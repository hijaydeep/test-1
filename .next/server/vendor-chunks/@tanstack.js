"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compareItems: () => (/* binding */ compareItems),\n/* harmony export */   rankItem: () => (/* binding */ rankItem),\n/* harmony export */   rankings: () => (/* binding */ rankings)\n/* harmony export */ });\n/**\n   * match-sorter-utils\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ const characterMap = {\n    À: \"A\",\n    Á: \"A\",\n    Â: \"A\",\n    Ã: \"A\",\n    Ä: \"A\",\n    Å: \"A\",\n    Ấ: \"A\",\n    Ắ: \"A\",\n    Ẳ: \"A\",\n    Ẵ: \"A\",\n    Ặ: \"A\",\n    Æ: \"AE\",\n    Ầ: \"A\",\n    Ằ: \"A\",\n    Ȃ: \"A\",\n    Ç: \"C\",\n    Ḉ: \"C\",\n    È: \"E\",\n    É: \"E\",\n    Ê: \"E\",\n    Ë: \"E\",\n    Ế: \"E\",\n    Ḗ: \"E\",\n    Ề: \"E\",\n    Ḕ: \"E\",\n    Ḝ: \"E\",\n    Ȇ: \"E\",\n    Ì: \"I\",\n    Í: \"I\",\n    Î: \"I\",\n    Ï: \"I\",\n    Ḯ: \"I\",\n    Ȋ: \"I\",\n    Ð: \"D\",\n    Ñ: \"N\",\n    Ò: \"O\",\n    Ó: \"O\",\n    Ô: \"O\",\n    Õ: \"O\",\n    Ö: \"O\",\n    Ø: \"O\",\n    Ố: \"O\",\n    Ṍ: \"O\",\n    Ṓ: \"O\",\n    Ȏ: \"O\",\n    Ù: \"U\",\n    Ú: \"U\",\n    Û: \"U\",\n    Ü: \"U\",\n    Ý: \"Y\",\n    à: \"a\",\n    á: \"a\",\n    â: \"a\",\n    ã: \"a\",\n    ä: \"a\",\n    å: \"a\",\n    ấ: \"a\",\n    ắ: \"a\",\n    ẳ: \"a\",\n    ẵ: \"a\",\n    ặ: \"a\",\n    æ: \"ae\",\n    ầ: \"a\",\n    ằ: \"a\",\n    ȃ: \"a\",\n    ç: \"c\",\n    ḉ: \"c\",\n    è: \"e\",\n    é: \"e\",\n    ê: \"e\",\n    ë: \"e\",\n    ế: \"e\",\n    ḗ: \"e\",\n    ề: \"e\",\n    ḕ: \"e\",\n    ḝ: \"e\",\n    ȇ: \"e\",\n    ì: \"i\",\n    í: \"i\",\n    î: \"i\",\n    ï: \"i\",\n    ḯ: \"i\",\n    ȋ: \"i\",\n    ð: \"d\",\n    ñ: \"n\",\n    ò: \"o\",\n    ó: \"o\",\n    ô: \"o\",\n    õ: \"o\",\n    ö: \"o\",\n    ø: \"o\",\n    ố: \"o\",\n    ṍ: \"o\",\n    ṓ: \"o\",\n    ȏ: \"o\",\n    ù: \"u\",\n    ú: \"u\",\n    û: \"u\",\n    ü: \"u\",\n    ý: \"y\",\n    ÿ: \"y\",\n    Ā: \"A\",\n    ā: \"a\",\n    Ă: \"A\",\n    ă: \"a\",\n    Ą: \"A\",\n    ą: \"a\",\n    Ć: \"C\",\n    ć: \"c\",\n    Ĉ: \"C\",\n    ĉ: \"c\",\n    Ċ: \"C\",\n    ċ: \"c\",\n    Č: \"C\",\n    č: \"c\",\n    C̆: \"C\",\n    c̆: \"c\",\n    Ď: \"D\",\n    ď: \"d\",\n    Đ: \"D\",\n    đ: \"d\",\n    Ē: \"E\",\n    ē: \"e\",\n    Ĕ: \"E\",\n    ĕ: \"e\",\n    Ė: \"E\",\n    ė: \"e\",\n    Ę: \"E\",\n    ę: \"e\",\n    Ě: \"E\",\n    ě: \"e\",\n    Ĝ: \"G\",\n    Ǵ: \"G\",\n    ĝ: \"g\",\n    ǵ: \"g\",\n    Ğ: \"G\",\n    ğ: \"g\",\n    Ġ: \"G\",\n    ġ: \"g\",\n    Ģ: \"G\",\n    ģ: \"g\",\n    Ĥ: \"H\",\n    ĥ: \"h\",\n    Ħ: \"H\",\n    ħ: \"h\",\n    Ḫ: \"H\",\n    ḫ: \"h\",\n    Ĩ: \"I\",\n    ĩ: \"i\",\n    Ī: \"I\",\n    ī: \"i\",\n    Ĭ: \"I\",\n    ĭ: \"i\",\n    Į: \"I\",\n    į: \"i\",\n    İ: \"I\",\n    ı: \"i\",\n    Ĳ: \"IJ\",\n    ĳ: \"ij\",\n    Ĵ: \"J\",\n    ĵ: \"j\",\n    Ķ: \"K\",\n    ķ: \"k\",\n    Ḱ: \"K\",\n    ḱ: \"k\",\n    K̆: \"K\",\n    k̆: \"k\",\n    Ĺ: \"L\",\n    ĺ: \"l\",\n    Ļ: \"L\",\n    ļ: \"l\",\n    Ľ: \"L\",\n    ľ: \"l\",\n    Ŀ: \"L\",\n    ŀ: \"l\",\n    Ł: \"l\",\n    ł: \"l\",\n    Ḿ: \"M\",\n    ḿ: \"m\",\n    M̆: \"M\",\n    m̆: \"m\",\n    Ń: \"N\",\n    ń: \"n\",\n    Ņ: \"N\",\n    ņ: \"n\",\n    Ň: \"N\",\n    ň: \"n\",\n    ŉ: \"n\",\n    N̆: \"N\",\n    n̆: \"n\",\n    Ō: \"O\",\n    ō: \"o\",\n    Ŏ: \"O\",\n    ŏ: \"o\",\n    Ő: \"O\",\n    ő: \"o\",\n    Œ: \"OE\",\n    œ: \"oe\",\n    P̆: \"P\",\n    p̆: \"p\",\n    Ŕ: \"R\",\n    ŕ: \"r\",\n    Ŗ: \"R\",\n    ŗ: \"r\",\n    Ř: \"R\",\n    ř: \"r\",\n    R̆: \"R\",\n    r̆: \"r\",\n    Ȓ: \"R\",\n    ȓ: \"r\",\n    Ś: \"S\",\n    ś: \"s\",\n    Ŝ: \"S\",\n    ŝ: \"s\",\n    Ş: \"S\",\n    Ș: \"S\",\n    ș: \"s\",\n    ş: \"s\",\n    Š: \"S\",\n    š: \"s\",\n    Ţ: \"T\",\n    ţ: \"t\",\n    ț: \"t\",\n    Ț: \"T\",\n    Ť: \"T\",\n    ť: \"t\",\n    Ŧ: \"T\",\n    ŧ: \"t\",\n    T̆: \"T\",\n    t̆: \"t\",\n    Ũ: \"U\",\n    ũ: \"u\",\n    Ū: \"U\",\n    ū: \"u\",\n    Ŭ: \"U\",\n    ŭ: \"u\",\n    Ů: \"U\",\n    ů: \"u\",\n    Ű: \"U\",\n    ű: \"u\",\n    Ų: \"U\",\n    ų: \"u\",\n    Ȗ: \"U\",\n    ȗ: \"u\",\n    V̆: \"V\",\n    v̆: \"v\",\n    Ŵ: \"W\",\n    ŵ: \"w\",\n    Ẃ: \"W\",\n    ẃ: \"w\",\n    X̆: \"X\",\n    x̆: \"x\",\n    Ŷ: \"Y\",\n    ŷ: \"y\",\n    Ÿ: \"Y\",\n    Y̆: \"Y\",\n    y̆: \"y\",\n    Ź: \"Z\",\n    ź: \"z\",\n    Ż: \"Z\",\n    ż: \"z\",\n    Ž: \"Z\",\n    ž: \"z\",\n    ſ: \"s\",\n    ƒ: \"f\",\n    Ơ: \"O\",\n    ơ: \"o\",\n    Ư: \"U\",\n    ư: \"u\",\n    Ǎ: \"A\",\n    ǎ: \"a\",\n    Ǐ: \"I\",\n    ǐ: \"i\",\n    Ǒ: \"O\",\n    ǒ: \"o\",\n    Ǔ: \"U\",\n    ǔ: \"u\",\n    Ǖ: \"U\",\n    ǖ: \"u\",\n    Ǘ: \"U\",\n    ǘ: \"u\",\n    Ǚ: \"U\",\n    ǚ: \"u\",\n    Ǜ: \"U\",\n    ǜ: \"u\",\n    Ứ: \"U\",\n    ứ: \"u\",\n    Ṹ: \"U\",\n    ṹ: \"u\",\n    Ǻ: \"A\",\n    ǻ: \"a\",\n    Ǽ: \"AE\",\n    ǽ: \"ae\",\n    Ǿ: \"O\",\n    ǿ: \"o\",\n    Þ: \"TH\",\n    þ: \"th\",\n    Ṕ: \"P\",\n    ṕ: \"p\",\n    Ṥ: \"S\",\n    ṥ: \"s\",\n    X́: \"X\",\n    x́: \"x\",\n    Ѓ: \"Г\",\n    ѓ: \"г\",\n    Ќ: \"К\",\n    ќ: \"к\",\n    A̋: \"A\",\n    a̋: \"a\",\n    E̋: \"E\",\n    e̋: \"e\",\n    I̋: \"I\",\n    i̋: \"i\",\n    Ǹ: \"N\",\n    ǹ: \"n\",\n    Ồ: \"O\",\n    ồ: \"o\",\n    Ṑ: \"O\",\n    ṑ: \"o\",\n    Ừ: \"U\",\n    ừ: \"u\",\n    Ẁ: \"W\",\n    ẁ: \"w\",\n    Ỳ: \"Y\",\n    ỳ: \"y\",\n    Ȁ: \"A\",\n    ȁ: \"a\",\n    Ȅ: \"E\",\n    ȅ: \"e\",\n    Ȉ: \"I\",\n    ȉ: \"i\",\n    Ȍ: \"O\",\n    ȍ: \"o\",\n    Ȑ: \"R\",\n    ȑ: \"r\",\n    Ȕ: \"U\",\n    ȕ: \"u\",\n    B̌: \"B\",\n    b̌: \"b\",\n    Č̣: \"C\",\n    č̣: \"c\",\n    Ê̌: \"E\",\n    ê̌: \"e\",\n    F̌: \"F\",\n    f̌: \"f\",\n    Ǧ: \"G\",\n    ǧ: \"g\",\n    Ȟ: \"H\",\n    ȟ: \"h\",\n    J̌: \"J\",\n    ǰ: \"j\",\n    Ǩ: \"K\",\n    ǩ: \"k\",\n    M̌: \"M\",\n    m̌: \"m\",\n    P̌: \"P\",\n    p̌: \"p\",\n    Q̌: \"Q\",\n    q̌: \"q\",\n    Ř̩: \"R\",\n    ř̩: \"r\",\n    Ṧ: \"S\",\n    ṧ: \"s\",\n    V̌: \"V\",\n    v̌: \"v\",\n    W̌: \"W\",\n    w̌: \"w\",\n    X̌: \"X\",\n    x̌: \"x\",\n    Y̌: \"Y\",\n    y̌: \"y\",\n    A̧: \"A\",\n    a̧: \"a\",\n    B̧: \"B\",\n    b̧: \"b\",\n    Ḑ: \"D\",\n    ḑ: \"d\",\n    Ȩ: \"E\",\n    ȩ: \"e\",\n    Ɛ̧: \"E\",\n    ɛ̧: \"e\",\n    Ḩ: \"H\",\n    ḩ: \"h\",\n    I̧: \"I\",\n    i̧: \"i\",\n    Ɨ̧: \"I\",\n    ɨ̧: \"i\",\n    M̧: \"M\",\n    m̧: \"m\",\n    O̧: \"O\",\n    o̧: \"o\",\n    Q̧: \"Q\",\n    q̧: \"q\",\n    U̧: \"U\",\n    u̧: \"u\",\n    X̧: \"X\",\n    x̧: \"x\",\n    Z̧: \"Z\",\n    z̧: \"z\"\n};\nconst chars = Object.keys(characterMap).join(\"|\");\nconst allAccents = new RegExp(chars, \"g\");\nfunction removeAccents(str) {\n    return str.replace(allAccents, (match)=>{\n        return characterMap[match];\n    });\n}\n/**\n * @name match-sorter\n * @license MIT license.\n * @copyright (c) 2099 Kent C. Dodds\n * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)\n */ const rankings = {\n    CASE_SENSITIVE_EQUAL: 7,\n    EQUAL: 6,\n    STARTS_WITH: 5,\n    WORD_STARTS_WITH: 4,\n    CONTAINS: 3,\n    ACRONYM: 2,\n    MATCHES: 1,\n    NO_MATCH: 0\n};\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, accessorIndex: Number, accessorThreshold: Number}} - the highest ranking\n */ function rankItem(item, value, options) {\n    var _options$threshold;\n    options = options || {};\n    options.threshold = (_options$threshold = options.threshold) != null ? _options$threshold : rankings.MATCHES;\n    if (!options.accessors) {\n        // if keys is not specified, then we assume the item given is ready to be matched\n        const rank = getMatchRanking(item, value, options);\n        return {\n            // ends up being duplicate of 'item' in matches but consistent\n            rankedValue: item,\n            rank,\n            accessorIndex: -1,\n            accessorThreshold: options.threshold,\n            passed: rank >= options.threshold\n        };\n    }\n    const valuesToRank = getAllValuesToRank(item, options.accessors);\n    const rankingInfo = {\n        rankedValue: item,\n        rank: rankings.NO_MATCH,\n        accessorIndex: -1,\n        accessorThreshold: options.threshold,\n        passed: false\n    };\n    for(let i = 0; i < valuesToRank.length; i++){\n        const rankValue = valuesToRank[i];\n        let newRank = getMatchRanking(rankValue.itemValue, value, options);\n        const { minRanking, maxRanking, threshold = options.threshold } = rankValue.attributes;\n        if (newRank < minRanking && newRank >= rankings.MATCHES) {\n            newRank = minRanking;\n        } else if (newRank > maxRanking) {\n            newRank = maxRanking;\n        }\n        newRank = Math.min(newRank, maxRanking);\n        if (newRank >= threshold && newRank > rankingInfo.rank) {\n            rankingInfo.rank = newRank;\n            rankingInfo.passed = true;\n            rankingInfo.accessorIndex = i;\n            rankingInfo.accessorThreshold = threshold;\n            rankingInfo.rankedValue = rankValue.itemValue;\n        }\n    }\n    return rankingInfo;\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */ function getMatchRanking(testString, stringToRank, options) {\n    testString = prepareValueForComparison(testString, options);\n    stringToRank = prepareValueForComparison(stringToRank, options);\n    // too long\n    if (stringToRank.length > testString.length) {\n        return rankings.NO_MATCH;\n    }\n    // case sensitive equals\n    if (testString === stringToRank) {\n        return rankings.CASE_SENSITIVE_EQUAL;\n    }\n    // Lower casing before further comparison\n    testString = testString.toLowerCase();\n    stringToRank = stringToRank.toLowerCase();\n    // case insensitive equals\n    if (testString === stringToRank) {\n        return rankings.EQUAL;\n    }\n    // starts with\n    if (testString.startsWith(stringToRank)) {\n        return rankings.STARTS_WITH;\n    }\n    // word starts with\n    if (testString.includes(` ${stringToRank}`)) {\n        return rankings.WORD_STARTS_WITH;\n    }\n    // contains\n    if (testString.includes(stringToRank)) {\n        return rankings.CONTAINS;\n    } else if (stringToRank.length === 1) {\n        // If the only character in the given stringToRank\n        //   isn't even contained in the testString, then\n        //   it's definitely not a match.\n        return rankings.NO_MATCH;\n    }\n    // acronym\n    if (getAcronym(testString).includes(stringToRank)) {\n        return rankings.ACRONYM;\n    }\n    // will return a number between rankings.MATCHES and\n    // rankings.MATCHES + 1 depending  on how close of a match it is.\n    return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */ function getAcronym(string) {\n    let acronym = \"\";\n    const wordsInString = string.split(\" \");\n    wordsInString.forEach((wordInString)=>{\n        const splitByHyphenWords = wordInString.split(\"-\");\n        splitByHyphenWords.forEach((splitByHyphenWord)=>{\n            acronym += splitByHyphenWord.substr(0, 1);\n        });\n    });\n    return acronym;\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */ function getClosenessRanking(testString, stringToRank) {\n    let matchingInOrderCharCount = 0;\n    let charNumber = 0;\n    function findMatchingCharacter(matchChar, string, index) {\n        for(let j = index, J = string.length; j < J; j++){\n            const stringChar = string[j];\n            if (stringChar === matchChar) {\n                matchingInOrderCharCount += 1;\n                return j + 1;\n            }\n        }\n        return -1;\n    }\n    function getRanking(spread) {\n        const spreadPercentage = 1 / spread;\n        const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n        const ranking = rankings.MATCHES + inOrderPercentage * spreadPercentage;\n        return ranking;\n    }\n    const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n    if (firstIndex < 0) {\n        return rankings.NO_MATCH;\n    }\n    charNumber = firstIndex;\n    for(let i = 1, I = stringToRank.length; i < I; i++){\n        const matchChar = stringToRank[i];\n        charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n        const found = charNumber > -1;\n        if (!found) {\n            return rankings.NO_MATCH;\n        }\n    }\n    const spread = charNumber - firstIndex;\n    return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and accessorIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */ function compareItems(a, b) {\n    return a.rank === b.rank ? 0 : a.rank > b.rank ? -1 : 1;\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */ function prepareValueForComparison(value, _ref) {\n    let { keepDiacritics } = _ref;\n    // value might not actually be a string at this point (we don't get to choose)\n    // so part of preparing the value for comparison is ensure that it is a string\n    value = `${value}`; // toString\n    if (!keepDiacritics) {\n        value = removeAccents(value);\n    }\n    return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */ function getItemValues(item, accessor) {\n    let accessorFn = accessor;\n    if (typeof accessor === \"object\") {\n        accessorFn = accessor.accessor;\n    }\n    const value = accessorFn(item);\n    // because `value` can also be undefined\n    if (value == null) {\n        return [];\n    }\n    if (Array.isArray(value)) {\n        return value;\n    }\n    return [\n        String(value)\n    ];\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param item - the item from which the values will be retrieved\n * @param keys - the keys to use to retrieve the values\n * @return objects with {itemValue, attributes}\n */ function getAllValuesToRank(item, accessors) {\n    const allValues = [];\n    for(let j = 0, J = accessors.length; j < J; j++){\n        const accessor = accessors[j];\n        const attributes = getAccessorAttributes(accessor);\n        const itemValues = getItemValues(item, accessor);\n        for(let i = 0, I = itemValues.length; i < I; i++){\n            allValues.push({\n                itemValue: itemValues[i],\n                attributes\n            });\n        }\n    }\n    return allValues;\n}\nconst defaultKeyAttributes = {\n    maxRanking: Infinity,\n    minRanking: -Infinity\n};\n/**\n * Gets all the attributes for the given accessor\n * @param accessor - the accessor from which the attributes will be retrieved\n * @return object containing the accessor's attributes\n */ function getAccessorAttributes(accessor) {\n    if (typeof accessor === \"function\") {\n        return defaultKeyAttributes;\n    }\n    return {\n        ...defaultKeyAttributes,\n        ...accessor\n    };\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL21hdGNoLXNvcnRlci11dGlscy9idWlsZC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7R0FTRyxHQUNILE1BQU1BLGVBQWU7SUFDbkJDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxHQUFHO0lBQ0hDLEdBQUc7SUFDSEMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLEdBQUc7SUFDSEMsR0FBRztJQUNIQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJ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QUFVLENBQUN4RCxFQUFFO2dCQUN4Qk87WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPK0M7QUFDVDtBQUNBLE1BQU1JLHVCQUF1QjtJQUMzQnBELFlBQVlxRDtJQUNadEQsWUFBWSxDQUFDc0Q7QUFDZjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTSixzQkFBc0JOLFFBQVE7SUFDckMsSUFBSSxPQUFPQSxhQUFhLFlBQVk7UUFDbEMsT0FBT1M7SUFDVDtJQUNBLE9BQU87UUFDTCxHQUFHQSxvQkFBb0I7UUFDdkIsR0FBR1QsUUFBUTtJQUNiO0FBQ0Y7QUFFNEMsQ0FDNUMsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWF0ZXJpby1tdWktcmVhY3QtbmV4dGpzLWFkbWluLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay9tYXRjaC1zb3J0ZXItdXRpbHMvYnVpbGQvbGliL2luZGV4Lm1qcz9iMmJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgKiBtYXRjaC1zb3J0ZXItdXRpbHNcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKlxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovXG5jb25zdCBjaGFyYWN0ZXJNYXAgPSB7XG4gIMOAOiAnQScsXG4gIMOBOiAnQScsXG4gIMOCOiAnQScsXG4gIMODOiAnQScsXG4gIMOEOiAnQScsXG4gIMOFOiAnQScsXG4gIOG6pDogJ0EnLFxuICDhuq46ICdBJyxcbiAg4bqyOiAnQScsXG4gIOG6tDogJ0EnLFxuICDhurY6ICdBJyxcbiAgw4Y6ICdBRScsXG4gIOG6pjogJ0EnLFxuICDhurA6ICdBJyxcbiAgyII6ICdBJyxcbiAgw4c6ICdDJyxcbiAg4biIOiAnQycsXG4gIMOIOiAnRScsXG4gIMOJOiAnRScsXG4gIMOKOiAnRScsXG4gIMOLOiAnRScsXG4gIOG6vjogJ0UnLFxuICDhuJY6ICdFJyxcbiAg4buAOiAnRScsXG4gIOG4lDogJ0UnLFxuICDhuJw6ICdFJyxcbiAgyIY6ICdFJyxcbiAgw4w6ICdJJyxcbiAgw406ICdJJyxcbiAgw446ICdJJyxcbiAgw486ICdJJyxcbiAg4biuOiAnSScsXG4gIMiKOiAnSScsXG4gIMOQOiAnRCcsXG4gIMOROiAnTicsXG4gIMOSOiAnTycsXG4gIMOTOiAnTycsXG4gIMOUOiAnTycsXG4gIMOVOiAnTycsXG4gIMOWOiAnTycsXG4gIMOYOiAnTycsXG4gIOG7kDogJ08nLFxuICDhuYw6ICdPJyxcbiAg4bmSOiAnTycsXG4gIMiOOiAnTycsXG4gIMOZOiAnVScsXG4gIMOaOiAnVScsXG4gIMObOiAnVScsXG4gIMOcOiAnVScsXG4gIMOdOiAnWScsXG4gIMOgOiAnYScsXG4gIMOhOiAnYScsXG4gIMOiOiAnYScsXG4gIMOjOiAnYScsXG4gIMOkOiAnYScsXG4gIMOlOiAnYScsXG4gIOG6pTogJ2EnLFxuICDhuq86ICdhJyxcbiAg4bqzOiAnYScsXG4gIOG6tTogJ2EnLFxuICDhurc6ICdhJyxcbiAgw6Y6ICdhZScsXG4gIOG6pzogJ2EnLFxuICDhurE6ICdhJyxcbiAgyIM6ICdhJyxcbiAgw6c6ICdjJyxcbiAg4biJOiAnYycsXG4gIMOoOiAnZScsXG4gIMOpOiAnZScsXG4gIMOqOiAnZScsXG4gIMOrOiAnZScsXG4gIOG6vzogJ2UnLFxuICDhuJc6ICdlJyxcbiAg4buBOiAnZScsXG4gIOG4lTogJ2UnLFxuICDhuJ06ICdlJyxcbiAgyIc6ICdlJyxcbiAgw6w6ICdpJyxcbiAgw606ICdpJyxcbiAgw646ICdpJyxcbiAgw686ICdpJyxcbiAg4bivOiAnaScsXG4gIMiLOiAnaScsXG4gIMOwOiAnZCcsXG4gIMOxOiAnbicsXG4gIMOyOiAnbycsXG4gIMOzOiAnbycsXG4gIMO0OiAnbycsXG4gIMO1OiAnbycsXG4gIMO2OiAnbycsXG4gIMO4OiAnbycsXG4gIOG7kTogJ28nLFxuICDhuY06ICdvJyxcbiAg4bmTOiAnbycsXG4gIMiPOiAnbycsXG4gIMO5OiAndScsXG4gIMO6OiAndScsXG4gIMO7OiAndScsXG4gIMO8OiAndScsXG4gIMO9OiAneScsXG4gIMO/OiAneScsXG4gIMSAOiAnQScsXG4gIMSBOiAnYScsXG4gIMSCOiAnQScsXG4gIMSDOiAnYScsXG4gIMSEOiAnQScsXG4gIMSFOiAnYScsXG4gIMSGOiAnQycsXG4gIMSHOiAnYycsXG4gIMSIOiAnQycsXG4gIMSJOiAnYycsXG4gIMSKOiAnQycsXG4gIMSLOiAnYycsXG4gIMSMOiAnQycsXG4gIMSNOiAnYycsXG4gIEPMhjogJ0MnLFxuICBjzIY6ICdjJyxcbiAgxI46ICdEJyxcbiAgxI86ICdkJyxcbiAgxJA6ICdEJyxcbiAgxJE6ICdkJyxcbiAgxJI6ICdFJyxcbiAgxJM6ICdlJyxcbiAgxJQ6ICdFJyxcbiAgxJU6ICdlJyxcbiAgxJY6ICdFJyxcbiAgxJc6ICdlJyxcbiAgxJg6ICdFJyxcbiAgxJk6ICdlJyxcbiAgxJo6ICdFJyxcbiAgxJs6ICdlJyxcbiAgxJw6ICdHJyxcbiAgx7Q6ICdHJyxcbiAgxJ06ICdnJyxcbiAgx7U6ICdnJyxcbiAgxJ46ICdHJyxcbiAgxJ86ICdnJyxcbiAgxKA6ICdHJyxcbiAgxKE6ICdnJyxcbiAgxKI6ICdHJyxcbiAgxKM6ICdnJyxcbiAgxKQ6ICdIJyxcbiAgxKU6ICdoJyxcbiAgxKY6ICdIJyxcbiAgxKc6ICdoJyxcbiAg4biqOiAnSCcsXG4gIOG4qzogJ2gnLFxuICDEqDogJ0knLFxuICDEqTogJ2knLFxuICDEqjogJ0knLFxuICDEqzogJ2knLFxuICDErDogJ0knLFxuICDErTogJ2knLFxuICDErjogJ0knLFxuICDErzogJ2knLFxuICDEsDogJ0knLFxuICDEsTogJ2knLFxuICDEsjogJ0lKJyxcbiAgxLM6ICdpaicsXG4gIMS0OiAnSicsXG4gIMS1OiAnaicsXG4gIMS2OiAnSycsXG4gIMS3OiAnaycsXG4gIOG4sDogJ0snLFxuICDhuLE6ICdrJyxcbiAgS8yGOiAnSycsXG4gIGvMhjogJ2snLFxuICDEuTogJ0wnLFxuICDEujogJ2wnLFxuICDEuzogJ0wnLFxuICDEvDogJ2wnLFxuICDEvTogJ0wnLFxuICDEvjogJ2wnLFxuICDEvzogJ0wnLFxuICDFgDogJ2wnLFxuICDFgTogJ2wnLFxuICDFgjogJ2wnLFxuICDhuL46ICdNJyxcbiAg4bi/OiAnbScsXG4gIE3MhjogJ00nLFxuICBtzIY6ICdtJyxcbiAgxYM6ICdOJyxcbiAgxYQ6ICduJyxcbiAgxYU6ICdOJyxcbiAgxYY6ICduJyxcbiAgxYc6ICdOJyxcbiAgxYg6ICduJyxcbiAgxYk6ICduJyxcbiAgTsyGOiAnTicsXG4gIG7MhjogJ24nLFxuICDFjDogJ08nLFxuICDFjTogJ28nLFxuICDFjjogJ08nLFxuICDFjzogJ28nLFxuICDFkDogJ08nLFxuICDFkTogJ28nLFxuICDFkjogJ09FJyxcbiAgxZM6ICdvZScsXG4gIFDMhjogJ1AnLFxuICBwzIY6ICdwJyxcbiAgxZQ6ICdSJyxcbiAgxZU6ICdyJyxcbiAgxZY6ICdSJyxcbiAgxZc6ICdyJyxcbiAgxZg6ICdSJyxcbiAgxZk6ICdyJyxcbiAgUsyGOiAnUicsXG4gIHLMhjogJ3InLFxuICDIkjogJ1InLFxuICDIkzogJ3InLFxuICDFmjogJ1MnLFxuICDFmzogJ3MnLFxuICDFnDogJ1MnLFxuICDFnTogJ3MnLFxuICDFnjogJ1MnLFxuICDImDogJ1MnLFxuICDImTogJ3MnLFxuICDFnzogJ3MnLFxuICDFoDogJ1MnLFxuICDFoTogJ3MnLFxuICDFojogJ1QnLFxuICDFozogJ3QnLFxuICDImzogJ3QnLFxuICDImjogJ1QnLFxuICDFpDogJ1QnLFxuICDFpTogJ3QnLFxuICDFpjogJ1QnLFxuICDFpzogJ3QnLFxuICBUzIY6ICdUJyxcbiAgdMyGOiAndCcsXG4gIMWoOiAnVScsXG4gIMWpOiAndScsXG4gIMWqOiAnVScsXG4gIMWrOiAndScsXG4gIMWsOiAnVScsXG4gIMWtOiAndScsXG4gIMWuOiAnVScsXG4gIMWvOiAndScsXG4gIMWwOiAnVScsXG4gIMWxOiAndScsXG4gIMWyOiAnVScsXG4gIMWzOiAndScsXG4gIMiWOiAnVScsXG4gIMiXOiAndScsXG4gIFbMhjogJ1YnLFxuICB2zIY6ICd2JyxcbiAgxbQ6ICdXJyxcbiAgxbU6ICd3JyxcbiAg4bqCOiAnVycsXG4gIOG6gzogJ3cnLFxuICBYzIY6ICdYJyxcbiAgeMyGOiAneCcsXG4gIMW2OiAnWScsXG4gIMW3OiAneScsXG4gIMW4OiAnWScsXG4gIFnMhjogJ1knLFxuICB5zIY6ICd5JyxcbiAgxbk6ICdaJyxcbiAgxbo6ICd6JyxcbiAgxbs6ICdaJyxcbiAgxbw6ICd6JyxcbiAgxb06ICdaJyxcbiAgxb46ICd6JyxcbiAgxb86ICdzJyxcbiAgxpI6ICdmJyxcbiAgxqA6ICdPJyxcbiAgxqE6ICdvJyxcbiAgxq86ICdVJyxcbiAgxrA6ICd1JyxcbiAgx406ICdBJyxcbiAgx446ICdhJyxcbiAgx486ICdJJyxcbiAgx5A6ICdpJyxcbiAgx5E6ICdPJyxcbiAgx5I6ICdvJyxcbiAgx5M6ICdVJyxcbiAgx5Q6ICd1JyxcbiAgx5U6ICdVJyxcbiAgx5Y6ICd1JyxcbiAgx5c6ICdVJyxcbiAgx5g6ICd1JyxcbiAgx5k6ICdVJyxcbiAgx5o6ICd1JyxcbiAgx5s6ICdVJyxcbiAgx5w6ICd1JyxcbiAg4buoOiAnVScsXG4gIOG7qTogJ3UnLFxuICDhubg6ICdVJyxcbiAg4bm5OiAndScsXG4gIMe6OiAnQScsXG4gIMe7OiAnYScsXG4gIMe8OiAnQUUnLFxuICDHvTogJ2FlJyxcbiAgx746ICdPJyxcbiAgx786ICdvJyxcbiAgw546ICdUSCcsXG4gIMO+OiAndGgnLFxuICDhuZQ6ICdQJyxcbiAg4bmVOiAncCcsXG4gIOG5pDogJ1MnLFxuICDhuaU6ICdzJyxcbiAgWMyBOiAnWCcsXG4gIHjMgTogJ3gnLFxuICDQgzogJ9CTJyxcbiAg0ZM6ICfQsycsXG4gINCMOiAn0JonLFxuICDRnDogJ9C6JyxcbiAgQcyLOiAnQScsXG4gIGHMizogJ2EnLFxuICBFzIs6ICdFJyxcbiAgZcyLOiAnZScsXG4gIEnMizogJ0knLFxuICBpzIs6ICdpJyxcbiAgx7g6ICdOJyxcbiAgx7k6ICduJyxcbiAg4buSOiAnTycsXG4gIOG7kzogJ28nLFxuICDhuZA6ICdPJyxcbiAg4bmROiAnbycsXG4gIOG7qjogJ1UnLFxuICDhu6s6ICd1JyxcbiAg4bqAOiAnVycsXG4gIOG6gTogJ3cnLFxuICDhu7I6ICdZJyxcbiAg4buzOiAneScsXG4gIMiAOiAnQScsXG4gIMiBOiAnYScsXG4gIMiEOiAnRScsXG4gIMiFOiAnZScsXG4gIMiIOiAnSScsXG4gIMiJOiAnaScsXG4gIMiMOiAnTycsXG4gIMiNOiAnbycsXG4gIMiQOiAnUicsXG4gIMiROiAncicsXG4gIMiUOiAnVScsXG4gIMiVOiAndScsXG4gIELMjDogJ0InLFxuICBizIw6ICdiJyxcbiAgxIzMozogJ0MnLFxuICDEjcyjOiAnYycsXG4gIMOKzIw6ICdFJyxcbiAgw6rMjDogJ2UnLFxuICBGzIw6ICdGJyxcbiAgZsyMOiAnZicsXG4gIMemOiAnRycsXG4gIMenOiAnZycsXG4gIMieOiAnSCcsXG4gIMifOiAnaCcsXG4gIErMjDogJ0onLFxuICDHsDogJ2onLFxuICDHqDogJ0snLFxuICDHqTogJ2snLFxuICBNzIw6ICdNJyxcbiAgbcyMOiAnbScsXG4gIFDMjDogJ1AnLFxuICBwzIw6ICdwJyxcbiAgUcyMOiAnUScsXG4gIHHMjDogJ3EnLFxuICDFmMypOiAnUicsXG4gIMWZzKk6ICdyJyxcbiAg4bmmOiAnUycsXG4gIOG5pzogJ3MnLFxuICBWzIw6ICdWJyxcbiAgdsyMOiAndicsXG4gIFfMjDogJ1cnLFxuICB3zIw6ICd3JyxcbiAgWMyMOiAnWCcsXG4gIHjMjDogJ3gnLFxuICBZzIw6ICdZJyxcbiAgecyMOiAneScsXG4gIEHMpzogJ0EnLFxuICBhzKc6ICdhJyxcbiAgQsynOiAnQicsXG4gIGLMpzogJ2InLFxuICDhuJA6ICdEJyxcbiAg4biROiAnZCcsXG4gIMioOiAnRScsXG4gIMipOiAnZScsXG4gIMaQzKc6ICdFJyxcbiAgyZvMpzogJ2UnLFxuICDhuKg6ICdIJyxcbiAg4bipOiAnaCcsXG4gIEnMpzogJ0knLFxuICBpzKc6ICdpJyxcbiAgxpfMpzogJ0knLFxuICDJqMynOiAnaScsXG4gIE3MpzogJ00nLFxuICBtzKc6ICdtJyxcbiAgT8ynOiAnTycsXG4gIG/MpzogJ28nLFxuICBRzKc6ICdRJyxcbiAgccynOiAncScsXG4gIFXMpzogJ1UnLFxuICB1zKc6ICd1JyxcbiAgWMynOiAnWCcsXG4gIHjMpzogJ3gnLFxuICBazKc6ICdaJyxcbiAgesynOiAneidcbn07XG5jb25zdCBjaGFycyA9IE9iamVjdC5rZXlzKGNoYXJhY3Rlck1hcCkuam9pbignfCcpO1xuY29uc3QgYWxsQWNjZW50cyA9IG5ldyBSZWdFeHAoY2hhcnMsICdnJyk7XG5mdW5jdGlvbiByZW1vdmVBY2NlbnRzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoYWxsQWNjZW50cywgbWF0Y2ggPT4ge1xuICAgIHJldHVybiBjaGFyYWN0ZXJNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAbmFtZSBtYXRjaC1zb3J0ZXJcbiAqIEBsaWNlbnNlIE1JVCBsaWNlbnNlLlxuICogQGNvcHlyaWdodCAoYykgMjA5OSBLZW50IEMuIERvZGRzXG4gKiBAYXV0aG9yIEtlbnQgQy4gRG9kZHMgPG1lQGtlbnRjZG9kZHMuY29tPiAoaHR0cHM6Ly9rZW50Y2RvZGRzLmNvbSlcbiAqL1xuXG5jb25zdCByYW5raW5ncyA9IHtcbiAgQ0FTRV9TRU5TSVRJVkVfRVFVQUw6IDcsXG4gIEVRVUFMOiA2LFxuICBTVEFSVFNfV0lUSDogNSxcbiAgV09SRF9TVEFSVFNfV0lUSDogNCxcbiAgQ09OVEFJTlM6IDMsXG4gIEFDUk9OWU06IDIsXG4gIE1BVENIRVM6IDEsXG4gIE5PX01BVENIOiAwXG59O1xuLyoqXG4gKiBHZXRzIHRoZSBoaWdoZXN0IHJhbmtpbmcgZm9yIHZhbHVlIGZvciB0aGUgZ2l2ZW4gaXRlbSBiYXNlZCBvbiBpdHMgdmFsdWVzIGZvciB0aGUgZ2l2ZW4ga2V5c1xuICogQHBhcmFtIHsqfSBpdGVtIC0gdGhlIGl0ZW0gdG8gcmFua1xuICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIHRoZSBrZXlzIHRvIGdldCB2YWx1ZXMgZnJvbSB0aGUgaXRlbSBmb3IgdGhlIHJhbmtpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byByYW5rIGFnYWluc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0byBjb250cm9sIHRoZSByYW5raW5nXG4gKiBAcmV0dXJuIHt7cmFuazogTnVtYmVyLCBhY2Nlc3NvckluZGV4OiBOdW1iZXIsIGFjY2Vzc29yVGhyZXNob2xkOiBOdW1iZXJ9fSAtIHRoZSBoaWdoZXN0IHJhbmtpbmdcbiAqL1xuZnVuY3Rpb24gcmFua0l0ZW0oaXRlbSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJHRocmVzaG9sZDtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMudGhyZXNob2xkID0gKF9vcHRpb25zJHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkKSAhPSBudWxsID8gX29wdGlvbnMkdGhyZXNob2xkIDogcmFua2luZ3MuTUFUQ0hFUztcbiAgaWYgKCFvcHRpb25zLmFjY2Vzc29ycykge1xuICAgIC8vIGlmIGtleXMgaXMgbm90IHNwZWNpZmllZCwgdGhlbiB3ZSBhc3N1bWUgdGhlIGl0ZW0gZ2l2ZW4gaXMgcmVhZHkgdG8gYmUgbWF0Y2hlZFxuICAgIGNvbnN0IHJhbmsgPSBnZXRNYXRjaFJhbmtpbmcoaXRlbSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBlbmRzIHVwIGJlaW5nIGR1cGxpY2F0ZSBvZiAnaXRlbScgaW4gbWF0Y2hlcyBidXQgY29uc2lzdGVudFxuICAgICAgcmFua2VkVmFsdWU6IGl0ZW0sXG4gICAgICByYW5rLFxuICAgICAgYWNjZXNzb3JJbmRleDogLTEsXG4gICAgICBhY2Nlc3NvclRocmVzaG9sZDogb3B0aW9ucy50aHJlc2hvbGQsXG4gICAgICBwYXNzZWQ6IHJhbmsgPj0gb3B0aW9ucy50aHJlc2hvbGRcbiAgICB9O1xuICB9XG4gIGNvbnN0IHZhbHVlc1RvUmFuayA9IGdldEFsbFZhbHVlc1RvUmFuayhpdGVtLCBvcHRpb25zLmFjY2Vzc29ycyk7XG4gIGNvbnN0IHJhbmtpbmdJbmZvID0ge1xuICAgIHJhbmtlZFZhbHVlOiBpdGVtLFxuICAgIHJhbms6IHJhbmtpbmdzLk5PX01BVENILFxuICAgIGFjY2Vzc29ySW5kZXg6IC0xLFxuICAgIGFjY2Vzc29yVGhyZXNob2xkOiBvcHRpb25zLnRocmVzaG9sZCxcbiAgICBwYXNzZWQ6IGZhbHNlXG4gIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzVG9SYW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcmFua1ZhbHVlID0gdmFsdWVzVG9SYW5rW2ldO1xuICAgIGxldCBuZXdSYW5rID0gZ2V0TWF0Y2hSYW5raW5nKHJhbmtWYWx1ZS5pdGVtVmFsdWUsIHZhbHVlLCBvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBtaW5SYW5raW5nLFxuICAgICAgbWF4UmFua2luZyxcbiAgICAgIHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkXG4gICAgfSA9IHJhbmtWYWx1ZS5hdHRyaWJ1dGVzO1xuICAgIGlmIChuZXdSYW5rIDwgbWluUmFua2luZyAmJiBuZXdSYW5rID49IHJhbmtpbmdzLk1BVENIRVMpIHtcbiAgICAgIG5ld1JhbmsgPSBtaW5SYW5raW5nO1xuICAgIH0gZWxzZSBpZiAobmV3UmFuayA+IG1heFJhbmtpbmcpIHtcbiAgICAgIG5ld1JhbmsgPSBtYXhSYW5raW5nO1xuICAgIH1cbiAgICBuZXdSYW5rID0gTWF0aC5taW4obmV3UmFuaywgbWF4UmFua2luZyk7XG4gICAgaWYgKG5ld1JhbmsgPj0gdGhyZXNob2xkICYmIG5ld1JhbmsgPiByYW5raW5nSW5mby5yYW5rKSB7XG4gICAgICByYW5raW5nSW5mby5yYW5rID0gbmV3UmFuaztcbiAgICAgIHJhbmtpbmdJbmZvLnBhc3NlZCA9IHRydWU7XG4gICAgICByYW5raW5nSW5mby5hY2Nlc3NvckluZGV4ID0gaTtcbiAgICAgIHJhbmtpbmdJbmZvLmFjY2Vzc29yVGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgICAgcmFua2luZ0luZm8ucmFua2VkVmFsdWUgPSByYW5rVmFsdWUuaXRlbVZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmFua2luZ0luZm87XG59XG5cbi8qKlxuICogR2l2ZXMgYSByYW5raW5ncyBzY29yZSBiYXNlZCBvbiBob3cgd2VsbCB0aGUgdHdvIHN0cmluZ3MgbWF0Y2guXG4gKiBAcGFyYW0ge1N0cmluZ30gdGVzdFN0cmluZyAtIHRoZSBzdHJpbmcgdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nVG9SYW5rIC0gdGhlIHN0cmluZyB0byByYW5rXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgZm9yIHRoZSBtYXRjaCAobGlrZSBrZWVwRGlhY3JpdGljcyBmb3IgY29tcGFyaXNvbilcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSByYW5raW5nIGZvciBob3cgd2VsbCBzdHJpbmdUb1JhbmsgbWF0Y2hlcyB0ZXN0U3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoUmFua2luZyh0ZXN0U3RyaW5nLCBzdHJpbmdUb1JhbmssIG9wdGlvbnMpIHtcbiAgdGVzdFN0cmluZyA9IHByZXBhcmVWYWx1ZUZvckNvbXBhcmlzb24odGVzdFN0cmluZywgb3B0aW9ucyk7XG4gIHN0cmluZ1RvUmFuayA9IHByZXBhcmVWYWx1ZUZvckNvbXBhcmlzb24oc3RyaW5nVG9SYW5rLCBvcHRpb25zKTtcblxuICAvLyB0b28gbG9uZ1xuICBpZiAoc3RyaW5nVG9SYW5rLmxlbmd0aCA+IHRlc3RTdHJpbmcubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLk5PX01BVENIO1xuICB9XG5cbiAgLy8gY2FzZSBzZW5zaXRpdmUgZXF1YWxzXG4gIGlmICh0ZXN0U3RyaW5nID09PSBzdHJpbmdUb1JhbmspIHtcbiAgICByZXR1cm4gcmFua2luZ3MuQ0FTRV9TRU5TSVRJVkVfRVFVQUw7XG4gIH1cblxuICAvLyBMb3dlciBjYXNpbmcgYmVmb3JlIGZ1cnRoZXIgY29tcGFyaXNvblxuICB0ZXN0U3RyaW5nID0gdGVzdFN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICBzdHJpbmdUb1JhbmsgPSBzdHJpbmdUb1JhbmsudG9Mb3dlckNhc2UoKTtcblxuICAvLyBjYXNlIGluc2Vuc2l0aXZlIGVxdWFsc1xuICBpZiAodGVzdFN0cmluZyA9PT0gc3RyaW5nVG9SYW5rKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLkVRVUFMO1xuICB9XG5cbiAgLy8gc3RhcnRzIHdpdGhcbiAgaWYgKHRlc3RTdHJpbmcuc3RhcnRzV2l0aChzdHJpbmdUb1JhbmspKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLlNUQVJUU19XSVRIO1xuICB9XG5cbiAgLy8gd29yZCBzdGFydHMgd2l0aFxuICBpZiAodGVzdFN0cmluZy5pbmNsdWRlcyhgICR7c3RyaW5nVG9SYW5rfWApKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLldPUkRfU1RBUlRTX1dJVEg7XG4gIH1cblxuICAvLyBjb250YWluc1xuICBpZiAodGVzdFN0cmluZy5pbmNsdWRlcyhzdHJpbmdUb1JhbmspKSB7XG4gICAgcmV0dXJuIHJhbmtpbmdzLkNPTlRBSU5TO1xuICB9IGVsc2UgaWYgKHN0cmluZ1RvUmFuay5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBJZiB0aGUgb25seSBjaGFyYWN0ZXIgaW4gdGhlIGdpdmVuIHN0cmluZ1RvUmFua1xuICAgIC8vICAgaXNuJ3QgZXZlbiBjb250YWluZWQgaW4gdGhlIHRlc3RTdHJpbmcsIHRoZW5cbiAgICAvLyAgIGl0J3MgZGVmaW5pdGVseSBub3QgYSBtYXRjaC5cbiAgICByZXR1cm4gcmFua2luZ3MuTk9fTUFUQ0g7XG4gIH1cblxuICAvLyBhY3JvbnltXG4gIGlmIChnZXRBY3JvbnltKHRlc3RTdHJpbmcpLmluY2x1ZGVzKHN0cmluZ1RvUmFuaykpIHtcbiAgICByZXR1cm4gcmFua2luZ3MuQUNST05ZTTtcbiAgfVxuXG4gIC8vIHdpbGwgcmV0dXJuIGEgbnVtYmVyIGJldHdlZW4gcmFua2luZ3MuTUFUQ0hFUyBhbmRcbiAgLy8gcmFua2luZ3MuTUFUQ0hFUyArIDEgZGVwZW5kaW5nICBvbiBob3cgY2xvc2Ugb2YgYSBtYXRjaCBpdCBpcy5cbiAgcmV0dXJuIGdldENsb3NlbmVzc1JhbmtpbmcodGVzdFN0cmluZywgc3RyaW5nVG9SYW5rKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWNyb255bSBmb3IgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0aGUgc3RyaW5nIGZvciB3aGljaCB0byBwcm9kdWNlIHRoZSBhY3JvbnltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgYWNyb255bVxuICovXG5mdW5jdGlvbiBnZXRBY3JvbnltKHN0cmluZykge1xuICBsZXQgYWNyb255bSA9ICcnO1xuICBjb25zdCB3b3Jkc0luU3RyaW5nID0gc3RyaW5nLnNwbGl0KCcgJyk7XG4gIHdvcmRzSW5TdHJpbmcuZm9yRWFjaCh3b3JkSW5TdHJpbmcgPT4ge1xuICAgIGNvbnN0IHNwbGl0QnlIeXBoZW5Xb3JkcyA9IHdvcmRJblN0cmluZy5zcGxpdCgnLScpO1xuICAgIHNwbGl0QnlIeXBoZW5Xb3Jkcy5mb3JFYWNoKHNwbGl0QnlIeXBoZW5Xb3JkID0+IHtcbiAgICAgIGFjcm9ueW0gKz0gc3BsaXRCeUh5cGhlbldvcmQuc3Vic3RyKDAsIDEpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGFjcm9ueW07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHNjb3JlIGJhc2VkIG9uIGhvdyBzcHJlYWQgYXBhcnQgdGhlXG4gKiBjaGFyYWN0ZXJzIGZyb20gdGhlIHN0cmluZ1RvUmFuayBhcmUgd2l0aGluIHRoZSB0ZXN0U3RyaW5nLlxuICogQSBudW1iZXIgY2xvc2UgdG8gcmFua2luZ3MuTUFUQ0hFUyByZXByZXNlbnRzIGEgbG9vc2UgbWF0Y2guIEEgbnVtYmVyIGNsb3NlXG4gKiB0byByYW5raW5ncy5NQVRDSEVTICsgMSByZXByZXNlbnRzIGEgdGlnaHRlciBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXN0U3RyaW5nIC0gdGhlIHN0cmluZyB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdUb1JhbmsgLSB0aGUgc3RyaW5nIHRvIHJhbmtcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgYmV0d2VlbiByYW5raW5ncy5NQVRDSEVTIGFuZFxuICogcmFua2luZ3MuTUFUQ0hFUyArIDEgZm9yIGhvdyB3ZWxsIHN0cmluZ1RvUmFuayBtYXRjaGVzIHRlc3RTdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VuZXNzUmFua2luZyh0ZXN0U3RyaW5nLCBzdHJpbmdUb1JhbmspIHtcbiAgbGV0IG1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCA9IDA7XG4gIGxldCBjaGFyTnVtYmVyID0gMDtcbiAgZnVuY3Rpb24gZmluZE1hdGNoaW5nQ2hhcmFjdGVyKG1hdGNoQ2hhciwgc3RyaW5nLCBpbmRleCkge1xuICAgIGZvciAobGV0IGogPSBpbmRleCwgSiA9IHN0cmluZy5sZW5ndGg7IGogPCBKOyBqKyspIHtcbiAgICAgIGNvbnN0IHN0cmluZ0NoYXIgPSBzdHJpbmdbal07XG4gICAgICBpZiAoc3RyaW5nQ2hhciA9PT0gbWF0Y2hDaGFyKSB7XG4gICAgICAgIG1hdGNoaW5nSW5PcmRlckNoYXJDb3VudCArPSAxO1xuICAgICAgICByZXR1cm4gaiArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmdW5jdGlvbiBnZXRSYW5raW5nKHNwcmVhZCkge1xuICAgIGNvbnN0IHNwcmVhZFBlcmNlbnRhZ2UgPSAxIC8gc3ByZWFkO1xuICAgIGNvbnN0IGluT3JkZXJQZXJjZW50YWdlID0gbWF0Y2hpbmdJbk9yZGVyQ2hhckNvdW50IC8gc3RyaW5nVG9SYW5rLmxlbmd0aDtcbiAgICBjb25zdCByYW5raW5nID0gcmFua2luZ3MuTUFUQ0hFUyArIGluT3JkZXJQZXJjZW50YWdlICogc3ByZWFkUGVyY2VudGFnZTtcbiAgICByZXR1cm4gcmFua2luZztcbiAgfVxuICBjb25zdCBmaXJzdEluZGV4ID0gZmluZE1hdGNoaW5nQ2hhcmFjdGVyKHN0cmluZ1RvUmFua1swXSwgdGVzdFN0cmluZywgMCk7XG4gIGlmIChmaXJzdEluZGV4IDwgMCkge1xuICAgIHJldHVybiByYW5raW5ncy5OT19NQVRDSDtcbiAgfVxuICBjaGFyTnVtYmVyID0gZmlyc3RJbmRleDtcbiAgZm9yIChsZXQgaSA9IDEsIEkgPSBzdHJpbmdUb1JhbmsubGVuZ3RoOyBpIDwgSTsgaSsrKSB7XG4gICAgY29uc3QgbWF0Y2hDaGFyID0gc3RyaW5nVG9SYW5rW2ldO1xuICAgIGNoYXJOdW1iZXIgPSBmaW5kTWF0Y2hpbmdDaGFyYWN0ZXIobWF0Y2hDaGFyLCB0ZXN0U3RyaW5nLCBjaGFyTnVtYmVyKTtcbiAgICBjb25zdCBmb3VuZCA9IGNoYXJOdW1iZXIgPiAtMTtcbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICByZXR1cm4gcmFua2luZ3MuTk9fTUFUQ0g7XG4gICAgfVxuICB9XG4gIGNvbnN0IHNwcmVhZCA9IGNoYXJOdW1iZXIgLSBmaXJzdEluZGV4O1xuICByZXR1cm4gZ2V0UmFua2luZyhzcHJlYWQpO1xufVxuXG4vKipcbiAqIFNvcnRzIGl0ZW1zIHRoYXQgaGF2ZSBhIHJhbmssIGluZGV4LCBhbmQgYWNjZXNzb3JJbmRleFxuICogQHBhcmFtIHtPYmplY3R9IGEgLSB0aGUgZmlyc3QgaXRlbSB0byBzb3J0XG4gKiBAcGFyYW0ge09iamVjdH0gYiAtIHRoZSBzZWNvbmQgaXRlbSB0byBzb3J0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IC0xIGlmIGEgc2hvdWxkIGNvbWUgZmlyc3QsIDEgaWYgYiBzaG91bGQgY29tZSBmaXJzdCwgMCBpZiBlcXVhbFxuICovXG5mdW5jdGlvbiBjb21wYXJlSXRlbXMoYSwgYikge1xuICByZXR1cm4gYS5yYW5rID09PSBiLnJhbmsgPyAwIDogYS5yYW5rID4gYi5yYW5rID8gLTEgOiAxO1xufVxuXG4vKipcbiAqIFByZXBhcmVzIHZhbHVlIGZvciBjb21wYXJpc29uIGJ5IHN0cmluZ2lmeWluZyBpdCwgcmVtb3ZpbmcgZGlhY3JpdGljcyAoaWYgc3BlY2lmaWVkKVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGNsZWFuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHtrZWVwRGlhY3JpdGljczogd2hldGhlciB0byByZW1vdmUgZGlhY3JpdGljc31cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHByZXBhcmVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmVWYWx1ZUZvckNvbXBhcmlzb24odmFsdWUsIF9yZWYpIHtcbiAgbGV0IHtcbiAgICBrZWVwRGlhY3JpdGljc1xuICB9ID0gX3JlZjtcbiAgLy8gdmFsdWUgbWlnaHQgbm90IGFjdHVhbGx5IGJlIGEgc3RyaW5nIGF0IHRoaXMgcG9pbnQgKHdlIGRvbid0IGdldCB0byBjaG9vc2UpXG4gIC8vIHNvIHBhcnQgb2YgcHJlcGFyaW5nIHRoZSB2YWx1ZSBmb3IgY29tcGFyaXNvbiBpcyBlbnN1cmUgdGhhdCBpdCBpcyBhIHN0cmluZ1xuICB2YWx1ZSA9IGAke3ZhbHVlfWA7IC8vIHRvU3RyaW5nXG4gIGlmICgha2VlcERpYWNyaXRpY3MpIHtcbiAgICB2YWx1ZSA9IHJlbW92ZUFjY2VudHModmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHZhbHVlIGZvciBrZXkgaW4gaXRlbSBhdCBhcmJpdHJhcmlseSBuZXN0ZWQga2V5cGF0aFxuICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gLSB0aGUgaXRlbVxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IGtleSAtIHRoZSBwb3RlbnRpYWxseSBuZXN0ZWQga2V5cGF0aCBvciBwcm9wZXJ0eSBjYWxsYmFja1xuICogQHJldHVybiB7QXJyYXl9IC0gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgdmFsdWUocykgYXQgdGhlIG5lc3RlZCBrZXlwYXRoXG4gKi9cbmZ1bmN0aW9uIGdldEl0ZW1WYWx1ZXMoaXRlbSwgYWNjZXNzb3IpIHtcbiAgbGV0IGFjY2Vzc29yRm4gPSBhY2Nlc3NvcjtcbiAgaWYgKHR5cGVvZiBhY2Nlc3NvciA9PT0gJ29iamVjdCcpIHtcbiAgICBhY2Nlc3NvckZuID0gYWNjZXNzb3IuYWNjZXNzb3I7XG4gIH1cbiAgY29uc3QgdmFsdWUgPSBhY2Nlc3NvckZuKGl0ZW0pO1xuXG4gIC8vIGJlY2F1c2UgYHZhbHVlYCBjYW4gYWxzbyBiZSB1bmRlZmluZWRcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBbU3RyaW5nKHZhbHVlKV07XG59XG5cbi8qKlxuICogR2V0cyBhbGwgdGhlIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGtleXMgaW4gdGhlIGdpdmVuIGl0ZW0gYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UgdmFsdWVzXG4gKiBAcGFyYW0gaXRlbSAtIHRoZSBpdGVtIGZyb20gd2hpY2ggdGhlIHZhbHVlcyB3aWxsIGJlIHJldHJpZXZlZFxuICogQHBhcmFtIGtleXMgLSB0aGUga2V5cyB0byB1c2UgdG8gcmV0cmlldmUgdGhlIHZhbHVlc1xuICogQHJldHVybiBvYmplY3RzIHdpdGgge2l0ZW1WYWx1ZSwgYXR0cmlidXRlc31cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsVmFsdWVzVG9SYW5rKGl0ZW0sIGFjY2Vzc29ycykge1xuICBjb25zdCBhbGxWYWx1ZXMgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDAsIEogPSBhY2Nlc3NvcnMubGVuZ3RoOyBqIDwgSjsgaisrKSB7XG4gICAgY29uc3QgYWNjZXNzb3IgPSBhY2Nlc3NvcnNbal07XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGdldEFjY2Vzc29yQXR0cmlidXRlcyhhY2Nlc3Nvcik7XG4gICAgY29uc3QgaXRlbVZhbHVlcyA9IGdldEl0ZW1WYWx1ZXMoaXRlbSwgYWNjZXNzb3IpO1xuICAgIGZvciAobGV0IGkgPSAwLCBJID0gaXRlbVZhbHVlcy5sZW5ndGg7IGkgPCBJOyBpKyspIHtcbiAgICAgIGFsbFZhbHVlcy5wdXNoKHtcbiAgICAgICAgaXRlbVZhbHVlOiBpdGVtVmFsdWVzW2ldLFxuICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbFZhbHVlcztcbn1cbmNvbnN0IGRlZmF1bHRLZXlBdHRyaWJ1dGVzID0ge1xuICBtYXhSYW5raW5nOiBJbmZpbml0eSxcbiAgbWluUmFua2luZzogLUluZmluaXR5XG59O1xuLyoqXG4gKiBHZXRzIGFsbCB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIGdpdmVuIGFjY2Vzc29yXG4gKiBAcGFyYW0gYWNjZXNzb3IgLSB0aGUgYWNjZXNzb3IgZnJvbSB3aGljaCB0aGUgYXR0cmlidXRlcyB3aWxsIGJlIHJldHJpZXZlZFxuICogQHJldHVybiBvYmplY3QgY29udGFpbmluZyB0aGUgYWNjZXNzb3IncyBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGdldEFjY2Vzc29yQXR0cmlidXRlcyhhY2Nlc3Nvcikge1xuICBpZiAodHlwZW9mIGFjY2Vzc29yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRLZXlBdHRyaWJ1dGVzO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGVmYXVsdEtleUF0dHJpYnV0ZXMsXG4gICAgLi4uYWNjZXNzb3JcbiAgfTtcbn1cblxuZXhwb3J0IHsgY29tcGFyZUl0ZW1zLCByYW5rSXRlbSwgcmFua2luZ3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJjaGFyYWN0ZXJNYXAiLCLDgCIsIsOBIiwiw4IiLCLDgyIsIsOEIiwiw4UiLCLhuqQiLCLhuq4iLCLhurIiLCLhurQiLCLhurYiLCLDhiIsIuG6piIsIuG6sCIsIsiCIiwiw4ciLCLhuIgiLCLDiCIsIsOJIiwiw4oiLCLDiyIsIuG6viIsIuG4liIsIuG7gCIsIuG4lCIsIuG4nCIsIsiGIiwiw4wiLCLDjSIsIsOOIiwiw48iLCLhuK4iLCLIiiIsIsOQIiwiw5EiLCLDkiIsIsOTIiwiw5QiLCLDlSIsIsOWIiwiw5giLCLhu5AiLCLhuYwiLCLhuZIiLCLIjiIsIsOZIiwiw5oiLCLDmyIsIsOcIiwiw50iLCLDoCIsIsOhIiwiw6IiLCLDoyIsIsOkIiwiw6UiLCLhuqUiLCLhuq8iLCLhurMiLCLhurUiLCLhurciLCLDpiIsIuG6pyIsIuG6sSIsIsiDIiwiw6ciLCLhuIkiLCLDqCIsIsOpIiwiw6oiLCLDqyIsIuG6vyIsIuG4lyIsIuG7gSIsIuG4lSIsIuG4nSIsIsiHIiwiw6wiLCLDrSIsIsOuIiwiw68iLCLhuK8iLCLIiyIsIsOwIiwiw7EiLCLDsiIsIsOzIiwiw7QiLCLDtSIsIsO2Iiwiw7giLCLhu5EiLCLhuY0iLCLhuZMiLCLIjyIsIsO5Iiwiw7oiLCLDuyIsIsO8Iiwiw70iLCLDvyIsIsSAIiwixIEiLCLEgiIsIsSDIiwixIQiLCLEhSIsIsSGIiwixIciLCLEiCIsIsSJIiwixIoiLCLEiyIsIsSMIiwixI0iLCJDzIYiLCJjzIYiLCLEjiIsIsSPIiwixJAiLCLEkSIsIsSSIiwixJMiLCLElCIsIsSVIiwixJYiLCLElyIsIsSYIiwixJkiLCLEmiIsIsSbIiwixJwiLCLHtCIsIsSdIiwix7UiLCLEniIsIsSfIiwixKAiLCLEoSIsIsSiIiwixKMiLCLEpCIsIsSlIiwixKYiLCLEpyIsIuG4qiIsIuG4qyIsIsSoIiwixKkiLCLEqiIsIsSrIiwixKwiLCLErSIsIsSuIiwixK8iLCLEsCIsIsSxIiwixLIiLCLEsyIsIsS0IiwixLUiLCLEtiIsIsS3Iiwi4biwIiwi4bixIiwiS8yGIiwia8yGIiwixLkiLCLEuiIsIsS7IiwixLwiLCLEvSIsIsS+IiwixL8iLCLFgCIsIsWBIiwixYIiLCLhuL4iLCLhuL8iLCJNzIYiLCJtzIYiLCLFgyIsIsWEIiwixYUiLCLFhiIsIsWHIiwixYgiLCLFiSIsIk7MhiIsIm7MhiIsIsWMIiwixY0iLCLFjiIsIsWPIiwixZAiLCLFkSIsIsWSIiwixZMiLCJQzIYiLCJwzIYiLCLFlCIsIsWVIiwixZYiLCLFlyIsIsWYIiwixZkiLCJSzIYiLCJyzIYiLCLIkiIsIsiTIiwixZoiLCLFmyIsIsWcIiwixZ0iLCLFniIsIsiYIiwiyJkiLCLFnyIsIsWgIiwixaEiLCLFoiIsIsWjIiwiyJsiLCLImiIsIsWkIiwixaUiLCLFpiIsIsWnIiwiVMyGIiwidMyGIiwixagiLCLFqSIsIsWqIiwixasiLCLFrCIsIsWtIiwixa4iLCLFryIsIsWwIiwixbEiLCLFsiIsIsWzIiwiyJYiLCLIlyIsIlbMhiIsInbMhiIsIsW0IiwixbUiLCLhuoIiLCLhuoMiLCJYzIYiLCJ4zIYiLCLFtiIsIsW3IiwixbgiLCJZzIYiLCJ5zIYiLCLFuSIsIsW6IiwixbsiLCLFvCIsIsW9Iiwixb4iLCLFvyIsIsaSIiwixqAiLCLGoSIsIsavIiwixrAiLCLHjSIsIseOIiwix48iLCLHkCIsIseRIiwix5IiLCLHkyIsIseUIiwix5UiLCLHliIsIseXIiwix5giLCLHmSIsIseaIiwix5siLCLHnCIsIuG7qCIsIuG7qSIsIuG5uCIsIuG5uSIsIse6Iiwix7siLCLHvCIsIse9Iiwix74iLCLHvyIsIsOeIiwiw74iLCLhuZQiLCLhuZUiLCLhuaQiLCLhuaUiLCJYzIEiLCJ4zIEiLCLQgyIsItGTIiwi0IwiLCLRnCIsIkHMiyIsImHMiyIsIkXMiyIsImXMiyIsIknMiyIsImnMiyIsIse4Iiwix7kiLCLhu5IiLCLhu5MiLCLhuZAiLCLhuZEiLCLhu6oiLCLhu6siLCLhuoAiLCLhuoEiLCLhu7IiLCLhu7MiLCLIgCIsIsiBIiwiyIQiLCLIhSIsIsiIIiwiyIkiLCLIjCIsIsiNIiwiyJAiLCLIkSIsIsiUIiwiyJUiLCJCzIwiLCJizIwiLCLEjMyjIiwixI3MoyIsIsOKzIwiLCLDqsyMIiwiRsyMIiwiZsyMIiwix6YiLCLHpyIsIsieIiwiyJ8iLCJKzIwiLCLHsCIsIseoIiwix6kiLCJNzIwiLCJtzIwiLCJQzIwiLCJwzIwiLCJRzIwiLCJxzIwiLCLFmMypIiwixZnMqSIsIuG5piIsIuG5pyIsIlbMjCIsInbMjCIsIlfMjCIsInfMjCIsIljMjCIsInjMjCIsIlnMjCIsInnMjCIsIkHMpyIsImHMpyIsIkLMpyIsImLMpyIsIuG4kCIsIuG4kSIsIsioIiwiyKkiLCLGkMynIiwiyZvMpyIsIuG4qCIsIuG4qSIsIknMpyIsImnMpyIsIsaXzKciLCLJqMynIiwiTcynIiwibcynIiwiT8ynIiwib8ynIiwiUcynIiwiccynIiwiVcynIiwidcynIiwiWMynIiwieMynIiwiWsynIiwiesynIiwiY2hhcnMiLCJPYmplY3QiLCJrZXlzIiwiam9pbiIsImFsbEFjY2VudHMiLCJSZWdFeHAiLCJyZW1vdmVBY2NlbnRzIiwic3RyIiwicmVwbGFjZSIsIm1hdGNoIiwicmFua2luZ3MiLCJDQVNFX1NFTlNJVElWRV9FUVVBTCIsIkVRVUFMIiwiU1RBUlRTX1dJVEgiLCJXT1JEX1NUQVJUU19XSVRIIiwiQ09OVEFJTlMiLCJBQ1JPTllNIiwiTUFUQ0hFUyIsIk5PX01BVENIIiwicmFua0l0ZW0iLCJpdGVtIiwidmFsdWUiLCJvcHRpb25zIiwiX29wdGlvbnMkdGhyZXNob2xkIiwidGhyZXNob2xkIiwiYWNjZXNzb3JzIiwicmFuayIsImdldE1hdGNoUmFua2luZyIsInJhbmtlZFZhbHVlIiwiYWNjZXNzb3JJbmRleCIsImFjY2Vzc29yVGhyZXNob2xkIiwicGFzc2VkIiwidmFsdWVzVG9SYW5rIiwiZ2V0QWxsVmFsdWVzVG9SYW5rIiwicmFua2luZ0luZm8iLCJpIiwibGVuZ3RoIiwicmFua1ZhbHVlIiwibmV3UmFuayIsIml0ZW1WYWx1ZSIsIm1pblJhbmtpbmciLCJtYXhSYW5raW5nIiwiYXR0cmlidXRlcyIsIk1hdGgiLCJtaW4iLCJ0ZXN0U3RyaW5nIiwic3RyaW5nVG9SYW5rIiwicHJlcGFyZVZhbHVlRm9yQ29tcGFyaXNvbiIsInRvTG93ZXJDYXNlIiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwiZ2V0QWNyb255bSIsImdldENsb3NlbmVzc1JhbmtpbmciLCJzdHJpbmciLCJhY3JvbnltIiwid29yZHNJblN0cmluZyIsInNwbGl0IiwiZm9yRWFjaCIsIndvcmRJblN0cmluZyIsInNwbGl0QnlIeXBoZW5Xb3JkcyIsInNwbGl0QnlIeXBoZW5Xb3JkIiwic3Vic3RyIiwibWF0Y2hpbmdJbk9yZGVyQ2hhckNvdW50IiwiY2hhck51bWJlciIsImZpbmRNYXRjaGluZ0NoYXJhY3RlciIsIm1hdGNoQ2hhciIsImluZGV4IiwiaiIsIkoiLCJzdHJpbmdDaGFyIiwiZ2V0UmFua2luZyIsInNwcmVhZCIsInNwcmVhZFBlcmNlbnRhZ2UiLCJpbk9yZGVyUGVyY2VudGFnZSIsInJhbmtpbmciLCJmaXJzdEluZGV4IiwiSSIsImZvdW5kIiwiY29tcGFyZUl0ZW1zIiwiYSIsImIiLCJfcmVmIiwia2VlcERpYWNyaXRpY3MiLCJnZXRJdGVtVmFsdWVzIiwiYWNjZXNzb3IiLCJhY2Nlc3NvckZuIiwiQXJyYXkiLCJpc0FycmF5IiwiU3RyaW5nIiwiYWxsVmFsdWVzIiwiZ2V0QWNjZXNzb3JBdHRyaWJ1dGVzIiwiaXRlbVZhbHVlcyIsInB1c2giLCJkZWZhdWx0S2V5QXR0cmlidXRlcyIsIkluZmluaXR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/match-sorter-utils/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.ColumnVisibility),\n/* harmony export */   GlobalFaceting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.GlobalFaceting),\n/* harmony export */   GlobalFiltering: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.GlobalFiltering),\n/* harmony export */   Headers: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.Headers),\n/* harmony export */   RowExpanding: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowExpanding),\n/* harmony export */   RowPagination: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowPagination),\n/* harmony export */   RowPinning: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowPinning),\n/* harmony export */   RowSelection: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSelection),\n/* harmony export */   RowSorting: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__._getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.buildHeaderGroups),\n/* harmony export */   createCell: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createCell),\n/* harmony export */   createColumn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumn),\n/* harmony export */   createColumnHelper: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createColumnHelper),\n/* harmony export */   createRow: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createRow),\n/* harmony export */   createTable: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable),\n/* harmony export */   defaultColumnSizing: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.expandRows),\n/* harmony export */   filterFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.filterFns),\n/* harmony export */   flattenBy: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.flattenBy),\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   functionalUpdate: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.getSortedRowModel),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isFunction),\n/* harmony export */   isNumberArray: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isNumberArray),\n/* harmony export */   isRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.makeStateUpdater),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.memo),\n/* harmony export */   noop: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.noop),\n/* harmony export */   orderColumns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* reexport safe */ _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.sortingFns),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/**\n   * react-table\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ \n\n\n//\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */ function flexRender(Comp, props) {\n    return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\n}\nfunction isReactComponent(component) {\n    return isClassComponent(component) || typeof component === \"function\" || isExoticComponent(component);\n}\nfunction isClassComponent(component) {\n    return typeof component === \"function\" && (()=>{\n        const proto = Object.getPrototypeOf(component);\n        return proto.prototype && proto.prototype.isReactComponent;\n    })();\n}\nfunction isExoticComponent(component) {\n    return typeof component === \"object\" && typeof component.$$typeof === \"symbol\" && [\n        \"react.memo\",\n        \"react.forward_ref\"\n    ].includes(component.$$typeof.description);\n}\nfunction useReactTable(options) {\n    // Compose in the generic options to the user options\n    const resolvedOptions = {\n        state: {},\n        // Dummy state\n        onStateChange: ()=>{},\n        // noop\n        renderFallbackValue: null,\n        ...options\n    };\n    // Create a new table and store it in state\n    const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>({\n            current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\n        }));\n    // By default, manage table state here using the table's initial state\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>tableRef.current.initialState);\n    // Compose the default state above with any user state. This will allow the user\n    // to only control a subset of the state if desired.\n    tableRef.current.setOptions((prev)=>({\n            ...prev,\n            ...options,\n            state: {\n                ...state,\n                ...options.state\n            },\n            // Similarly, we'll maintain both our internal state and any user-provided\n            // state.\n            onStateChange: (updater)=>{\n                setState(updater);\n                options.onStateChange == null || options.onStateChange(updater);\n            }\n        }));\n    return tableRef.current;\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7R0FTRyxHQUM0QjtBQUNvQjtBQUNkO0FBRXJDLEVBQUU7QUFFRjs7Q0FFQyxHQUNELFNBQVNFLFdBQVdDLElBQUksRUFBRUMsS0FBSztJQUM3QixPQUFPLENBQUNELE9BQU8sT0FBT0UsaUJBQWlCRixRQUFRLFdBQVcsR0FBRUgsZ0RBQW1CLENBQUNHLE1BQU1DLFNBQVNEO0FBQ2pHO0FBQ0EsU0FBU0UsaUJBQWlCRSxTQUFTO0lBQ2pDLE9BQU9DLGlCQUFpQkQsY0FBYyxPQUFPQSxjQUFjLGNBQWNFLGtCQUFrQkY7QUFDN0Y7QUFDQSxTQUFTQyxpQkFBaUJELFNBQVM7SUFDakMsT0FBTyxPQUFPQSxjQUFjLGNBQWMsQ0FBQztRQUN6QyxNQUFNRyxRQUFRQyxPQUFPQyxjQUFjLENBQUNMO1FBQ3BDLE9BQU9HLE1BQU1HLFNBQVMsSUFBSUgsTUFBTUcsU0FBUyxDQUFDUixnQkFBZ0I7SUFDNUQ7QUFDRjtBQUNBLFNBQVNJLGtCQUFrQkYsU0FBUztJQUNsQyxPQUFPLE9BQU9BLGNBQWMsWUFBWSxPQUFPQSxVQUFVTyxRQUFRLEtBQUssWUFBWTtRQUFDO1FBQWM7S0FBb0IsQ0FBQ0MsUUFBUSxDQUFDUixVQUFVTyxRQUFRLENBQUNFLFdBQVc7QUFDL0o7QUFDQSxTQUFTQyxjQUFjQyxPQUFPO0lBQzVCLHFEQUFxRDtJQUNyRCxNQUFNQyxrQkFBa0I7UUFDdEJDLE9BQU8sQ0FBQztRQUNSLGNBQWM7UUFDZEMsZUFBZSxLQUFPO1FBQ3RCLE9BQU87UUFDUEMscUJBQXFCO1FBQ3JCLEdBQUdKLE9BQU87SUFDWjtJQUVBLDJDQUEyQztJQUMzQyxNQUFNLENBQUNLLFNBQVMsR0FBR3ZCLDJDQUFjLENBQUMsSUFBTztZQUN2Q3lCLFNBQVN4QixpRUFBV0EsQ0FBQ2tCO1FBQ3ZCO0lBRUEsc0VBQXNFO0lBQ3RFLE1BQU0sQ0FBQ0MsT0FBT00sU0FBUyxHQUFHMUIsMkNBQWMsQ0FBQyxJQUFNdUIsU0FBU0UsT0FBTyxDQUFDRSxZQUFZO0lBRTVFLGdGQUFnRjtJQUNoRixvREFBb0Q7SUFDcERKLFNBQVNFLE9BQU8sQ0FBQ0csVUFBVSxDQUFDQyxDQUFBQSxPQUFTO1lBQ25DLEdBQUdBLElBQUk7WUFDUCxHQUFHWCxPQUFPO1lBQ1ZFLE9BQU87Z0JBQ0wsR0FBR0EsS0FBSztnQkFDUixHQUFHRixRQUFRRSxLQUFLO1lBQ2xCO1lBQ0EsMEVBQTBFO1lBQzFFLFNBQVM7WUFDVEMsZUFBZVMsQ0FBQUE7Z0JBQ2JKLFNBQVNJO2dCQUNUWixRQUFRRyxhQUFhLElBQUksUUFBUUgsUUFBUUcsYUFBYSxDQUFDUztZQUN6RDtRQUNGO0lBQ0EsT0FBT1AsU0FBU0UsT0FBTztBQUN6QjtBQUVxQyxDQUNyQyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRlcmlvLW11aS1yZWFjdC1uZXh0anMtYWRtaW4tdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanM/YTE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgICogcmVhY3QtdGFibGVcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKlxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVUYWJsZSB9IGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0YW5zdGFjay90YWJsZS1jb3JlJztcblxuLy9cblxuLyoqXG4gKiBJZiByZW5kZXJpbmcgaGVhZGVycywgY2VsbHMsIG9yIGZvb3RlcnMgd2l0aCBjdXN0b20gbWFya3VwLCB1c2UgZmxleFJlbmRlciBpbnN0ZWFkIG9mIGBjZWxsLmdldFZhbHVlKClgIG9yIGBjZWxsLnJlbmRlclZhbHVlKClgLlxuICovXG5mdW5jdGlvbiBmbGV4UmVuZGVyKENvbXAsIHByb3BzKSB7XG4gIHJldHVybiAhQ29tcCA/IG51bGwgOiBpc1JlYWN0Q29tcG9uZW50KENvbXApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcCwgcHJvcHMpIDogQ29tcDtcbn1cbmZ1bmN0aW9uIGlzUmVhY3RDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KGNvbXBvbmVudCkgfHwgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyB8fCBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpO1xufVxuZnVuY3Rpb24gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgKCgpID0+IHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjb21wb25lbnQpO1xuICAgIHJldHVybiBwcm90by5wcm90b3R5cGUgJiYgcHJvdG8ucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBpc0V4b3RpY0NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBjb21wb25lbnQuJCR0eXBlb2YgPT09ICdzeW1ib2wnICYmIFsncmVhY3QubWVtbycsICdyZWFjdC5mb3J3YXJkX3JlZiddLmluY2x1ZGVzKGNvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbik7XG59XG5mdW5jdGlvbiB1c2VSZWFjdFRhYmxlKG9wdGlvbnMpIHtcbiAgLy8gQ29tcG9zZSBpbiB0aGUgZ2VuZXJpYyBvcHRpb25zIHRvIHRoZSB1c2VyIG9wdGlvbnNcbiAgY29uc3QgcmVzb2x2ZWRPcHRpb25zID0ge1xuICAgIHN0YXRlOiB7fSxcbiAgICAvLyBEdW1teSBzdGF0ZVxuICAgIG9uU3RhdGVDaGFuZ2U6ICgpID0+IHt9LFxuICAgIC8vIG5vb3BcbiAgICByZW5kZXJGYWxsYmFja1ZhbHVlOiBudWxsLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBuZXcgdGFibGUgYW5kIHN0b3JlIGl0IGluIHN0YXRlXG4gIGNvbnN0IFt0YWJsZVJlZl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiAoe1xuICAgIGN1cnJlbnQ6IGNyZWF0ZVRhYmxlKHJlc29sdmVkT3B0aW9ucylcbiAgfSkpO1xuXG4gIC8vIEJ5IGRlZmF1bHQsIG1hbmFnZSB0YWJsZSBzdGF0ZSBoZXJlIHVzaW5nIHRoZSB0YWJsZSdzIGluaXRpYWwgc3RhdGVcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB0YWJsZVJlZi5jdXJyZW50LmluaXRpYWxTdGF0ZSk7XG5cbiAgLy8gQ29tcG9zZSB0aGUgZGVmYXVsdCBzdGF0ZSBhYm92ZSB3aXRoIGFueSB1c2VyIHN0YXRlLiBUaGlzIHdpbGwgYWxsb3cgdGhlIHVzZXJcbiAgLy8gdG8gb25seSBjb250cm9sIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZSBpZiBkZXNpcmVkLlxuICB0YWJsZVJlZi5jdXJyZW50LnNldE9wdGlvbnMocHJldiA9PiAoe1xuICAgIC4uLnByZXYsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBzdGF0ZToge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5vcHRpb25zLnN0YXRlXG4gICAgfSxcbiAgICAvLyBTaW1pbGFybHksIHdlJ2xsIG1haW50YWluIGJvdGggb3VyIGludGVybmFsIHN0YXRlIGFuZCBhbnkgdXNlci1wcm92aWRlZFxuICAgIC8vIHN0YXRlLlxuICAgIG9uU3RhdGVDaGFuZ2U6IHVwZGF0ZXIgPT4ge1xuICAgICAgc2V0U3RhdGUodXBkYXRlcik7XG4gICAgICBvcHRpb25zLm9uU3RhdGVDaGFuZ2UgPT0gbnVsbCB8fCBvcHRpb25zLm9uU3RhdGVDaGFuZ2UodXBkYXRlcik7XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiB0YWJsZVJlZi5jdXJyZW50O1xufVxuXG5leHBvcnQgeyBmbGV4UmVuZGVyLCB1c2VSZWFjdFRhYmxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVUYWJsZSIsImZsZXhSZW5kZXIiLCJDb21wIiwicHJvcHMiLCJpc1JlYWN0Q29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsImNvbXBvbmVudCIsImlzQ2xhc3NDb21wb25lbnQiLCJpc0V4b3RpY0NvbXBvbmVudCIsInByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCIkJHR5cGVvZiIsImluY2x1ZGVzIiwiZGVzY3JpcHRpb24iLCJ1c2VSZWFjdFRhYmxlIiwib3B0aW9ucyIsInJlc29sdmVkT3B0aW9ucyIsInN0YXRlIiwib25TdGF0ZUNoYW5nZSIsInJlbmRlckZhbGxiYWNrVmFsdWUiLCJ0YWJsZVJlZiIsInVzZVN0YXRlIiwiY3VycmVudCIsInNldFN0YXRlIiwiaW5pdGlhbFN0YXRlIiwic2V0T3B0aW9ucyIsInByZXYiLCJ1cGRhdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* binding */ ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* binding */ ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* binding */ ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* binding */ ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* binding */ ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* binding */ ColumnVisibility),\n/* harmony export */   GlobalFaceting: () => (/* binding */ GlobalFaceting),\n/* harmony export */   GlobalFiltering: () => (/* binding */ GlobalFiltering),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   RowExpanding: () => (/* binding */ RowExpanding),\n/* harmony export */   RowPagination: () => (/* binding */ RowPagination),\n/* harmony export */   RowPinning: () => (/* binding */ RowPinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   RowSorting: () => (/* binding */ RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* binding */ _getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* binding */ getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n   * table-core\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */ // type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n// const helper = createColumnHelper<Person>()\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\nfunction createColumnHelper() {\n    return {\n        accessor: (accessor, column)=>{\n            return typeof accessor === \"function\" ? {\n                ...column,\n                accessorFn: accessor\n            } : {\n                ...column,\n                accessorKey: accessor\n            };\n        },\n        display: (column)=>column,\n        group: (column)=>column\n    };\n}\n// Is this type a tuple?\n// If this type is a tuple, what indices are allowed?\n///\nfunction functionalUpdate(updater, input) {\n    return typeof updater === \"function\" ? updater(input) : updater;\n}\nfunction noop() {\n//\n}\nfunction makeStateUpdater(key, instance) {\n    return (updater)=>{\n        instance.setState((old)=>{\n            return {\n                ...old,\n                [key]: functionalUpdate(updater, old[key])\n            };\n        });\n    };\n}\nfunction isFunction(d) {\n    return d instanceof Function;\n}\nfunction isNumberArray(d) {\n    return Array.isArray(d) && d.every((val)=>typeof val === \"number\");\n}\nfunction flattenBy(arr, getChildren) {\n    const flat = [];\n    const recurse = (subArr)=>{\n        subArr.forEach((item)=>{\n            flat.push(item);\n            const children = getChildren(item);\n            if (children != null && children.length) {\n                recurse(children);\n            }\n        });\n    };\n    recurse(arr);\n    return flat;\n}\nfunction memo(getDeps, fn, opts) {\n    let deps = [];\n    let result;\n    return (depArgs)=>{\n        let depTime;\n        if (opts.key && opts.debug) depTime = Date.now();\n        const newDeps = getDeps(depArgs);\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && opts.debug) resultTime = Date.now();\n        result = fn(...newDeps);\n        opts == null || opts.onChange == null || opts.onChange(result);\n        if (opts.key && opts.debug) {\n            if (opts != null && opts.debug()) {\n                const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n                const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n                const resultFpsPercentage = resultEndTime / 16;\n                const pad = (str, num)=>{\n                    str = String(str);\n                    while(str.length < num){\n                        str = \" \" + str;\n                    }\n                    return str;\n                };\n                console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n            }\n        }\n        return result;\n    };\n}\nfunction getMemoOptions(tableOptions, debugLevel, key, onChange) {\n    return {\n        debug: ()=>{\n            var _tableOptions$debugAl;\n            return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];\n        },\n        key:  true && key,\n        onChange\n    };\n}\nfunction createCell(table, row, column, columnId) {\n    const getRenderValue = ()=>{\n        var _cell$getValue;\n        return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n    };\n    const cell = {\n        id: `${row.id}_${column.id}`,\n        row,\n        column,\n        getValue: ()=>row.getValue(columnId),\n        renderValue: getRenderValue,\n        getContext: memo(()=>[\n                table,\n                column,\n                row,\n                cell\n            ], (table, column, row, cell)=>({\n                table,\n                column,\n                row,\n                cell: cell,\n                getValue: cell.getValue,\n                renderValue: cell.renderValue\n            }), getMemoOptions(table.options, \"debugCells\", \"cell.getContext\"))\n    };\n    table._features.forEach((feature)=>{\n        feature.createCell == null || feature.createCell(cell, column, row, table);\n    }, {});\n    return cell;\n}\nfunction createColumn(table, columnDef, depth, parent) {\n    var _ref, _resolvedColumnDef$id;\n    const defaultColumn = table._getDefaultColumnDef();\n    const resolvedColumnDef = {\n        ...defaultColumn,\n        ...columnDef\n    };\n    const accessorKey = resolvedColumnDef.accessorKey;\n    let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? accessorKey.replace(\".\", \"_\") : undefined) != null ? _ref : typeof resolvedColumnDef.header === \"string\" ? resolvedColumnDef.header : undefined;\n    let accessorFn;\n    if (resolvedColumnDef.accessorFn) {\n        accessorFn = resolvedColumnDef.accessorFn;\n    } else if (accessorKey) {\n        // Support deep accessor keys\n        if (accessorKey.includes(\".\")) {\n            accessorFn = (originalRow)=>{\n                let result = originalRow;\n                for (const key of accessorKey.split(\".\")){\n                    var _result;\n                    result = (_result = result) == null ? void 0 : _result[key];\n                    if ( true && result === undefined) {\n                        console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n                    }\n                }\n                return result;\n            };\n        } else {\n            accessorFn = (originalRow)=>originalRow[resolvedColumnDef.accessorKey];\n        }\n    }\n    if (!id) {\n        if (true) {\n            throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n        }\n        throw new Error();\n    }\n    let column = {\n        id: `${String(id)}`,\n        accessorFn,\n        parent: parent,\n        depth,\n        columnDef: resolvedColumnDef,\n        columns: [],\n        getFlatColumns: memo(()=>[\n                true\n            ], ()=>{\n            var _column$columns;\n            return [\n                column,\n                ...(_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap((d)=>d.getFlatColumns())\n            ];\n        }, getMemoOptions(table.options, \"debugColumns\", \"column.getFlatColumns\")),\n        getLeafColumns: memo(()=>[\n                table._getOrderColumnsFn()\n            ], (orderColumns)=>{\n            var _column$columns2;\n            if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n                let leafColumns = column.columns.flatMap((column)=>column.getLeafColumns());\n                return orderColumns(leafColumns);\n            }\n            return [\n                column\n            ];\n        }, getMemoOptions(table.options, \"debugColumns\", \"column.getLeafColumns\"))\n    };\n    for (const feature of table._features){\n        feature.createColumn == null || feature.createColumn(column, table);\n    }\n    // Yes, we have to convert table to unknown, because we know more than the compiler here.\n    return column;\n}\nconst debug = \"debugHeaders\";\n//\nfunction createHeader(table, column, options) {\n    var _options$id;\n    const id = (_options$id = options.id) != null ? _options$id : column.id;\n    let header = {\n        id,\n        column,\n        index: options.index,\n        isPlaceholder: !!options.isPlaceholder,\n        placeholderId: options.placeholderId,\n        depth: options.depth,\n        subHeaders: [],\n        colSpan: 0,\n        rowSpan: 0,\n        headerGroup: null,\n        getLeafHeaders: ()=>{\n            const leafHeaders = [];\n            const recurseHeader = (h)=>{\n                if (h.subHeaders && h.subHeaders.length) {\n                    h.subHeaders.map(recurseHeader);\n                }\n                leafHeaders.push(h);\n            };\n            recurseHeader(header);\n            return leafHeaders;\n        },\n        getContext: ()=>({\n                table,\n                header: header,\n                column\n            })\n    };\n    table._features.forEach((feature)=>{\n        feature.createHeader == null || feature.createHeader(header, table);\n    });\n    return header;\n}\nconst Headers = {\n    createTable: (table)=>{\n        // Header Groups\n        table.getHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            var _left$map$filter, _right$map$filter;\n            const leftColumns = (_left$map$filter = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n            const rightColumns = (_right$map$filter = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n            const centerColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            const headerGroups = buildHeaderGroups(allColumns, [\n                ...leftColumns,\n                ...centerColumns,\n                ...rightColumns\n            ], table);\n            return headerGroups;\n        }, getMemoOptions(table.options, debug, \"getHeaderGroups\"));\n        table.getCenterHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, left, right)=>{\n            leafColumns = leafColumns.filter((column)=>!(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n            return buildHeaderGroups(allColumns, leafColumns, table, \"center\");\n        }, getMemoOptions(table.options, debug, \"getCenterHeaderGroups\"));\n        table.getLeftHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, leafColumns, left)=>{\n            var _left$map$filter2;\n            const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"left\");\n        }, getMemoOptions(table.options, debug, \"getLeftHeaderGroups\"));\n        table.getRightHeaderGroups = memo(()=>[\n                table.getAllColumns(),\n                table.getVisibleLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, leafColumns, right)=>{\n            var _right$map$filter2;\n            const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map((columnId)=>leafColumns.find((d)=>d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n            return buildHeaderGroups(allColumns, orderedLeafColumns, table, \"right\");\n        }, getMemoOptions(table.options, debug, \"getRightHeaderGroups\"));\n        // Footer Groups\n        table.getFooterGroups = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getFooterGroups\"));\n        table.getLeftFooterGroups = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getLeftFooterGroups\"));\n        table.getCenterFooterGroups = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getCenterFooterGroups\"));\n        table.getRightFooterGroups = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (headerGroups)=>{\n            return [\n                ...headerGroups\n            ].reverse();\n        }, getMemoOptions(table.options, debug, \"getRightFooterGroups\"));\n        // Flat Headers\n        table.getFlatHeaders = memo(()=>[\n                table.getHeaderGroups()\n            ], (headerGroups)=>{\n            return headerGroups.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getFlatHeaders\"));\n        table.getLeftFlatHeaders = memo(()=>[\n                table.getLeftHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getLeftFlatHeaders\"));\n        table.getCenterFlatHeaders = memo(()=>[\n                table.getCenterHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getCenterFlatHeaders\"));\n        table.getRightFlatHeaders = memo(()=>[\n                table.getRightHeaderGroups()\n            ], (left)=>{\n            return left.map((headerGroup)=>{\n                return headerGroup.headers;\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getRightFlatHeaders\"));\n        // Leaf Headers\n        table.getCenterLeafHeaders = memo(()=>[\n                table.getCenterFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders;\n                return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getCenterLeafHeaders\"));\n        table.getLeftLeafHeaders = memo(()=>[\n                table.getLeftFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders2;\n                return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getLeftLeafHeaders\"));\n        table.getRightLeafHeaders = memo(()=>[\n                table.getRightFlatHeaders()\n            ], (flatHeaders)=>{\n            return flatHeaders.filter((header)=>{\n                var _header$subHeaders3;\n                return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n            });\n        }, getMemoOptions(table.options, debug, \"getRightLeafHeaders\"));\n        table.getLeafHeaders = memo(()=>[\n                table.getLeftHeaderGroups(),\n                table.getCenterHeaderGroups(),\n                table.getRightHeaderGroups()\n            ], (left, center, right)=>{\n            var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n            return [\n                ...(_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : [],\n                ...(_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : [],\n                ...(_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : []\n            ].map((header)=>{\n                return header.getLeafHeaders();\n            }).flat();\n        }, getMemoOptions(table.options, debug, \"getLeafHeaders\"));\n    }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n    var _headerGroups$0$heade, _headerGroups$;\n    // Find the max depth of the columns:\n    // build the leaf column row\n    // build each buffer row going up\n    //    placeholder for non-existent level\n    //    real column for existing level\n    let maxDepth = 0;\n    const findMaxDepth = function(columns, depth) {\n        if (depth === void 0) {\n            depth = 1;\n        }\n        maxDepth = Math.max(maxDepth, depth);\n        columns.filter((column)=>column.getIsVisible()).forEach((column)=>{\n            var _column$columns;\n            if ((_column$columns = column.columns) != null && _column$columns.length) {\n                findMaxDepth(column.columns, depth + 1);\n            }\n        }, 0);\n    };\n    findMaxDepth(allColumns);\n    let headerGroups = [];\n    const createHeaderGroup = (headersToGroup, depth)=>{\n        // The header group we are creating\n        const headerGroup = {\n            depth,\n            id: [\n                headerFamily,\n                `${depth}`\n            ].filter(Boolean).join(\"_\"),\n            headers: []\n        };\n        // The parent columns we're going to scan next\n        const pendingParentHeaders = [];\n        // Scan each column for parents\n        headersToGroup.forEach((headerToGroup)=>{\n            // What is the latest (last) parent column?\n            const latestPendingParentHeader = [\n                ...pendingParentHeaders\n            ].reverse()[0];\n            const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n            let column;\n            let isPlaceholder = false;\n            if (isLeafHeader && headerToGroup.column.parent) {\n                // The parent header is new\n                column = headerToGroup.column.parent;\n            } else {\n                // The parent header is repeated\n                column = headerToGroup.column;\n                isPlaceholder = true;\n            }\n            if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n                // This column is repeated. Add it as a sub header to the next batch\n                latestPendingParentHeader.subHeaders.push(headerToGroup);\n            } else {\n                // This is a new header. Let's create it\n                const header = createHeader(table, column, {\n                    id: [\n                        headerFamily,\n                        depth,\n                        column.id,\n                        headerToGroup == null ? void 0 : headerToGroup.id\n                    ].filter(Boolean).join(\"_\"),\n                    isPlaceholder,\n                    placeholderId: isPlaceholder ? `${pendingParentHeaders.filter((d)=>d.column === column).length}` : undefined,\n                    depth,\n                    index: pendingParentHeaders.length\n                });\n                // Add the headerToGroup as a subHeader of the new header\n                header.subHeaders.push(headerToGroup);\n                // Add the new header to the pendingParentHeaders to get grouped\n                // in the next batch\n                pendingParentHeaders.push(header);\n            }\n            headerGroup.headers.push(headerToGroup);\n            headerToGroup.headerGroup = headerGroup;\n        });\n        headerGroups.push(headerGroup);\n        if (depth > 0) {\n            createHeaderGroup(pendingParentHeaders, depth - 1);\n        }\n    };\n    const bottomHeaders = columnsToGroup.map((column, index)=>createHeader(table, column, {\n            depth: maxDepth,\n            index\n        }));\n    createHeaderGroup(bottomHeaders, maxDepth - 1);\n    headerGroups.reverse();\n    // headerGroups = headerGroups.filter(headerGroup => {\n    //   return !headerGroup.headers.every(header => header.isPlaceholder)\n    // })\n    const recurseHeadersForSpans = (headers)=>{\n        const filteredHeaders = headers.filter((header)=>header.column.getIsVisible());\n        return filteredHeaders.map((header)=>{\n            let colSpan = 0;\n            let rowSpan = 0;\n            let childRowSpans = [\n                0\n            ];\n            if (header.subHeaders && header.subHeaders.length) {\n                childRowSpans = [];\n                recurseHeadersForSpans(header.subHeaders).forEach((_ref)=>{\n                    let { colSpan: childColSpan, rowSpan: childRowSpan } = _ref;\n                    colSpan += childColSpan;\n                    childRowSpans.push(childRowSpan);\n                });\n            } else {\n                colSpan = 1;\n            }\n            const minChildRowSpan = Math.min(...childRowSpans);\n            rowSpan = rowSpan + minChildRowSpan;\n            header.colSpan = colSpan;\n            header.rowSpan = rowSpan;\n            return {\n                colSpan,\n                rowSpan\n            };\n        });\n    };\n    recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n    return headerGroups;\n}\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId)=>{\n    let row = {\n        id,\n        index: rowIndex,\n        original,\n        depth,\n        parentId,\n        _valuesCache: {},\n        _uniqueValuesCache: {},\n        getValue: (columnId)=>{\n            if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n            return row._valuesCache[columnId];\n        },\n        getUniqueValues: (columnId)=>{\n            if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n                return row._uniqueValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.accessorFn)) {\n                return undefined;\n            }\n            if (!column.columnDef.getUniqueValues) {\n                row._uniqueValuesCache[columnId] = [\n                    row.getValue(columnId)\n                ];\n                return row._uniqueValuesCache[columnId];\n            }\n            row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n            return row._uniqueValuesCache[columnId];\n        },\n        renderValue: (columnId)=>{\n            var _row$getValue;\n            return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n        },\n        subRows: subRows != null ? subRows : [],\n        getLeafRows: ()=>flattenBy(row.subRows, (d)=>d.subRows),\n        getParentRow: ()=>row.parentId ? table.getRow(row.parentId, true) : undefined,\n        getParentRows: ()=>{\n            let parentRows = [];\n            let currentRow = row;\n            while(true){\n                const parentRow = currentRow.getParentRow();\n                if (!parentRow) break;\n                parentRows.push(parentRow);\n                currentRow = parentRow;\n            }\n            return parentRows.reverse();\n        },\n        getAllCells: memo(()=>[\n                table.getAllLeafColumns()\n            ], (leafColumns)=>{\n            return leafColumns.map((column)=>{\n                return createCell(table, row, column, column.id);\n            });\n        }, getMemoOptions(table.options, \"debugRows\", \"getAllCells\")),\n        _getAllCellsByColumnId: memo(()=>[\n                row.getAllCells()\n            ], (allCells)=>{\n            return allCells.reduce((acc, cell)=>{\n                acc[cell.column.id] = cell;\n                return acc;\n            }, {});\n        }, getMemoOptions(table.options, \"debugRows\", \"getAllCellsByColumnId\"))\n    };\n    for(let i = 0; i < table._features.length; i++){\n        const feature = table._features[i];\n        feature == null || feature.createRow == null || feature.createRow(row, table);\n    }\n    return row;\n};\n//\nconst ColumnFaceting = {\n    createColumn: (column, table)=>{\n        column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n        column.getFacetedRowModel = ()=>{\n            if (!column._getFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return column._getFacetedRowModel();\n        };\n        column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n        column.getFacetedUniqueValues = ()=>{\n            if (!column._getFacetedUniqueValues) {\n                return new Map();\n            }\n            return column._getFacetedUniqueValues();\n        };\n        column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n        column.getFacetedMinMaxValues = ()=>{\n            if (!column._getFacetedMinMaxValues) {\n                return undefined;\n            }\n            return column._getFacetedMinMaxValues();\n        };\n    }\n};\nconst includesString = (row, columnId, filterValue)=>{\n    var _row$getValue;\n    const search = filterValue.toLowerCase();\n    return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = (val)=>testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue)=>{\n    var _row$getValue2;\n    return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = (val)=>testFalsey(val);\nconst equalsString = (row, columnId, filterValue)=>{\n    var _row$getValue3;\n    return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = (val)=>testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue)=>{\n    var _row$getValue4;\n    return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesAll = (row, columnId, filterValue)=>{\n    return !filterValue.some((val)=>{\n        var _row$getValue5;\n        return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n    });\n};\narrIncludesAll.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue)=>{\n    return filterValue.some((val)=>{\n        var _row$getValue6;\n        return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n    });\n};\narrIncludesSome.autoRemove = (val)=>testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = (val)=>testFalsey(val);\nconst weakEquals = (row, columnId, filterValue)=>{\n    return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = (val)=>testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue)=>{\n    let [min, max] = filterValue;\n    const rowValue = row.getValue(columnId);\n    return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = (val)=>{\n    let [unsafeMin, unsafeMax] = val;\n    let parsedMin = typeof unsafeMin !== \"number\" ? parseFloat(unsafeMin) : unsafeMin;\n    let parsedMax = typeof unsafeMax !== \"number\" ? parseFloat(unsafeMax) : unsafeMax;\n    let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n    let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n    if (min > max) {\n        const temp = min;\n        min = max;\n        max = temp;\n    }\n    return [\n        min,\n        max\n    ];\n};\ninNumberRange.autoRemove = (val)=>testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n// Export\nconst filterFns = {\n    includesString,\n    includesStringSensitive,\n    equalsString,\n    arrIncludes,\n    arrIncludesAll,\n    arrIncludesSome,\n    equals,\n    weakEquals,\n    inNumberRange\n};\n// Utils\nfunction testFalsey(val) {\n    return val === undefined || val === null || val === \"\";\n}\n//\nconst ColumnFiltering = {\n    getDefaultColumnDef: ()=>{\n        return {\n            filterFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            columnFilters: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnFiltersChange: makeStateUpdater(\"columnFilters\", table),\n            filterFromLeafRows: false,\n            maxLeafRowFilterDepth: 100\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoFilterFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return filterFns.includesString;\n            }\n            if (typeof value === \"number\") {\n                return filterFns.inNumberRange;\n            }\n            if (typeof value === \"boolean\") {\n                return filterFns.equals;\n            }\n            if (value !== null && typeof value === \"object\") {\n                return filterFns.equals;\n            }\n            if (Array.isArray(value)) {\n                return filterFns.arrIncludes;\n            }\n            return filterFns.weakEquals;\n        };\n        column.getFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === \"auto\" ? column.getAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n        };\n        column.getCanFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n            return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n        };\n        column.getIsFiltered = ()=>column.getFilterIndex() > -1;\n        column.getFilterValue = ()=>{\n            var _table$getState$colum;\n            return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find((d)=>d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n        };\n        column.getFilterIndex = ()=>{\n            var _table$getState$colum2, _table$getState$colum3;\n            return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$colum2 : -1;\n        };\n        column.setFilterValue = (value)=>{\n            table.setColumnFilters((old)=>{\n                const filterFn = column.getFilterFn();\n                const previousFilter = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : undefined);\n                //\n                if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n                    var _old$filter;\n                    return (_old$filter = old == null ? void 0 : old.filter((d)=>d.id !== column.id)) != null ? _old$filter : [];\n                }\n                const newFilterObj = {\n                    id: column.id,\n                    value: newFilter\n                };\n                if (previousFilter) {\n                    var _old$map;\n                    return (_old$map = old == null ? void 0 : old.map((d)=>{\n                        if (d.id === column.id) {\n                            return newFilterObj;\n                        }\n                        return d;\n                    })) != null ? _old$map : [];\n                }\n                if (old != null && old.length) {\n                    return [\n                        ...old,\n                        newFilterObj\n                    ];\n                }\n                return [\n                    newFilterObj\n                ];\n            });\n        };\n    },\n    createRow: (row, _table)=>{\n        row.columnFilters = {};\n        row.columnFiltersMeta = {};\n    },\n    createTable: (table)=>{\n        table.setColumnFilters = (updater)=>{\n            const leafColumns = table.getAllLeafColumns();\n            const updateFn = (old)=>{\n                var _functionalUpdate;\n                return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter((filter)=>{\n                    const column = leafColumns.find((d)=>d.id === filter.id);\n                    if (column) {\n                        const filterFn = column.getFilterFn();\n                        if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            };\n            table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n        };\n        table.resetColumnFilters = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n        };\n        table.getPreFilteredRowModel = ()=>table.getCoreRowModel();\n        table.getFilteredRowModel = ()=>{\n            if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n                table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n            }\n            if (table.options.manualFiltering || !table._getFilteredRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getFilteredRowModel();\n        };\n    }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n    return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === \"undefined\" || typeof value === \"string\" && !value;\n}\nconst sum = (columnId, _leafRows, childRows)=>{\n    // It's faster to just add the aggregations together instead of\n    // process leaf nodes individually\n    return childRows.reduce((sum, next)=>{\n        const nextValue = next.getValue(columnId);\n        return sum + (typeof nextValue === \"number\" ? nextValue : 0);\n    }, 0);\n};\nconst min = (columnId, _leafRows, childRows)=>{\n    let min;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (min > value || min === undefined && value >= value)) {\n            min = value;\n        }\n    });\n    return min;\n};\nconst max = (columnId, _leafRows, childRows)=>{\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null && (max < value || max === undefined && value >= value)) {\n            max = value;\n        }\n    });\n    return max;\n};\nconst extent = (columnId, _leafRows, childRows)=>{\n    let min;\n    let max;\n    childRows.forEach((row)=>{\n        const value = row.getValue(columnId);\n        if (value != null) {\n            if (min === undefined) {\n                if (value >= value) min = max = value;\n            } else {\n                if (min > value) min = value;\n                if (max < value) max = value;\n            }\n        }\n    });\n    return [\n        min,\n        max\n    ];\n};\nconst mean = (columnId, leafRows)=>{\n    let count = 0;\n    let sum = 0;\n    leafRows.forEach((row)=>{\n        let value = row.getValue(columnId);\n        if (value != null && (value = +value) >= value) {\n            ++count, sum += value;\n        }\n    });\n    if (count) return sum / count;\n    return;\n};\nconst median = (columnId, leafRows)=>{\n    if (!leafRows.length) {\n        return;\n    }\n    const values = leafRows.map((row)=>row.getValue(columnId));\n    if (!isNumberArray(values)) {\n        return;\n    }\n    if (values.length === 1) {\n        return values[0];\n    }\n    const mid = Math.floor(values.length / 2);\n    const nums = values.sort((a, b)=>a - b);\n    return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows)=>{\n    return Array.from(new Set(leafRows.map((d)=>d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows)=>{\n    return new Set(leafRows.map((d)=>d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows)=>{\n    return leafRows.length;\n};\nconst aggregationFns = {\n    sum,\n    min,\n    max,\n    extent,\n    mean,\n    median,\n    unique,\n    uniqueCount,\n    count\n};\n//\nconst ColumnGrouping = {\n    getDefaultColumnDef: ()=>{\n        return {\n            aggregatedCell: (props)=>{\n                var _toString, _props$getValue;\n                return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n            },\n            aggregationFn: \"auto\"\n        };\n    },\n    getInitialState: (state)=>{\n        return {\n            grouping: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGroupingChange: makeStateUpdater(\"grouping\", table),\n            groupedColumnMode: \"reorder\"\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleGrouping = ()=>{\n            table.setGrouping((old)=>{\n                // Find any existing grouping for this column\n                if (old != null && old.includes(column.id)) {\n                    return old.filter((d)=>d !== column.id);\n                }\n                return [\n                    ...old != null ? old : [],\n                    column.id\n                ];\n            });\n        };\n        column.getCanGroup = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);\n        };\n        column.getIsGrouped = ()=>{\n            var _table$getState$group;\n            return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n        };\n        column.getGroupedIndex = ()=>{\n            var _table$getState$group2;\n            return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n        };\n        column.getToggleGroupingHandler = ()=>{\n            const canGroup = column.getCanGroup();\n            return ()=>{\n                if (!canGroup) return;\n                column.toggleGrouping();\n            };\n        };\n        column.getAutoAggregationFn = ()=>{\n            const firstRow = table.getCoreRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"number\") {\n                return aggregationFns.sum;\n            }\n            if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                return aggregationFns.extent;\n            }\n        };\n        column.getAggregationFn = ()=>{\n            var _table$options$aggreg, _table$options$aggreg2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === \"auto\" ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n        };\n    },\n    createTable: (table)=>{\n        table.setGrouping = (updater)=>table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n        table.resetGrouping = (defaultState)=>{\n            var _table$initialState$g, _table$initialState;\n            table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n        };\n        table.getPreGroupedRowModel = ()=>table.getFilteredRowModel();\n        table.getGroupedRowModel = ()=>{\n            if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n                table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n            }\n            if (table.options.manualGrouping || !table._getGroupedRowModel) {\n                return table.getPreGroupedRowModel();\n            }\n            return table._getGroupedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.getIsGrouped = ()=>!!row.groupingColumnId;\n        row.getGroupingValue = (columnId)=>{\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                return row._groupingValuesCache[columnId];\n            }\n            const column = table.getColumn(columnId);\n            if (!(column != null && column.columnDef.getGroupingValue)) {\n                return row.getValue(columnId);\n            }\n            row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n            return row._groupingValuesCache[columnId];\n        };\n        row._groupingValuesCache = {};\n    },\n    createCell: (cell, column, row, table)=>{\n        cell.getIsGrouped = ()=>column.getIsGrouped() && column.id === row.groupingColumnId;\n        cell.getIsPlaceholder = ()=>!cell.getIsGrouped() && column.getIsGrouped();\n        cell.getIsAggregated = ()=>{\n            var _row$subRows;\n            return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n    }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n    if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n        return leafColumns;\n    }\n    const nonGroupingColumns = leafColumns.filter((col)=>!grouping.includes(col.id));\n    if (groupedColumnMode === \"remove\") {\n        return nonGroupingColumns;\n    }\n    const groupingColumns = grouping.map((g)=>leafColumns.find((col)=>col.id === g)).filter(Boolean);\n    return [\n        ...groupingColumns,\n        ...nonGroupingColumns\n    ];\n}\n//\nconst ColumnOrdering = {\n    getInitialState: (state)=>{\n        return {\n            columnOrder: [],\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnOrderChange: makeStateUpdater(\"columnOrder\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getIndex = memo((position)=>[\n                _getVisibleLeafColumns(table, position)\n            ], (columns)=>columns.findIndex((d)=>d.id === column.id), getMemoOptions(table.options, \"debugColumns\", \"getIndex\"));\n        column.getIsFirstColumn = (position)=>{\n            var _columns$;\n            const columns = _getVisibleLeafColumns(table, position);\n            return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;\n        };\n        column.getIsLastColumn = (position)=>{\n            var _columns;\n            const columns = _getVisibleLeafColumns(table, position);\n            return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnOrder = (updater)=>table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n        table.resetColumnOrder = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n        };\n        table._getOrderColumnsFn = memo(()=>[\n                table.getState().columnOrder,\n                table.getState().grouping,\n                table.options.groupedColumnMode\n            ], (columnOrder, grouping, groupedColumnMode)=>(columns)=>{\n                // Sort grouped columns to the start of the column list\n                // before the headers are built\n                let orderedColumns = [];\n                // If there is no order, return the normal columns\n                if (!(columnOrder != null && columnOrder.length)) {\n                    orderedColumns = columns;\n                } else {\n                    const columnOrderCopy = [\n                        ...columnOrder\n                    ];\n                    // If there is an order, make a copy of the columns\n                    const columnsCopy = [\n                        ...columns\n                    ];\n                    // And make a new ordered array of the columns\n                    // Loop over the columns and place them in order into the new array\n                    while(columnsCopy.length && columnOrderCopy.length){\n                        const targetColumnId = columnOrderCopy.shift();\n                        const foundIndex = columnsCopy.findIndex((d)=>d.id === targetColumnId);\n                        if (foundIndex > -1) {\n                            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n                        }\n                    }\n                    // If there are any columns left, add them to the end\n                    orderedColumns = [\n                        ...orderedColumns,\n                        ...columnsCopy\n                    ];\n                }\n                return orderColumns(orderedColumns, grouping, groupedColumnMode);\n            }, getMemoOptions(table.options, \"debugTable\", \"_getOrderColumnsFn\"));\n    }\n};\n//\nconst getDefaultColumnPinningState = ()=>({\n        left: [],\n        right: []\n    });\nconst ColumnPinning = {\n    getInitialState: (state)=>{\n        return {\n            columnPinning: getDefaultColumnPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnPinningChange: makeStateUpdater(\"columnPinning\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.pin = (position)=>{\n            const columnIds = column.getLeafColumns().map((d)=>d.id).filter(Boolean);\n            table.setColumnPinning((old)=>{\n                var _old$left3, _old$right3;\n                if (position === \"right\") {\n                    var _old$left, _old$right;\n                    return {\n                        left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                        right: [\n                            ...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ]\n                    };\n                }\n                if (position === \"left\") {\n                    var _old$left2, _old$right2;\n                    return {\n                        left: [\n                            ...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                            ...columnIds\n                        ],\n                        right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                    };\n                }\n                return {\n                    left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d))),\n                    right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter((d)=>!(columnIds != null && columnIds.includes(d)))\n                };\n            });\n        };\n        column.getCanPin = ()=>{\n            const leafColumns = column.getLeafColumns();\n            return leafColumns.some((d)=>{\n                var _d$columnDef$enablePi, _ref, _table$options$enable;\n                return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n            });\n        };\n        column.getIsPinned = ()=>{\n            const leafColumnIds = column.getLeafColumns().map((d)=>d.id);\n            const { left, right } = table.getState().columnPinning;\n            const isLeft = leafColumnIds.some((d)=>left == null ? void 0 : left.includes(d));\n            const isRight = leafColumnIds.some((d)=>right == null ? void 0 : right.includes(d));\n            return isLeft ? \"left\" : isRight ? \"right\" : false;\n        };\n        column.getPinnedIndex = ()=>{\n            var _table$getState$colum, _table$getState$colum2;\n            const position = column.getIsPinned();\n            return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n        };\n    },\n    createRow: (row, table)=>{\n        row.getCenterVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allCells, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allCells.filter((d)=>!leftAndRight.includes(d.column.id));\n        }, getMemoOptions(table.options, \"debugRows\", \"getCenterVisibleCells\"));\n        row.getLeftVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.left\n            ], (allCells, left)=>{\n            const cells = (left != null ? left : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"left\"\n                }));\n            return cells;\n        }, getMemoOptions(table.options, \"debugRows\", \"getLeftVisibleCells\"));\n        row.getRightVisibleCells = memo(()=>[\n                row._getAllVisibleCells(),\n                table.getState().columnPinning.right\n            ], (allCells, right)=>{\n            const cells = (right != null ? right : []).map((columnId)=>allCells.find((cell)=>cell.column.id === columnId)).filter(Boolean).map((d)=>({\n                    ...d,\n                    position: \"right\"\n                }));\n            return cells;\n        }, getMemoOptions(table.options, \"debugRows\", \"getRightVisibleCells\"));\n    },\n    createTable: (table)=>{\n        table.setColumnPinning = (updater)=>table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n        table.resetColumnPinning = (defaultState)=>{\n            var _table$initialState$c, _table$initialState;\n            return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n        };\n        table.getIsSomeColumnsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().columnPinning;\n            if (!position) {\n                var _pinningState$left, _pinningState$right;\n                return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table.getLeftLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left\n            ], (allColumns, left)=>{\n            return (left != null ? left : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, getMemoOptions(table.options, \"debugColumns\", \"getLeftLeafColumns\"));\n        table.getRightLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.right\n            ], (allColumns, right)=>{\n            return (right != null ? right : []).map((columnId)=>allColumns.find((column)=>column.id === columnId)).filter(Boolean);\n        }, getMemoOptions(table.options, \"debugColumns\", \"getRightLeafColumns\"));\n        table.getCenterLeafColumns = memo(()=>[\n                table.getAllLeafColumns(),\n                table.getState().columnPinning.left,\n                table.getState().columnPinning.right\n            ], (allColumns, left, right)=>{\n            const leftAndRight = [\n                ...left != null ? left : [],\n                ...right != null ? right : []\n            ];\n            return allColumns.filter((d)=>!leftAndRight.includes(d.id));\n        }, getMemoOptions(table.options, \"debugColumns\", \"getCenterLeafColumns\"));\n    }\n};\n//\n//\nconst defaultColumnSizing = {\n    size: 150,\n    minSize: 20,\n    maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = ()=>({\n        startOffset: null,\n        startSize: null,\n        deltaOffset: null,\n        deltaPercentage: null,\n        isResizingColumn: false,\n        columnSizingStart: []\n    });\nconst ColumnSizing = {\n    getDefaultColumnDef: ()=>{\n        return defaultColumnSizing;\n    },\n    getInitialState: (state)=>{\n        return {\n            columnSizing: {},\n            columnSizingInfo: getDefaultColumnSizingInfoState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            columnResizeMode: \"onEnd\",\n            columnResizeDirection: \"ltr\",\n            onColumnSizingChange: makeStateUpdater(\"columnSizing\", table),\n            onColumnSizingInfoChange: makeStateUpdater(\"columnSizingInfo\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getSize = ()=>{\n            var _column$columnDef$min, _ref, _column$columnDef$max;\n            const columnSize = table.getState().columnSizing[column.id];\n            return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n        };\n        column.getStart = memo((position)=>[\n                position,\n                _getVisibleLeafColumns(table, position),\n                table.getState().columnSizing\n            ], (position, columns)=>columns.slice(0, column.getIndex(position)).reduce((sum, column)=>sum + column.getSize(), 0), getMemoOptions(table.options, \"debugColumns\", \"getStart\"));\n        column.getAfter = memo((position)=>[\n                position,\n                _getVisibleLeafColumns(table, position),\n                table.getState().columnSizing\n            ], (position, columns)=>columns.slice(column.getIndex(position) + 1).reduce((sum, column)=>sum + column.getSize(), 0), getMemoOptions(table.options, \"debugColumns\", \"getAfter\"));\n        column.resetSize = ()=>{\n            table.setColumnSizing((_ref2)=>{\n                let { [column.id]: _, ...rest } = _ref2;\n                return rest;\n            });\n        };\n        column.getCanResize = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n        };\n        column.getIsResizing = ()=>{\n            return table.getState().columnSizingInfo.isResizingColumn === column.id;\n        };\n    },\n    createHeader: (header, table)=>{\n        header.getSize = ()=>{\n            let sum = 0;\n            const recurse = (header)=>{\n                if (header.subHeaders.length) {\n                    header.subHeaders.forEach(recurse);\n                } else {\n                    var _header$column$getSiz;\n                    sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n                }\n            };\n            recurse(header);\n            return sum;\n        };\n        header.getStart = ()=>{\n            if (header.index > 0) {\n                const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n                return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n            }\n            return 0;\n        };\n        header.getResizeHandler = (_contextDocument)=>{\n            const column = table.getColumn(header.column.id);\n            const canResize = column == null ? void 0 : column.getCanResize();\n            return (e)=>{\n                if (!column || !canResize) {\n                    return;\n                }\n                e.persist == null || e.persist();\n                if (isTouchStartEvent(e)) {\n                    // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n                    if (e.touches && e.touches.length > 1) {\n                        return;\n                    }\n                }\n                const startSize = header.getSize();\n                const columnSizingStart = header ? header.getLeafHeaders().map((d)=>[\n                        d.column.id,\n                        d.column.getSize()\n                    ]) : [\n                    [\n                        column.id,\n                        column.getSize()\n                    ]\n                ];\n                const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n                const newColumnSizing = {};\n                const updateOffset = (eventType, clientXPos)=>{\n                    if (typeof clientXPos !== \"number\") {\n                        return;\n                    }\n                    table.setColumnSizingInfo((old)=>{\n                        var _old$startOffset, _old$startSize;\n                        const deltaDirection = table.options.columnResizeDirection === \"rtl\" ? -1 : 1;\n                        const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;\n                        const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n                        old.columnSizingStart.forEach((_ref3)=>{\n                            let [columnId, headerSize] = _ref3;\n                            newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n                        });\n                        return {\n                            ...old,\n                            deltaOffset,\n                            deltaPercentage\n                        };\n                    });\n                    if (table.options.columnResizeMode === \"onChange\" || eventType === \"end\") {\n                        table.setColumnSizing((old)=>({\n                                ...old,\n                                ...newColumnSizing\n                            }));\n                    }\n                };\n                const onMove = (clientXPos)=>updateOffset(\"move\", clientXPos);\n                const onEnd = (clientXPos)=>{\n                    updateOffset(\"end\", clientXPos);\n                    table.setColumnSizingInfo((old)=>({\n                            ...old,\n                            isResizingColumn: false,\n                            startOffset: null,\n                            startSize: null,\n                            deltaOffset: null,\n                            deltaPercentage: null,\n                            columnSizingStart: []\n                        }));\n                };\n                const contextDocument = _contextDocument || typeof document !== \"undefined\" ? document : null;\n                const mouseEvents = {\n                    moveHandler: (e)=>onMove(e.clientX),\n                    upHandler: (e)=>{\n                        contextDocument == null || contextDocument.removeEventListener(\"mousemove\", mouseEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"mouseup\", mouseEvents.upHandler);\n                        onEnd(e.clientX);\n                    }\n                };\n                const touchEvents = {\n                    moveHandler: (e)=>{\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onMove(e.touches[0].clientX);\n                        return false;\n                    },\n                    upHandler: (e)=>{\n                        var _e$touches$;\n                        contextDocument == null || contextDocument.removeEventListener(\"touchmove\", touchEvents.moveHandler);\n                        contextDocument == null || contextDocument.removeEventListener(\"touchend\", touchEvents.upHandler);\n                        if (e.cancelable) {\n                            e.preventDefault();\n                            e.stopPropagation();\n                        }\n                        onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n                    }\n                };\n                const passiveIfSupported = passiveEventSupported() ? {\n                    passive: false\n                } : false;\n                if (isTouchStartEvent(e)) {\n                    contextDocument == null || contextDocument.addEventListener(\"touchmove\", touchEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"touchend\", touchEvents.upHandler, passiveIfSupported);\n                } else {\n                    contextDocument == null || contextDocument.addEventListener(\"mousemove\", mouseEvents.moveHandler, passiveIfSupported);\n                    contextDocument == null || contextDocument.addEventListener(\"mouseup\", mouseEvents.upHandler, passiveIfSupported);\n                }\n                table.setColumnSizingInfo((old)=>({\n                        ...old,\n                        startOffset: clientX,\n                        startSize,\n                        deltaOffset: 0,\n                        deltaPercentage: 0,\n                        columnSizingStart,\n                        isResizingColumn: column.id\n                    }));\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setColumnSizing = (updater)=>table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n        table.setColumnSizingInfo = (updater)=>table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n        table.resetColumnSizing = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n        };\n        table.resetHeaderSizeInfo = (defaultState)=>{\n            var _table$initialState$c2;\n            table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n        };\n        table.getTotalSize = ()=>{\n            var _table$getHeaderGroup, _table$getHeaderGroup2;\n            return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getHeaderGroup : 0;\n        };\n        table.getLeftTotalSize = ()=>{\n            var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n            return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getLeftHeaderG : 0;\n        };\n        table.getCenterTotalSize = ()=>{\n            var _table$getCenterHeade, _table$getCenterHeade2;\n            return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getCenterHeade : 0;\n        };\n        table.getRightTotalSize = ()=>{\n            var _table$getRightHeader, _table$getRightHeader2;\n            return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header)=>{\n                return sum + header.getSize();\n            }, 0)) != null ? _table$getRightHeader : 0;\n        };\n    }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n    if (typeof passiveSupported === \"boolean\") return passiveSupported;\n    let supported = false;\n    try {\n        const options = {\n            get passive () {\n                supported = true;\n                return false;\n            }\n        };\n        const noop = ()=>{};\n        window.addEventListener(\"test\", noop, options);\n        window.removeEventListener(\"test\", noop);\n    } catch (err) {\n        supported = false;\n    }\n    passiveSupported = supported;\n    return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n    return e.type === \"touchstart\";\n}\n//\nconst ColumnVisibility = {\n    getInitialState: (state)=>{\n        return {\n            columnVisibility: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onColumnVisibilityChange: makeStateUpdater(\"columnVisibility\", table)\n        };\n    },\n    createColumn: (column, table)=>{\n        column.toggleVisibility = (value)=>{\n            if (column.getCanHide()) {\n                table.setColumnVisibility((old)=>({\n                        ...old,\n                        [column.id]: value != null ? value : !column.getIsVisible()\n                    }));\n            }\n        };\n        column.getIsVisible = ()=>{\n            var _ref, _table$getState$colum;\n            const childColumns = column.columns;\n            return (_ref = childColumns.length ? childColumns.some((c)=>c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;\n        };\n        column.getCanHide = ()=>{\n            var _column$columnDef$ena, _table$options$enable;\n            return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n        };\n        column.getToggleVisibilityHandler = ()=>{\n            return (e)=>{\n                column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row._getAllVisibleCells = memo(()=>[\n                row.getAllCells(),\n                table.getState().columnVisibility\n            ], (cells)=>{\n            return cells.filter((cell)=>cell.column.getIsVisible());\n        }, getMemoOptions(table.options, \"debugRows\", \"_getAllVisibleCells\"));\n        row.getVisibleCells = memo(()=>[\n                row.getLeftVisibleCells(),\n                row.getCenterVisibleCells(),\n                row.getRightVisibleCells()\n            ], (left, center, right)=>[\n                ...left,\n                ...center,\n                ...right\n            ], getMemoOptions(table.options, \"debugRows\", \"getVisibleCells\"));\n    },\n    createTable: (table)=>{\n        const makeVisibleColumnsMethod = (key, getColumns)=>{\n            return memo(()=>[\n                    getColumns(),\n                    getColumns().filter((d)=>d.getIsVisible()).map((d)=>d.id).join(\"_\")\n                ], (columns)=>{\n                return columns.filter((d)=>d.getIsVisible == null ? void 0 : d.getIsVisible());\n            }, getMemoOptions(table.options, \"debugColumns\", key));\n        };\n        table.getVisibleFlatColumns = makeVisibleColumnsMethod(\"getVisibleFlatColumns\", ()=>table.getAllFlatColumns());\n        table.getVisibleLeafColumns = makeVisibleColumnsMethod(\"getVisibleLeafColumns\", ()=>table.getAllLeafColumns());\n        table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod(\"getLeftVisibleLeafColumns\", ()=>table.getLeftLeafColumns());\n        table.getRightVisibleLeafColumns = makeVisibleColumnsMethod(\"getRightVisibleLeafColumns\", ()=>table.getRightLeafColumns());\n        table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod(\"getCenterVisibleLeafColumns\", ()=>table.getCenterLeafColumns());\n        table.setColumnVisibility = (updater)=>table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n        table.resetColumnVisibility = (defaultState)=>{\n            var _table$initialState$c;\n            table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n        };\n        table.toggleAllColumnsVisible = (value)=>{\n            var _value;\n            value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n            table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column)=>({\n                    ...obj,\n                    [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n                }), {}));\n        };\n        table.getIsAllColumnsVisible = ()=>!table.getAllLeafColumns().some((column)=>!(column.getIsVisible != null && column.getIsVisible()));\n        table.getIsSomeColumnsVisible = ()=>table.getAllLeafColumns().some((column)=>column.getIsVisible == null ? void 0 : column.getIsVisible());\n        table.getToggleAllColumnsVisibilityHandler = ()=>{\n            return (e)=>{\n                var _target;\n                table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nfunction _getVisibleLeafColumns(table, position) {\n    return !position ? table.getVisibleLeafColumns() : position === \"center\" ? table.getCenterVisibleLeafColumns() : position === \"left\" ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n}\n//\nconst GlobalFaceting = {\n    createTable: (table)=>{\n        table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, \"__global__\");\n        table.getGlobalFacetedRowModel = ()=>{\n            if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n                return table.getPreFilteredRowModel();\n            }\n            return table._getGlobalFacetedRowModel();\n        };\n        table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, \"__global__\");\n        table.getGlobalFacetedUniqueValues = ()=>{\n            if (!table._getGlobalFacetedUniqueValues) {\n                return new Map();\n            }\n            return table._getGlobalFacetedUniqueValues();\n        };\n        table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, \"__global__\");\n        table.getGlobalFacetedMinMaxValues = ()=>{\n            if (!table._getGlobalFacetedMinMaxValues) {\n                return;\n            }\n            return table._getGlobalFacetedMinMaxValues();\n        };\n    }\n};\n//\nconst GlobalFiltering = {\n    getInitialState: (state)=>{\n        return {\n            globalFilter: undefined,\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onGlobalFilterChange: makeStateUpdater(\"globalFilter\", table),\n            globalFilterFn: \"auto\",\n            getColumnCanGlobalFilter: (column)=>{\n                var _table$getCoreRowMode;\n                const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n                return typeof value === \"string\" || typeof value === \"number\";\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getCanGlobalFilter = ()=>{\n            var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;\n            return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n        };\n    },\n    createTable: (table)=>{\n        table.getGlobalAutoFilterFn = ()=>{\n            return filterFns.includesString;\n        };\n        table.getGlobalFilterFn = ()=>{\n            var _table$options$filter, _table$options$filter2;\n            const { globalFilterFn: globalFilterFn } = table.options;\n            return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === \"auto\" ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];\n        };\n        table.setGlobalFilter = (updater)=>{\n            table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n        };\n        table.resetGlobalFilter = (defaultState)=>{\n            table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n        };\n    }\n};\n//\nconst RowExpanding = {\n    getInitialState: (state)=>{\n        return {\n            expanded: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onExpandedChange: makeStateUpdater(\"expanded\", table),\n            paginateExpandedRows: true\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetExpanded = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetExpanded();\n                    queued = false;\n                });\n            }\n        };\n        table.setExpanded = (updater)=>table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n        table.toggleAllRowsExpanded = (expanded)=>{\n            if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n                table.setExpanded(true);\n            } else {\n                table.setExpanded({});\n            }\n        };\n        table.resetExpanded = (defaultState)=>{\n            var _table$initialState$e, _table$initialState;\n            table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n        };\n        table.getCanSomeRowsExpand = ()=>{\n            return table.getPrePaginationRowModel().flatRows.some((row)=>row.getCanExpand());\n        };\n        table.getToggleAllRowsExpandedHandler = ()=>{\n            return (e)=>{\n                e.persist == null || e.persist();\n                table.toggleAllRowsExpanded();\n            };\n        };\n        table.getIsSomeRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            return expanded === true || Object.values(expanded).some(Boolean);\n        };\n        table.getIsAllRowsExpanded = ()=>{\n            const expanded = table.getState().expanded;\n            // If expanded is true, save some cycles and return true\n            if (typeof expanded === \"boolean\") {\n                return expanded === true;\n            }\n            if (!Object.keys(expanded).length) {\n                return false;\n            }\n            // If any row is not expanded, return false\n            if (table.getRowModel().flatRows.some((row)=>!row.getIsExpanded())) {\n                return false;\n            }\n            // They must all be expanded :shrug:\n            return true;\n        };\n        table.getExpandedDepth = ()=>{\n            let maxDepth = 0;\n            const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n            rowIds.forEach((id)=>{\n                const splitId = id.split(\".\");\n                maxDepth = Math.max(maxDepth, splitId.length);\n            });\n            return maxDepth;\n        };\n        table.getPreExpandedRowModel = ()=>table.getSortedRowModel();\n        table.getExpandedRowModel = ()=>{\n            if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n                table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n            }\n            if (table.options.manualExpanding || !table._getExpandedRowModel) {\n                return table.getPreExpandedRowModel();\n            }\n            return table._getExpandedRowModel();\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleExpanded = (expanded)=>{\n            table.setExpanded((old)=>{\n                var _expanded;\n                const exists = old === true ? true : !!(old != null && old[row.id]);\n                let oldExpanded = {};\n                if (old === true) {\n                    Object.keys(table.getRowModel().rowsById).forEach((rowId)=>{\n                        oldExpanded[rowId] = true;\n                    });\n                } else {\n                    oldExpanded = old;\n                }\n                expanded = (_expanded = expanded) != null ? _expanded : !exists;\n                if (!exists && expanded) {\n                    return {\n                        ...oldExpanded,\n                        [row.id]: true\n                    };\n                }\n                if (exists && !expanded) {\n                    const { [row.id]: _, ...rest } = oldExpanded;\n                    return rest;\n                }\n                return old;\n            });\n        };\n        row.getIsExpanded = ()=>{\n            var _table$options$getIsR;\n            const expanded = table.getState().expanded;\n            return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n        };\n        row.getCanExpand = ()=>{\n            var _table$options$getRow, _table$options$enable, _row$subRows;\n            return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n        };\n        row.getIsAllParentsExpanded = ()=>{\n            let isFullyExpanded = true;\n            let currentRow = row;\n            while(isFullyExpanded && currentRow.parentId){\n                currentRow = table.getRow(currentRow.parentId, true);\n                isFullyExpanded = currentRow.getIsExpanded();\n            }\n            return isFullyExpanded;\n        };\n        row.getToggleExpandedHandler = ()=>{\n            const canExpand = row.getCanExpand();\n            return ()=>{\n                if (!canExpand) return;\n                row.toggleExpanded();\n            };\n        };\n    }\n};\n//\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = ()=>({\n        pageIndex: defaultPageIndex,\n        pageSize: defaultPageSize\n    });\nconst RowPagination = {\n    getInitialState: (state)=>{\n        return {\n            ...state,\n            pagination: {\n                ...getDefaultPaginationState(),\n                ...state == null ? void 0 : state.pagination\n            }\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onPaginationChange: makeStateUpdater(\"pagination\", table)\n        };\n    },\n    createTable: (table)=>{\n        let registered = false;\n        let queued = false;\n        table._autoResetPageIndex = ()=>{\n            var _ref, _table$options$autoRe;\n            if (!registered) {\n                table._queue(()=>{\n                    registered = true;\n                });\n                return;\n            }\n            if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n                if (queued) return;\n                queued = true;\n                table._queue(()=>{\n                    table.resetPageIndex();\n                    queued = false;\n                });\n            }\n        };\n        table.setPagination = (updater)=>{\n            const safeUpdater = (old)=>{\n                let newState = functionalUpdate(updater, old);\n                return newState;\n            };\n            return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n        };\n        table.resetPagination = (defaultState)=>{\n            var _table$initialState$p;\n            table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n        };\n        table.setPageIndex = (updater)=>{\n            table.setPagination((old)=>{\n                let pageIndex = functionalUpdate(updater, old.pageIndex);\n                const maxPageIndex = typeof table.options.pageCount === \"undefined\" || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n                pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n                return {\n                    ...old,\n                    pageIndex\n                };\n            });\n        };\n        table.resetPageIndex = (defaultState)=>{\n            var _table$initialState$p2, _table$initialState;\n            table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n        };\n        table.resetPageSize = (defaultState)=>{\n            var _table$initialState$p3, _table$initialState2;\n            table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n        };\n        table.setPageSize = (updater)=>{\n            table.setPagination((old)=>{\n                const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n                const topRowIndex = old.pageSize * old.pageIndex;\n                const pageIndex = Math.floor(topRowIndex / pageSize);\n                return {\n                    ...old,\n                    pageIndex,\n                    pageSize\n                };\n            });\n        };\n        //deprecated\n        table.setPageCount = (updater)=>table.setPagination((old)=>{\n                var _table$options$pageCo;\n                let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n                if (typeof newPageCount === \"number\") {\n                    newPageCount = Math.max(-1, newPageCount);\n                }\n                return {\n                    ...old,\n                    pageCount: newPageCount\n                };\n            });\n        table.getPageOptions = memo(()=>[\n                table.getPageCount()\n            ], (pageCount)=>{\n            let pageOptions = [];\n            if (pageCount && pageCount > 0) {\n                pageOptions = [\n                    ...new Array(pageCount)\n                ].fill(null).map((_, i)=>i);\n            }\n            return pageOptions;\n        }, getMemoOptions(table.options, \"debugTable\", \"getPageOptions\"));\n        table.getCanPreviousPage = ()=>table.getState().pagination.pageIndex > 0;\n        table.getCanNextPage = ()=>{\n            const { pageIndex } = table.getState().pagination;\n            const pageCount = table.getPageCount();\n            if (pageCount === -1) {\n                return true;\n            }\n            if (pageCount === 0) {\n                return false;\n            }\n            return pageIndex < pageCount - 1;\n        };\n        table.previousPage = ()=>{\n            return table.setPageIndex((old)=>old - 1);\n        };\n        table.nextPage = ()=>{\n            return table.setPageIndex((old)=>{\n                return old + 1;\n            });\n        };\n        table.firstPage = ()=>{\n            return table.setPageIndex(0);\n        };\n        table.lastPage = ()=>{\n            return table.setPageIndex(table.getPageCount() - 1);\n        };\n        table.getPrePaginationRowModel = ()=>table.getExpandedRowModel();\n        table.getPaginationRowModel = ()=>{\n            if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n                table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n            }\n            if (table.options.manualPagination || !table._getPaginationRowModel) {\n                return table.getPrePaginationRowModel();\n            }\n            return table._getPaginationRowModel();\n        };\n        table.getPageCount = ()=>{\n            var _table$options$pageCo2;\n            return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);\n        };\n        table.getRowCount = ()=>{\n            var _table$options$rowCou;\n            return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;\n        };\n    }\n};\n//\nconst getDefaultRowPinningState = ()=>({\n        top: [],\n        bottom: []\n    });\nconst RowPinning = {\n    getInitialState: (state)=>{\n        return {\n            rowPinning: getDefaultRowPinningState(),\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowPinningChange: makeStateUpdater(\"rowPinning\", table)\n        };\n    },\n    createRow: (row, table)=>{\n        row.pin = (position, includeLeafRows, includeParentRows)=>{\n            const leafRowIds = includeLeafRows ? row.getLeafRows().map((_ref)=>{\n                let { id } = _ref;\n                return id;\n            }) : [];\n            const parentRowIds = includeParentRows ? row.getParentRows().map((_ref2)=>{\n                let { id } = _ref2;\n                return id;\n            }) : [];\n            const rowIds = new Set([\n                ...parentRowIds,\n                row.id,\n                ...leafRowIds\n            ]);\n            table.setRowPinning((old)=>{\n                var _old$top3, _old$bottom3;\n                if (position === \"bottom\") {\n                    var _old$top, _old$bottom;\n                    return {\n                        top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                        bottom: [\n                            ...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ]\n                    };\n                }\n                if (position === \"top\") {\n                    var _old$top2, _old$bottom2;\n                    return {\n                        top: [\n                            ...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                            ...Array.from(rowIds)\n                        ],\n                        bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                    };\n                }\n                return {\n                    top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter((d)=>!(rowIds != null && rowIds.has(d))),\n                    bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter((d)=>!(rowIds != null && rowIds.has(d)))\n                };\n            });\n        };\n        row.getCanPin = ()=>{\n            var _ref3;\n            const { enableRowPinning, enablePinning } = table.options;\n            if (typeof enableRowPinning === \"function\") {\n                return enableRowPinning(row);\n            }\n            return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;\n        };\n        row.getIsPinned = ()=>{\n            const rowIds = [\n                row.id\n            ];\n            const { top, bottom } = table.getState().rowPinning;\n            const isTop = rowIds.some((d)=>top == null ? void 0 : top.includes(d));\n            const isBottom = rowIds.some((d)=>bottom == null ? void 0 : bottom.includes(d));\n            return isTop ? \"top\" : isBottom ? \"bottom\" : false;\n        };\n        row.getPinnedIndex = ()=>{\n            var _ref4, _visiblePinnedRowIds$;\n            const position = row.getIsPinned();\n            if (!position) return -1;\n            const visiblePinnedRowIds = (_ref4 = position === \"top\" ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map((_ref5)=>{\n                let { id } = _ref5;\n                return id;\n            });\n            return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n        };\n    },\n    createTable: (table)=>{\n        table.setRowPinning = (updater)=>table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n        table.resetRowPinning = (defaultState)=>{\n            var _table$initialState$r, _table$initialState;\n            return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n        };\n        table.getIsSomeRowsPinned = (position)=>{\n            var _pinningState$positio;\n            const pinningState = table.getState().rowPinning;\n            if (!position) {\n                var _pinningState$top, _pinningState$bottom;\n                return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n            }\n            return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n        };\n        table._getPinnedRows = (visibleRows, pinnedRowIds, position)=>{\n            var _table$options$keepPi;\n            const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ? //get all rows that are pinned even if they would not be otherwise visible\n            //account for expanded parent rows, but not pagination or filtering\n            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>{\n                const row = table.getRow(rowId, true);\n                return row.getIsAllParentsExpanded() ? row : null;\n            }) : //else get only visible rows that are pinned\n            (pinnedRowIds != null ? pinnedRowIds : []).map((rowId)=>visibleRows.find((row)=>row.id === rowId));\n            return rows.filter(Boolean).map((d)=>({\n                    ...d,\n                    position\n                }));\n        };\n        table.getTopRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top\n            ], (allRows, topPinnedRowIds)=>table._getPinnedRows(allRows, topPinnedRowIds, \"top\"), getMemoOptions(table.options, \"debugRows\", \"getTopRows\"));\n        table.getBottomRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.bottom\n            ], (allRows, bottomPinnedRowIds)=>table._getPinnedRows(allRows, bottomPinnedRowIds, \"bottom\"), getMemoOptions(table.options, \"debugRows\", \"getBottomRows\"));\n        table.getCenterRows = memo(()=>[\n                table.getRowModel().rows,\n                table.getState().rowPinning.top,\n                table.getState().rowPinning.bottom\n            ], (allRows, top, bottom)=>{\n            const topAndBottom = new Set([\n                ...top != null ? top : [],\n                ...bottom != null ? bottom : []\n            ]);\n            return allRows.filter((d)=>!topAndBottom.has(d.id));\n        }, getMemoOptions(table.options, \"debugRows\", \"getCenterRows\"));\n    }\n};\n//\nconst RowSelection = {\n    getInitialState: (state)=>{\n        return {\n            rowSelection: {},\n            ...state\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onRowSelectionChange: makeStateUpdater(\"rowSelection\", table),\n            enableRowSelection: true,\n            enableMultiRowSelection: true,\n            enableSubRowSelection: true\n        };\n    },\n    createTable: (table)=>{\n        table.setRowSelection = (updater)=>table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n        table.resetRowSelection = (defaultState)=>{\n            var _table$initialState$r;\n            return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n        };\n        table.toggleAllRowsSelected = (value)=>{\n            table.setRowSelection((old)=>{\n                value = typeof value !== \"undefined\" ? value : !table.getIsAllRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n                // We don't use `mutateRowIsSelected` here for performance reasons.\n                // All of the rows are flat already, so it wouldn't be worth it\n                if (value) {\n                    preGroupedFlatRows.forEach((row)=>{\n                        if (!row.getCanSelect()) {\n                            return;\n                        }\n                        rowSelection[row.id] = true;\n                    });\n                } else {\n                    preGroupedFlatRows.forEach((row)=>{\n                        delete rowSelection[row.id];\n                    });\n                }\n                return rowSelection;\n            });\n        };\n        table.toggleAllPageRowsSelected = (value)=>table.setRowSelection((old)=>{\n                const resolvedValue = typeof value !== \"undefined\" ? value : !table.getIsAllPageRowsSelected();\n                const rowSelection = {\n                    ...old\n                };\n                table.getRowModel().rows.forEach((row)=>{\n                    mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n                });\n                return rowSelection;\n            });\n        // addRowSelectionRange: rowId => {\n        //   const {\n        //     rows,\n        //     rowsById,\n        //     options: { selectGroupingRows, selectSubRows },\n        //   } = table\n        //   const findSelectedRow = (rows: Row[]) => {\n        //     let found\n        //     rows.find(d => {\n        //       if (d.getIsSelected()) {\n        //         found = d\n        //         return true\n        //       }\n        //       const subFound = findSelectedRow(d.subRows || [])\n        //       if (subFound) {\n        //         found = subFound\n        //         return true\n        //       }\n        //       return false\n        //     })\n        //     return found\n        //   }\n        //   const firstRow = findSelectedRow(rows) || rows[0]\n        //   const lastRow = rowsById[rowId]\n        //   let include = false\n        //   const selectedRowIds = {}\n        //   const addRow = (row: Row) => {\n        //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n        //       rowsById,\n        //       selectGroupingRows: selectGroupingRows!,\n        //       selectSubRows: selectSubRows!,\n        //     })\n        //   }\n        //   table.rows.forEach(row => {\n        //     const isFirstRow = row.id === firstRow.id\n        //     const isLastRow = row.id === lastRow.id\n        //     if (isFirstRow || isLastRow) {\n        //       if (!include) {\n        //         include = true\n        //       } else if (include) {\n        //         addRow(row)\n        //         include = false\n        //       }\n        //     }\n        //     if (include) {\n        //       addRow(row)\n        //     }\n        //   })\n        //   table.setRowSelection(selectedRowIds)\n        // },\n        table.getPreSelectedRowModel = ()=>table.getCoreRowModel();\n        table.getSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getCoreRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getSelectedRowModel\"));\n        table.getFilteredSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getFilteredRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFilteredSelectedRowModel\"));\n        table.getGroupedSelectedRowModel = memo(()=>[\n                table.getState().rowSelection,\n                table.getSortedRowModel()\n            ], (rowSelection, rowModel)=>{\n            if (!Object.keys(rowSelection).length) {\n                return {\n                    rows: [],\n                    flatRows: [],\n                    rowsById: {}\n                };\n            }\n            return selectRowsFn(table, rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getGroupedSelectedRowModel\"));\n        ///\n        // getGroupingRowCanSelect: rowId => {\n        //   const row = table.getRow(rowId)\n        //   if (!row) {\n        //     throw new Error()\n        //   }\n        //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n        //     return table.options.enableGroupingRowSelection(row)\n        //   }\n        //   return table.options.enableGroupingRowSelection ?? false\n        // },\n        table.getIsAllRowsSelected = ()=>{\n            const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n            const { rowSelection } = table.getState();\n            let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n            if (isAllRowsSelected) {\n                if (preGroupedFlatRows.some((row)=>row.getCanSelect() && !rowSelection[row.id])) {\n                    isAllRowsSelected = false;\n                }\n            }\n            return isAllRowsSelected;\n        };\n        table.getIsAllPageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows.filter((row)=>row.getCanSelect());\n            const { rowSelection } = table.getState();\n            let isAllPageRowsSelected = !!paginationFlatRows.length;\n            if (isAllPageRowsSelected && paginationFlatRows.some((row)=>!rowSelection[row.id])) {\n                isAllPageRowsSelected = false;\n            }\n            return isAllPageRowsSelected;\n        };\n        table.getIsSomeRowsSelected = ()=>{\n            var _table$getState$rowSe;\n            const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n            return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n        };\n        table.getIsSomePageRowsSelected = ()=>{\n            const paginationFlatRows = table.getPaginationRowModel().flatRows;\n            return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter((row)=>row.getCanSelect()).some((d)=>d.getIsSelected() || d.getIsSomeSelected());\n        };\n        table.getToggleAllRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllRowsSelected(e.target.checked);\n            };\n        };\n        table.getToggleAllPageRowsSelectedHandler = ()=>{\n            return (e)=>{\n                table.toggleAllPageRowsSelected(e.target.checked);\n            };\n        };\n    },\n    createRow: (row, table)=>{\n        row.toggleSelected = (value, opts)=>{\n            const isSelected = row.getIsSelected();\n            table.setRowSelection((old)=>{\n                var _opts$selectChildren;\n                value = typeof value !== \"undefined\" ? value : !isSelected;\n                if (row.getCanSelect() && isSelected === value) {\n                    return old;\n                }\n                const selectedRowIds = {\n                    ...old\n                };\n                mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n                return selectedRowIds;\n            });\n        };\n        row.getIsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isRowSelected(row, rowSelection);\n        };\n        row.getIsSomeSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"some\";\n        };\n        row.getIsAllSubRowsSelected = ()=>{\n            const { rowSelection } = table.getState();\n            return isSubRowSelected(row, rowSelection) === \"all\";\n        };\n        row.getCanSelect = ()=>{\n            var _table$options$enable;\n            if (typeof table.options.enableRowSelection === \"function\") {\n                return table.options.enableRowSelection(row);\n            }\n            return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n        };\n        row.getCanSelectSubRows = ()=>{\n            var _table$options$enable2;\n            if (typeof table.options.enableSubRowSelection === \"function\") {\n                return table.options.enableSubRowSelection(row);\n            }\n            return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n        };\n        row.getCanMultiSelect = ()=>{\n            var _table$options$enable3;\n            if (typeof table.options.enableMultiRowSelection === \"function\") {\n                return table.options.enableMultiRowSelection(row);\n            }\n            return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n        };\n        row.getToggleSelectedHandler = ()=>{\n            const canSelect = row.getCanSelect();\n            return (e)=>{\n                var _target;\n                if (!canSelect) return;\n                row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n            };\n        };\n    }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table)=>{\n    var _row$subRows;\n    const row = table.getRow(id, true);\n    // const isGrouped = row.getIsGrouped()\n    // if ( // TODO: enforce grouping row selection rules\n    //   !isGrouped ||\n    //   (isGrouped && table.options.enableGroupingRowSelection)\n    // ) {\n    if (value) {\n        if (!row.getCanMultiSelect()) {\n            Object.keys(selectedRowIds).forEach((key)=>delete selectedRowIds[key]);\n        }\n        if (row.getCanSelect()) {\n            selectedRowIds[id] = true;\n        }\n    } else {\n        delete selectedRowIds[id];\n    }\n    // }\n    if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n        row.subRows.forEach((row)=>mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n    }\n};\nfunction selectRowsFn(table, rowModel) {\n    const rowSelection = table.getState().rowSelection;\n    const newSelectedFlatRows = [];\n    const newSelectedRowsById = {};\n    // Filters top level and nested rows\n    const recurseRows = function(rows, depth) {\n        return rows.map((row)=>{\n            var _row$subRows2;\n            const isSelected = isRowSelected(row, rowSelection);\n            if (isSelected) {\n                newSelectedFlatRows.push(row);\n                newSelectedRowsById[row.id] = row;\n            }\n            if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n                row = {\n                    ...row,\n                    subRows: recurseRows(row.subRows)\n                };\n            }\n            if (isSelected) {\n                return row;\n            }\n        }).filter(Boolean);\n    };\n    return {\n        rows: recurseRows(rowModel.rows),\n        flatRows: newSelectedFlatRows,\n        rowsById: newSelectedRowsById\n    };\n}\nfunction isRowSelected(row, selection) {\n    var _selection$row$id;\n    return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n    var _row$subRows3;\n    if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n    let allChildrenSelected = true;\n    let someSelected = false;\n    row.subRows.forEach((subRow)=>{\n        // Bail out early if we know both of these\n        if (someSelected && !allChildrenSelected) {\n            return;\n        }\n        if (subRow.getCanSelect()) {\n            if (isRowSelected(subRow, selection)) {\n                someSelected = true;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n        // Check row selection of nested subrows\n        if (subRow.subRows && subRow.subRows.length) {\n            const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n            if (subRowChildrenSelected === \"all\") {\n                someSelected = true;\n            } else if (subRowChildrenSelected === \"some\") {\n                someSelected = true;\n                allChildrenSelected = false;\n            } else {\n                allChildrenSelected = false;\n            }\n        }\n    });\n    return allChildrenSelected ? \"all\" : someSelected ? \"some\" : false;\n}\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId)=>{\n    return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId)=>{\n    const a = rowA.getValue(columnId);\n    const b = rowB.getValue(columnId);\n    // Can handle nullish values\n    // Use > and < because == (and ===) doesn't work with\n    // Date objects (would require calling getTime()).\n    return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId)=>{\n    return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n// Utils\nfunction compareBasic(a, b) {\n    return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n    if (typeof a === \"number\") {\n        if (isNaN(a) || a === Infinity || a === -Infinity) {\n            return \"\";\n        }\n        return String(a);\n    }\n    if (typeof a === \"string\") {\n        return a;\n    }\n    return \"\";\n}\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n    // Split on number groups, but keep the delimiter\n    // Then remove falsey split values\n    const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n    const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n    // While\n    while(a.length && b.length){\n        const aa = a.shift();\n        const bb = b.shift();\n        const an = parseInt(aa, 10);\n        const bn = parseInt(bb, 10);\n        const combo = [\n            an,\n            bn\n        ].sort();\n        // Both are string\n        if (isNaN(combo[0])) {\n            if (aa > bb) {\n                return 1;\n            }\n            if (bb > aa) {\n                return -1;\n            }\n            continue;\n        }\n        // One is a string, one is a number\n        if (isNaN(combo[1])) {\n            return isNaN(an) ? -1 : 1;\n        }\n        // Both are numbers\n        if (an > bn) {\n            return 1;\n        }\n        if (bn > an) {\n            return -1;\n        }\n    }\n    return a.length - b.length;\n}\n// Exports\nconst sortingFns = {\n    alphanumeric,\n    alphanumericCaseSensitive,\n    text,\n    textCaseSensitive,\n    datetime,\n    basic\n};\n//\nconst RowSorting = {\n    getInitialState: (state)=>{\n        return {\n            sorting: [],\n            ...state\n        };\n    },\n    getDefaultColumnDef: ()=>{\n        return {\n            sortingFn: \"auto\",\n            sortUndefined: 1\n        };\n    },\n    getDefaultOptions: (table)=>{\n        return {\n            onSortingChange: makeStateUpdater(\"sorting\", table),\n            isMultiSortEvent: (e)=>{\n                return e.shiftKey;\n            }\n        };\n    },\n    createColumn: (column, table)=>{\n        column.getAutoSortingFn = ()=>{\n            const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n            let isString = false;\n            for (const row of firstRows){\n                const value = row == null ? void 0 : row.getValue(column.id);\n                if (Object.prototype.toString.call(value) === \"[object Date]\") {\n                    return sortingFns.datetime;\n                }\n                if (typeof value === \"string\") {\n                    isString = true;\n                    if (value.split(reSplitAlphaNumeric).length > 1) {\n                        return sortingFns.alphanumeric;\n                    }\n                }\n            }\n            if (isString) {\n                return sortingFns.text;\n            }\n            return sortingFns.basic;\n        };\n        column.getAutoSortDir = ()=>{\n            const firstRow = table.getFilteredRowModel().flatRows[0];\n            const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n            if (typeof value === \"string\") {\n                return \"asc\";\n            }\n            return \"desc\";\n        };\n        column.getSortingFn = ()=>{\n            var _table$options$sortin, _table$options$sortin2;\n            if (!column) {\n                throw new Error();\n            }\n            return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === \"auto\" ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n        };\n        column.toggleSorting = (desc, multi)=>{\n            // if (column.columns.length) {\n            //   column.columns.forEach((c, i) => {\n            //     if (c.id) {\n            //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n            //     }\n            //   })\n            //   return\n            // }\n            // this needs to be outside of table.setSorting to be in sync with rerender\n            const nextSortingOrder = column.getNextSortingOrder();\n            const hasManualValue = typeof desc !== \"undefined\" && desc !== null;\n            table.setSorting((old)=>{\n                // Find any existing sorting for this column\n                const existingSorting = old == null ? void 0 : old.find((d)=>d.id === column.id);\n                const existingIndex = old == null ? void 0 : old.findIndex((d)=>d.id === column.id);\n                let newSorting = [];\n                // What should we do with this sort action?\n                let sortAction;\n                let nextDesc = hasManualValue ? desc : nextSortingOrder === \"desc\";\n                // Multi-mode\n                if (old != null && old.length && column.getCanMultiSort() && multi) {\n                    if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"add\";\n                    }\n                } else {\n                    // Normal mode\n                    if (old != null && old.length && existingIndex !== old.length - 1) {\n                        sortAction = \"replace\";\n                    } else if (existingSorting) {\n                        sortAction = \"toggle\";\n                    } else {\n                        sortAction = \"replace\";\n                    }\n                }\n                // Handle toggle states that will remove the sorting\n                if (sortAction === \"toggle\") {\n                    // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n                    if (!hasManualValue) {\n                        // Is our intention to remove?\n                        if (!nextSortingOrder) {\n                            sortAction = \"remove\";\n                        }\n                    }\n                }\n                if (sortAction === \"add\") {\n                    var _table$options$maxMul;\n                    newSorting = [\n                        ...old,\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                    // Take latest n columns\n                    newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n                } else if (sortAction === \"toggle\") {\n                    // This flips (or sets) the\n                    newSorting = old.map((d)=>{\n                        if (d.id === column.id) {\n                            return {\n                                ...d,\n                                desc: nextDesc\n                            };\n                        }\n                        return d;\n                    });\n                } else if (sortAction === \"remove\") {\n                    newSorting = old.filter((d)=>d.id !== column.id);\n                } else {\n                    newSorting = [\n                        {\n                            id: column.id,\n                            desc: nextDesc\n                        }\n                    ];\n                }\n                return newSorting;\n            });\n        };\n        column.getFirstSortDir = ()=>{\n            var _ref, _column$columnDef$sor;\n            const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === \"desc\";\n            return sortDescFirst ? \"desc\" : \"asc\";\n        };\n        column.getNextSortingOrder = (multi)=>{\n            var _table$options$enable, _table$options$enable2;\n            const firstSortDirection = column.getFirstSortDir();\n            const isSorted = column.getIsSorted();\n            if (!isSorted) {\n                return firstSortDirection;\n            }\n            if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && // If enableSortRemove, enable in general\n            (multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true // If multi, don't allow if enableMultiRemove))\n            )) {\n                return false;\n            }\n            return isSorted === \"desc\" ? \"asc\" : \"desc\";\n        };\n        column.getCanSort = ()=>{\n            var _column$columnDef$ena, _table$options$enable3;\n            return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n        };\n        column.getCanMultiSort = ()=>{\n            var _ref2, _column$columnDef$ena2;\n            return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n        };\n        column.getIsSorted = ()=>{\n            var _table$getState$sorti;\n            const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find((d)=>d.id === column.id);\n            return !columnSort ? false : columnSort.desc ? \"desc\" : \"asc\";\n        };\n        column.getSortIndex = ()=>{\n            var _table$getState$sorti2, _table$getState$sorti3;\n            return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex((d)=>d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n        };\n        column.clearSorting = ()=>{\n            //clear sorting for just 1 column\n            table.setSorting((old)=>old != null && old.length ? old.filter((d)=>d.id !== column.id) : []);\n        };\n        column.getToggleSortingHandler = ()=>{\n            const canSort = column.getCanSort();\n            return (e)=>{\n                if (!canSort) return;\n                e.persist == null || e.persist();\n                column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n            };\n        };\n    },\n    createTable: (table)=>{\n        table.setSorting = (updater)=>table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n        table.resetSorting = (defaultState)=>{\n            var _table$initialState$s, _table$initialState;\n            table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n        };\n        table.getPreSortedRowModel = ()=>table.getGroupedRowModel();\n        table.getSortedRowModel = ()=>{\n            if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n                table._getSortedRowModel = table.options.getSortedRowModel(table);\n            }\n            if (table.options.manualSorting || !table._getSortedRowModel) {\n                return table.getPreSortedRowModel();\n            }\n            return table._getSortedRowModel();\n        };\n    }\n};\nconst builtInFeatures = [\n    Headers,\n    ColumnVisibility,\n    ColumnOrdering,\n    ColumnPinning,\n    ColumnFaceting,\n    ColumnFiltering,\n    GlobalFaceting,\n    //depends on ColumnFaceting\n    GlobalFiltering,\n    //depends on ColumnFiltering\n    RowSorting,\n    ColumnGrouping,\n    //depends on RowSorting\n    RowExpanding,\n    RowPagination,\n    RowPinning,\n    RowSelection,\n    ColumnSizing\n];\n//\nfunction createTable(options) {\n    var _options$_features, _options$initialState;\n    if ( true && (options.debugAll || options.debugTable)) {\n        console.info(\"Creating Table Instance...\");\n    }\n    const _features = [\n        ...builtInFeatures,\n        ...(_options$_features = options._features) != null ? _options$_features : []\n    ];\n    let table = {\n        _features\n    };\n    const defaultOptions = table._features.reduce((obj, feature)=>{\n        return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n    }, {});\n    const mergeOptions = (options)=>{\n        if (table.options.mergeOptions) {\n            return table.options.mergeOptions(defaultOptions, options);\n        }\n        return {\n            ...defaultOptions,\n            ...options\n        };\n    };\n    const coreInitialState = {};\n    let initialState = {\n        ...coreInitialState,\n        ...(_options$initialState = options.initialState) != null ? _options$initialState : {}\n    };\n    table._features.forEach((feature)=>{\n        var _feature$getInitialSt;\n        initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n    });\n    const queued = [];\n    let queuedTimeout = false;\n    const coreInstance = {\n        _features,\n        options: {\n            ...defaultOptions,\n            ...options\n        },\n        initialState,\n        _queue: (cb)=>{\n            queued.push(cb);\n            if (!queuedTimeout) {\n                queuedTimeout = true;\n                // Schedule a microtask to run the queued callbacks after\n                // the current call stack (render, etc) has finished.\n                Promise.resolve().then(()=>{\n                    while(queued.length){\n                        queued.shift()();\n                    }\n                    queuedTimeout = false;\n                }).catch((error)=>setTimeout(()=>{\n                        throw error;\n                    }));\n            }\n        },\n        reset: ()=>{\n            table.setState(table.initialState);\n        },\n        setOptions: (updater)=>{\n            const newOptions = functionalUpdate(updater, table.options);\n            table.options = mergeOptions(newOptions);\n        },\n        getState: ()=>{\n            return table.options.state;\n        },\n        setState: (updater)=>{\n            table.options.onStateChange == null || table.options.onStateChange(updater);\n        },\n        _getRowId: (row, index, parent)=>{\n            var _table$options$getRow;\n            return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [\n                parent.id,\n                index\n            ].join(\".\") : index}`;\n        },\n        getCoreRowModel: ()=>{\n            if (!table._getCoreRowModel) {\n                table._getCoreRowModel = table.options.getCoreRowModel(table);\n            }\n            return table._getCoreRowModel();\n        },\n        // The final calls start at the bottom of the model,\n        // expanded rows, which then work their way up\n        getRowModel: ()=>{\n            return table.getPaginationRowModel();\n        },\n        //in next version, we should just pass in the row model as the optional 2nd arg\n        getRow: (id, searchAll)=>{\n            let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];\n            if (!row) {\n                row = table.getCoreRowModel().rowsById[id];\n                if (!row) {\n                    if (true) {\n                        throw new Error(`getRow could not find row with ID: ${id}`);\n                    }\n                    throw new Error();\n                }\n            }\n            return row;\n        },\n        _getDefaultColumnDef: memo(()=>[\n                table.options.defaultColumn\n            ], (defaultColumn)=>{\n            var _defaultColumn;\n            defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n            return {\n                header: (props)=>{\n                    const resolvedColumnDef = props.header.column.columnDef;\n                    if (resolvedColumnDef.accessorKey) {\n                        return resolvedColumnDef.accessorKey;\n                    }\n                    if (resolvedColumnDef.accessorFn) {\n                        return resolvedColumnDef.id;\n                    }\n                    return null;\n                },\n                // footer: props => props.header.column.id,\n                cell: (props)=>{\n                    var _props$renderValue$to, _props$renderValue;\n                    return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n                },\n                ...table._features.reduce((obj, feature)=>{\n                    return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n                }, {}),\n                ...defaultColumn\n            };\n        }, getMemoOptions(options, \"debugColumns\", \"_getDefaultColumnDef\")),\n        _getColumnDefs: ()=>table.options.columns,\n        getAllColumns: memo(()=>[\n                table._getColumnDefs()\n            ], (columnDefs)=>{\n            const recurseColumns = function(columnDefs, parent, depth) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                return columnDefs.map((columnDef)=>{\n                    const column = createColumn(table, columnDef, depth, parent);\n                    const groupingColumnDef = columnDef;\n                    column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n                    return column;\n                });\n            };\n            return recurseColumns(columnDefs);\n        }, getMemoOptions(options, \"debugColumns\", \"getAllColumns\")),\n        getAllFlatColumns: memo(()=>[\n                table.getAllColumns()\n            ], (allColumns)=>{\n            return allColumns.flatMap((column)=>{\n                return column.getFlatColumns();\n            });\n        }, getMemoOptions(options, \"debugColumns\", \"getAllFlatColumns\")),\n        _getAllFlatColumnsById: memo(()=>[\n                table.getAllFlatColumns()\n            ], (flatColumns)=>{\n            return flatColumns.reduce((acc, column)=>{\n                acc[column.id] = column;\n                return acc;\n            }, {});\n        }, getMemoOptions(options, \"debugColumns\", \"getAllFlatColumnsById\")),\n        getAllLeafColumns: memo(()=>[\n                table.getAllColumns(),\n                table._getOrderColumnsFn()\n            ], (allColumns, orderColumns)=>{\n            let leafColumns = allColumns.flatMap((column)=>column.getLeafColumns());\n            return orderColumns(leafColumns);\n        }, getMemoOptions(options, \"debugColumns\", \"getAllLeafColumns\")),\n        getColumn: (columnId)=>{\n            const column = table._getAllFlatColumnsById()[columnId];\n            if ( true && !column) {\n                console.error(`[Table] Column with id '${columnId}' does not exist.`);\n            }\n            return column;\n        }\n    };\n    Object.assign(table, coreInstance);\n    for(let index = 0; index < table._features.length; index++){\n        const feature = table._features[index];\n        feature == null || feature.createTable == null || feature.createTable(table);\n    }\n    return table;\n}\nfunction getCoreRowModel() {\n    return (table)=>memo(()=>[\n                table.options.data\n            ], (data)=>{\n            const rowModel = {\n                rows: [],\n                flatRows: [],\n                rowsById: {}\n            };\n            const accessRows = function(originalRows, depth, parentRow) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                const rows = [];\n                for(let i = 0; i < originalRows.length; i++){\n                    // This could be an expensive check at scale, so we should move it somewhere else, but where?\n                    // if (!id) {\n                    //   if (process.env.NODE_ENV !== 'production') {\n                    //     throw new Error(`getRowId expected an ID, but got ${id}`)\n                    //   }\n                    // }\n                    // Make the row\n                    const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n                    // Keep track of every row in a flat array\n                    rowModel.flatRows.push(row);\n                    // Also keep track of every row by its ID\n                    rowModel.rowsById[row.id] = row;\n                    // Push table row into parent\n                    rows.push(row);\n                    // Get the original subrows\n                    if (table.options.getSubRows) {\n                        var _row$originalSubRows;\n                        row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n                        // Then recursively access them\n                        if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n                            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n                        }\n                    }\n                }\n                return rows;\n            };\n            rowModel.rows = accessRows(data);\n            return rowModel;\n        }, getMemoOptions(table.options, \"debugTable\", \"getRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction getExpandedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().expanded,\n                table.getPreExpandedRowModel(),\n                table.options.paginateExpandedRows\n            ], (expanded, rowModel, paginateExpandedRows)=>{\n            if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n                return rowModel;\n            }\n            if (!paginateExpandedRows) {\n                // Only expand rows at this point if they are being paginated\n                return rowModel;\n            }\n            return expandRows(rowModel);\n        }, getMemoOptions(table.options, \"debugTable\", \"getExpandedRowModel\"));\n}\nfunction expandRows(rowModel) {\n    const expandedRows = [];\n    const handleRow = (row)=>{\n        var _row$subRows;\n        expandedRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n            row.subRows.forEach(handleRow);\n        }\n    };\n    rowModel.rows.forEach(handleRow);\n    return {\n        rows: expandedRows,\n        flatRows: rowModel.flatRows,\n        rowsById: rowModel.rowsById\n    };\n}\nfunction getFacetedMinMaxValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            var _facetedRowModel$flat;\n            if (!facetedRowModel) return undefined;\n            const firstValue = (_facetedRowModel$flat = facetedRowModel.flatRows[0]) == null ? void 0 : _facetedRowModel$flat.getUniqueValues(columnId);\n            if (typeof firstValue === \"undefined\") {\n                return undefined;\n            }\n            let facetedMinMaxValues = [\n                firstValue,\n                firstValue\n            ];\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (value < facetedMinMaxValues[0]) {\n                        facetedMinMaxValues[0] = value;\n                    } else if (value > facetedMinMaxValues[1]) {\n                        facetedMinMaxValues[1] = value;\n                    }\n                }\n            }\n            return facetedMinMaxValues;\n        }, getMemoOptions(table.options, \"debugTable\", \"getFacetedMinMaxValues\"));\n}\nfunction filterRows(rows, filterRowImpl, table) {\n    if (table.options.filterFromLeafRows) {\n        return filterRowModelFromLeafs(rows, filterRowImpl, table);\n    }\n    return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        const rows = [];\n        // Filter from children up first\n        for(let i = 0; i < rowsToFilter.length; i++){\n            var _row$subRows;\n            let row = rowsToFilter[i];\n            const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n            newRow.columnFilters = row.columnFilters;\n            if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n                newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                row = newRow;\n                if (filterRow(row) && !newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n                if (filterRow(row) || newRow.subRows.length) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                    continue;\n                }\n            } else {\n                row = newRow;\n                if (filterRow(row)) {\n                    rows.push(row);\n                    newFilteredRowsById[row.id] = row;\n                    newFilteredFlatRows.push(row);\n                }\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n    var _table$options$maxLea2;\n    const newFilteredFlatRows = [];\n    const newFilteredRowsById = {};\n    const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n    // Filters top level and nested rows\n    const recurseFilterRows = function(rowsToFilter, depth) {\n        if (depth === void 0) {\n            depth = 0;\n        }\n        // Filter from parents downward first\n        const rows = [];\n        // Apply the filter to any subRows\n        for(let i = 0; i < rowsToFilter.length; i++){\n            let row = rowsToFilter[i];\n            const pass = filterRow(row);\n            if (pass) {\n                var _row$subRows2;\n                if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n                    const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n                    newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n                    row = newRow;\n                }\n                rows.push(row);\n                newFilteredFlatRows.push(row);\n                newFilteredRowsById[row.id] = row;\n            }\n        }\n        return rows;\n    };\n    return {\n        rows: recurseFilterRows(rowsToFilter),\n        flatRows: newFilteredFlatRows,\n        rowsById: newFilteredRowsById\n    };\n}\nfunction getFacetedRowModel() {\n    return (table, columnId)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter,\n                table.getFilteredRowModel()\n            ], (preRowModel, columnFilters, globalFilter)=>{\n            if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                return preRowModel;\n            }\n            const filterableIds = [\n                ...columnFilters.map((d)=>d.id).filter((d)=>d !== columnId),\n                globalFilter ? \"__global__\" : undefined\n            ].filter(Boolean);\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            return filterRows(preRowModel.rows, filterRowsImpl, table);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFacetedRowModel\"));\n}\nfunction getFacetedUniqueValues() {\n    return (table, columnId)=>memo(()=>{\n            var _table$getColumn;\n            return [\n                (_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()\n            ];\n        }, (facetedRowModel)=>{\n            if (!facetedRowModel) return new Map();\n            let facetedUniqueValues = new Map();\n            for(let i = 0; i < facetedRowModel.flatRows.length; i++){\n                const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n                for(let j = 0; j < values.length; j++){\n                    const value = values[j];\n                    if (facetedUniqueValues.has(value)) {\n                        var _facetedUniqueValues$;\n                        facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n                    } else {\n                        facetedUniqueValues.set(value, 1);\n                    }\n                }\n            }\n            return facetedUniqueValues;\n        }, getMemoOptions(table.options, \"debugTable\", `getFacetedUniqueValues_${columnId}`));\n}\nfunction getFilteredRowModel() {\n    return (table)=>memo(()=>[\n                table.getPreFilteredRowModel(),\n                table.getState().columnFilters,\n                table.getState().globalFilter\n            ], (rowModel, columnFilters, globalFilter)=>{\n            if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n                for(let i = 0; i < rowModel.flatRows.length; i++){\n                    rowModel.flatRows[i].columnFilters = {};\n                    rowModel.flatRows[i].columnFiltersMeta = {};\n                }\n                return rowModel;\n            }\n            const resolvedColumnFilters = [];\n            const resolvedGlobalFilters = [];\n            (columnFilters != null ? columnFilters : []).forEach((d)=>{\n                var _filterFn$resolveFilt;\n                const column = table.getColumn(d.id);\n                if (!column) {\n                    return;\n                }\n                const filterFn = column.getFilterFn();\n                if (!filterFn) {\n                    if (true) {\n                        console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n                    }\n                    return;\n                }\n                resolvedColumnFilters.push({\n                    id: d.id,\n                    filterFn,\n                    resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n                });\n            });\n            const filterableIds = (columnFilters != null ? columnFilters : []).map((d)=>d.id);\n            const globalFilterFn = table.getGlobalFilterFn();\n            const globallyFilterableColumns = table.getAllLeafColumns().filter((column)=>column.getCanGlobalFilter());\n            if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n                filterableIds.push(\"__global__\");\n                globallyFilterableColumns.forEach((column)=>{\n                    var _globalFilterFn$resol;\n                    resolvedGlobalFilters.push({\n                        id: column.id,\n                        filterFn: globalFilterFn,\n                        resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n                    });\n                });\n            }\n            let currentColumnFilter;\n            let currentGlobalFilter;\n            // Flag the prefiltered row model with each filter state\n            for(let j = 0; j < rowModel.flatRows.length; j++){\n                const row = rowModel.flatRows[j];\n                row.columnFilters = {};\n                if (resolvedColumnFilters.length) {\n                    for(let i = 0; i < resolvedColumnFilters.length; i++){\n                        currentColumnFilter = resolvedColumnFilters[i];\n                        const id = currentColumnFilter.id;\n                        // Tag the row with the column filter state\n                        row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        });\n                    }\n                }\n                if (resolvedGlobalFilters.length) {\n                    for(let i = 0; i < resolvedGlobalFilters.length; i++){\n                        currentGlobalFilter = resolvedGlobalFilters[i];\n                        const id = currentGlobalFilter.id;\n                        // Tag the row with the first truthy global filter state\n                        if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, (filterMeta)=>{\n                            row.columnFiltersMeta[id] = filterMeta;\n                        })) {\n                            row.columnFilters.__global__ = true;\n                            break;\n                        }\n                    }\n                    if (row.columnFilters.__global__ !== true) {\n                        row.columnFilters.__global__ = false;\n                    }\n                }\n            }\n            const filterRowsImpl = (row)=>{\n                // Horizontally filter rows through each column\n                for(let i = 0; i < filterableIds.length; i++){\n                    if (row.columnFilters[filterableIds[i]] === false) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            // Filter final rows using all of the active filters\n            return filterRows(rowModel.rows, filterRowsImpl, table);\n        }, getMemoOptions(table.options, \"debugTable\", \"getFilteredRowModel\", ()=>table._autoResetPageIndex()));\n}\nfunction getGroupedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().grouping,\n                table.getPreGroupedRowModel()\n            ], (grouping, rowModel)=>{\n            if (!rowModel.rows.length || !grouping.length) {\n                return rowModel;\n            }\n            // Filter the grouping list down to columns that exist\n            const existingGrouping = grouping.filter((columnId)=>table.getColumn(columnId));\n            const groupedFlatRows = [];\n            const groupedRowsById = {};\n            // const onlyGroupedFlatRows: Row[] = [];\n            // const onlyGroupedRowsById: Record<RowId, Row> = {};\n            // const nonGroupedFlatRows: Row[] = [];\n            // const nonGroupedRowsById: Record<RowId, Row> = {};\n            // Recursively group the data\n            const groupUpRecursively = function(rows, depth, parentId) {\n                if (depth === void 0) {\n                    depth = 0;\n                }\n                // Grouping depth has been been met\n                // Stop grouping and simply rewrite thd depth and row relationships\n                if (depth >= existingGrouping.length) {\n                    return rows.map((row)=>{\n                        row.depth = depth;\n                        groupedFlatRows.push(row);\n                        groupedRowsById[row.id] = row;\n                        if (row.subRows) {\n                            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n                        }\n                        return row;\n                    });\n                }\n                const columnId = existingGrouping[depth];\n                // Group the rows together for this level\n                const rowGroupsMap = groupBy(rows, columnId);\n                // Peform aggregations for each group\n                const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index)=>{\n                    let [groupingValue, groupedRows] = _ref;\n                    let id = `${columnId}:${groupingValue}`;\n                    id = parentId ? `${parentId}>${id}` : id;\n                    // First, Recurse to group sub rows before aggregation\n                    const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n                    // Flatten the leaf rows of the rows in this group\n                    const leafRows = depth ? flattenBy(groupedRows, (row)=>row.subRows) : groupedRows;\n                    const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n                    Object.assign(row, {\n                        groupingColumnId: columnId,\n                        groupingValue,\n                        subRows,\n                        leafRows,\n                        getValue: (columnId)=>{\n                            // Don't aggregate columns that are in the grouping\n                            if (existingGrouping.includes(columnId)) {\n                                if (row._valuesCache.hasOwnProperty(columnId)) {\n                                    return row._valuesCache[columnId];\n                                }\n                                if (groupedRows[0]) {\n                                    var _groupedRows$0$getVal;\n                                    row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n                                }\n                                return row._valuesCache[columnId];\n                            }\n                            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n                                return row._groupingValuesCache[columnId];\n                            }\n                            // Aggregate the values\n                            const column = table.getColumn(columnId);\n                            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n                            if (aggregateFn) {\n                                row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n                                return row._groupingValuesCache[columnId];\n                            }\n                        }\n                    });\n                    subRows.forEach((subRow)=>{\n                        groupedFlatRows.push(subRow);\n                        groupedRowsById[subRow.id] = subRow;\n                    // if (subRow.getIsGrouped?.()) {\n                    //   onlyGroupedFlatRows.push(subRow);\n                    //   onlyGroupedRowsById[subRow.id] = subRow;\n                    // } else {\n                    //   nonGroupedFlatRows.push(subRow);\n                    //   nonGroupedRowsById[subRow.id] = subRow;\n                    // }\n                    });\n                    return row;\n                });\n                return aggregatedGroupedRows;\n            };\n            const groupedRows = groupUpRecursively(rowModel.rows, 0);\n            groupedRows.forEach((subRow)=>{\n                groupedFlatRows.push(subRow);\n                groupedRowsById[subRow.id] = subRow;\n            // if (subRow.getIsGrouped?.()) {\n            //   onlyGroupedFlatRows.push(subRow);\n            //   onlyGroupedRowsById[subRow.id] = subRow;\n            // } else {\n            //   nonGroupedFlatRows.push(subRow);\n            //   nonGroupedRowsById[subRow.id] = subRow;\n            // }\n            });\n            return {\n                rows: groupedRows,\n                flatRows: groupedFlatRows,\n                rowsById: groupedRowsById\n            };\n        }, getMemoOptions(table.options, \"debugTable\", \"getGroupedRowModel\", ()=>{\n            table._queue(()=>{\n                table._autoResetExpanded();\n                table._autoResetPageIndex();\n            });\n        }));\n}\nfunction groupBy(rows, columnId) {\n    const groupMap = new Map();\n    return rows.reduce((map, row)=>{\n        const resKey = `${row.getGroupingValue(columnId)}`;\n        const previous = map.get(resKey);\n        if (!previous) {\n            map.set(resKey, [\n                row\n            ]);\n        } else {\n            previous.push(row);\n        }\n        return map;\n    }, groupMap);\n}\nfunction getPaginationRowModel(opts) {\n    return (table)=>memo(()=>[\n                table.getState().pagination,\n                table.getPrePaginationRowModel(),\n                table.options.paginateExpandedRows ? undefined : table.getState().expanded\n            ], (pagination, rowModel)=>{\n            if (!rowModel.rows.length) {\n                return rowModel;\n            }\n            const { pageSize, pageIndex } = pagination;\n            let { rows, flatRows, rowsById } = rowModel;\n            const pageStart = pageSize * pageIndex;\n            const pageEnd = pageStart + pageSize;\n            rows = rows.slice(pageStart, pageEnd);\n            let paginatedRowModel;\n            if (!table.options.paginateExpandedRows) {\n                paginatedRowModel = expandRows({\n                    rows,\n                    flatRows,\n                    rowsById\n                });\n            } else {\n                paginatedRowModel = {\n                    rows,\n                    flatRows,\n                    rowsById\n                };\n            }\n            paginatedRowModel.flatRows = [];\n            const handleRow = (row)=>{\n                paginatedRowModel.flatRows.push(row);\n                if (row.subRows.length) {\n                    row.subRows.forEach(handleRow);\n                }\n            };\n            paginatedRowModel.rows.forEach(handleRow);\n            return paginatedRowModel;\n        }, getMemoOptions(table.options, \"debugTable\", \"getPaginationRowModel\"));\n}\nfunction getSortedRowModel() {\n    return (table)=>memo(()=>[\n                table.getState().sorting,\n                table.getPreSortedRowModel()\n            ], (sorting, rowModel)=>{\n            if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n                return rowModel;\n            }\n            const sortingState = table.getState().sorting;\n            const sortedFlatRows = [];\n            // Filter out sortings that correspond to non existing columns\n            const availableSorting = sortingState.filter((sort)=>{\n                var _table$getColumn;\n                return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n            });\n            const columnInfoById = {};\n            availableSorting.forEach((sortEntry)=>{\n                const column = table.getColumn(sortEntry.id);\n                if (!column) return;\n                columnInfoById[sortEntry.id] = {\n                    sortUndefined: column.columnDef.sortUndefined,\n                    invertSorting: column.columnDef.invertSorting,\n                    sortingFn: column.getSortingFn()\n                };\n            });\n            const sortData = (rows)=>{\n                // This will also perform a stable sorting using the row index\n                // if needed.\n                const sortedData = rows.map((row)=>({\n                        ...row\n                    }));\n                sortedData.sort((rowA, rowB)=>{\n                    for(let i = 0; i < availableSorting.length; i += 1){\n                        var _sortEntry$desc;\n                        const sortEntry = availableSorting[i];\n                        const columnInfo = columnInfoById[sortEntry.id];\n                        const sortUndefined = columnInfo.sortUndefined;\n                        const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n                        let sortInt = 0;\n                        // All sorting ints should always return in ascending order\n                        if (sortUndefined) {\n                            const aValue = rowA.getValue(sortEntry.id);\n                            const bValue = rowB.getValue(sortEntry.id);\n                            const aUndefined = aValue === undefined;\n                            const bUndefined = bValue === undefined;\n                            if (aUndefined || bUndefined) {\n                                if (sortUndefined === \"first\") return aUndefined ? -1 : 1;\n                                if (sortUndefined === \"last\") return aUndefined ? 1 : -1;\n                                sortInt = aUndefined && bUndefined ? 0 : aUndefined ? sortUndefined : -sortUndefined;\n                            }\n                        }\n                        if (sortInt === 0) {\n                            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n                        }\n                        // If sorting is non-zero, take care of desc and inversion\n                        if (sortInt !== 0) {\n                            if (isDesc) {\n                                sortInt *= -1;\n                            }\n                            if (columnInfo.invertSorting) {\n                                sortInt *= -1;\n                            }\n                            return sortInt;\n                        }\n                    }\n                    return rowA.index - rowB.index;\n                });\n                // If there are sub-rows, sort them\n                sortedData.forEach((row)=>{\n                    var _row$subRows;\n                    sortedFlatRows.push(row);\n                    if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n                        row.subRows = sortData(row.subRows);\n                    }\n                });\n                return sortedData;\n            };\n            return {\n                rows: sortData(rowModel.rows),\n                flatRows: sortedFlatRows,\n                rowsById: rowModel.rowsById\n            };\n        }, getMemoOptions(table.options, \"debugTable\", \"getSortedRowModel\", ()=>table._autoResetPageIndex()));\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3RhYmxlLWNvcmUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0dBU0csR0FDSCxrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZCxhQUFhO0FBQ2IsVUFBVTtBQUNWLHFCQUFxQjtBQUNyQixVQUFVO0FBQ1YsUUFBUTtBQUNSLGlDQUFpQztBQUNqQyxhQUFhO0FBQ2IsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixxQkFBcUI7QUFDckIsVUFBVTtBQUNWLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUVKLG9EQUFvRDtBQUNwRCwrQ0FBK0M7QUFFL0MsOENBQThDO0FBRTlDLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsS0FBSztBQUVMLHdDQUF3QztBQUN4QyxtQ0FBbUM7QUFDbkMsS0FBSztBQUVMLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMsS0FBSztBQUVMLFNBQVNBO0lBQ1AsT0FBTztRQUNMQyxVQUFVLENBQUNBLFVBQVVDO1lBQ25CLE9BQU8sT0FBT0QsYUFBYSxhQUFhO2dCQUN0QyxHQUFHQyxNQUFNO2dCQUNUQyxZQUFZRjtZQUNkLElBQUk7Z0JBQ0YsR0FBR0MsTUFBTTtnQkFDVEUsYUFBYUg7WUFDZjtRQUNGO1FBQ0FJLFNBQVNILENBQUFBLFNBQVVBO1FBQ25CSSxPQUFPSixDQUFBQSxTQUFVQTtJQUNuQjtBQUNGO0FBRUEsd0JBQXdCO0FBRXhCLHFEQUFxRDtBQUVyRCxHQUFHO0FBRUgsU0FBU0ssaUJBQWlCQyxPQUFPLEVBQUVDLEtBQUs7SUFDdEMsT0FBTyxPQUFPRCxZQUFZLGFBQWFBLFFBQVFDLFNB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LFdBQVd2NUIsT0FBTyxDQUFDNEMsQ0FBQUE7b0JBQ2pCLElBQUlnVDtvQkFDSnFqQixlQUFlLzRCLElBQUksQ0FBQzBDO29CQUNwQixJQUFJLENBQUNnVCxlQUFlaFQsSUFBSStILE9BQU8sS0FBSyxRQUFRaUwsYUFBYXhWLE1BQU0sRUFBRTt3QkFDL0R3QyxJQUFJK0gsT0FBTyxHQUFHMnVCLFNBQVMxMkIsSUFBSStILE9BQU87b0JBQ3BDO2dCQUNGO2dCQUNBLE9BQU80dUI7WUFDVDtZQUNBLE9BQU87Z0JBQ0x2UixNQUFNc1IsU0FBU3pOLFNBQVM3RCxJQUFJO2dCQUM1QnpZLFVBQVUwcEI7Z0JBQ1ZuVixVQUFVK0gsU0FBUy9ILFFBQVE7WUFDN0I7UUFDRixHQUFHMWhCLGVBQWVPLE1BQU1PLE9BQU8sRUFBRSxjQUFjLHFCQUFxQixJQUFNUCxNQUFNK2lCLG1CQUFtQjtBQUNyRztBQUVvMEIsQ0FDcDBCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hdGVyaW8tbXVpLXJlYWN0LW5leHRqcy1hZG1pbi10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdGFibGUtY29yZS9idWlsZC9saWIvaW5kZXgubWpzPzU1NmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gICAqIHRhYmxlLWNvcmVcbiAgICpcbiAgICogQ29weXJpZ2h0IChjKSBUYW5TdGFja1xuICAgKlxuICAgKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAgICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICAgKlxuICAgKiBAbGljZW5zZSBNSVRcbiAgICovXG4vLyB0eXBlIFBlcnNvbiA9IHtcbi8vICAgZmlyc3ROYW1lOiBzdHJpbmdcbi8vICAgbGFzdE5hbWU6IHN0cmluZ1xuLy8gICBhZ2U6IG51bWJlclxuLy8gICB2aXNpdHM6IG51bWJlclxuLy8gICBzdGF0dXM6IHN0cmluZ1xuLy8gICBwcm9ncmVzczogbnVtYmVyXG4vLyAgIGNyZWF0ZWRBdDogRGF0ZVxuLy8gICBuZXN0ZWQ6IHtcbi8vICAgICBmb286IFtcbi8vICAgICAgIHtcbi8vICAgICAgICAgYmFyOiAnYmFyJ1xuLy8gICAgICAgfVxuLy8gICAgIF1cbi8vICAgICBiYXI6IHsgc3ViQmFyOiBib29sZWFuIH1bXVxuLy8gICAgIGJhejoge1xuLy8gICAgICAgZm9vOiAnZm9vJ1xuLy8gICAgICAgYmFyOiB7XG4vLyAgICAgICAgIGJhejogJ2Jheidcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cblxuLy8gY29uc3QgdGVzdDogRGVlcEtleXM8UGVyc29uPiA9ICduZXN0ZWQuZm9vLjAuYmFyJ1xuLy8gY29uc3QgdGVzdDI6IERlZXBLZXlzPFBlcnNvbj4gPSAnbmVzdGVkLmJhcidcblxuLy8gY29uc3QgaGVscGVyID0gY3JlYXRlQ29sdW1uSGVscGVyPFBlcnNvbj4oKVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5mb28nLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuZm9vLjAuYmFyJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmJhcicsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuXG5mdW5jdGlvbiBjcmVhdGVDb2x1bW5IZWxwZXIoKSB7XG4gIHJldHVybiB7XG4gICAgYWNjZXNzb3I6IChhY2Nlc3NvciwgY29sdW1uKSA9PiB7XG4gICAgICByZXR1cm4gdHlwZW9mIGFjY2Vzc29yID09PSAnZnVuY3Rpb24nID8ge1xuICAgICAgICAuLi5jb2x1bW4sXG4gICAgICAgIGFjY2Vzc29yRm46IGFjY2Vzc29yXG4gICAgICB9IDoge1xuICAgICAgICAuLi5jb2x1bW4sXG4gICAgICAgIGFjY2Vzc29yS2V5OiBhY2Nlc3NvclxuICAgICAgfTtcbiAgICB9LFxuICAgIGRpc3BsYXk6IGNvbHVtbiA9PiBjb2x1bW4sXG4gICAgZ3JvdXA6IGNvbHVtbiA9PiBjb2x1bW5cbiAgfTtcbn1cblxuLy8gSXMgdGhpcyB0eXBlIGEgdHVwbGU/XG5cbi8vIElmIHRoaXMgdHlwZSBpcyBhIHR1cGxlLCB3aGF0IGluZGljZXMgYXJlIGFsbG93ZWQ/XG5cbi8vL1xuXG5mdW5jdGlvbiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIGlucHV0KSB7XG4gIHJldHVybiB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIoaW5wdXQpIDogdXBkYXRlcjtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vXG59XG5mdW5jdGlvbiBtYWtlU3RhdGVVcGRhdGVyKGtleSwgaW5zdGFuY2UpIHtcbiAgcmV0dXJuIHVwZGF0ZXIgPT4ge1xuICAgIGluc3RhbmNlLnNldFN0YXRlKG9sZCA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vbGQsXG4gICAgICAgIFtrZXldOiBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZFtrZXldKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZCkge1xuICByZXR1cm4gZCBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xufVxuZnVuY3Rpb24gaXNOdW1iZXJBcnJheShkKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGQpICYmIGQuZXZlcnkodmFsID0+IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5CeShhcnIsIGdldENoaWxkcmVuKSB7XG4gIGNvbnN0IGZsYXQgPSBbXTtcbiAgY29uc3QgcmVjdXJzZSA9IHN1YkFyciA9PiB7XG4gICAgc3ViQXJyLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBmbGF0LnB1c2goaXRlbSk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKGl0ZW0pO1xuICAgICAgaWYgKGNoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJlY3Vyc2UoY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZWN1cnNlKGFycik7XG4gIHJldHVybiBmbGF0O1xufVxuZnVuY3Rpb24gbWVtbyhnZXREZXBzLCBmbiwgb3B0cykge1xuICBsZXQgZGVwcyA9IFtdO1xuICBsZXQgcmVzdWx0O1xuICByZXR1cm4gZGVwQXJncyA9PiB7XG4gICAgbGV0IGRlcFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIGRlcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG5ld0RlcHMgPSBnZXREZXBzKGRlcEFyZ3MpO1xuICAgIGNvbnN0IGRlcHNDaGFuZ2VkID0gbmV3RGVwcy5sZW5ndGggIT09IGRlcHMubGVuZ3RoIHx8IG5ld0RlcHMuc29tZSgoZGVwLCBpbmRleCkgPT4gZGVwc1tpbmRleF0gIT09IGRlcCk7XG4gICAgaWYgKCFkZXBzQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVwcyA9IG5ld0RlcHM7XG4gICAgbGV0IHJlc3VsdFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmIG9wdHMuZGVidWcpIHJlc3VsdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJlc3VsdCA9IGZuKC4uLm5ld0RlcHMpO1xuICAgIG9wdHMgPT0gbnVsbCB8fCBvcHRzLm9uQ2hhbmdlID09IG51bGwgfHwgb3B0cy5vbkNoYW5nZShyZXN1bHQpO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSB7XG4gICAgICBpZiAob3B0cyAhPSBudWxsICYmIG9wdHMuZGVidWcoKSkge1xuICAgICAgICBjb25zdCBkZXBFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIGRlcFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgICAgY29uc3QgcmVzdWx0RW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSByZXN1bHRUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdEZwc1BlcmNlbnRhZ2UgPSByZXN1bHRFbmRUaW1lIC8gMTY7XG4gICAgICAgIGNvbnN0IHBhZCA9IChzdHIsIG51bSkgPT4ge1xuICAgICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbnVtKSB7XG4gICAgICAgICAgICBzdHIgPSAnICcgKyBzdHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUuaW5mbyhgJWPij7EgJHtwYWQocmVzdWx0RW5kVGltZSwgNSl9IC8ke3BhZChkZXBFbmRUaW1lLCA1KX0gbXNgLCBgXG4gICAgICAgICAgICBmb250LXNpemU6IC42cmVtO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBjb2xvcjogaHNsKCR7TWF0aC5tYXgoMCwgTWF0aC5taW4oMTIwIC0gMTIwICogcmVzdWx0RnBzUGVyY2VudGFnZSwgMTIwKSl9ZGVnIDEwMCUgMzElKTtgLCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRNZW1vT3B0aW9ucyh0YWJsZU9wdGlvbnMsIGRlYnVnTGV2ZWwsIGtleSwgb25DaGFuZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWJ1ZzogKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZU9wdGlvbnMkZGVidWdBbDtcbiAgICAgIHJldHVybiAoX3RhYmxlT3B0aW9ucyRkZWJ1Z0FsID0gdGFibGVPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZU9wdGlvbnMuZGVidWdBbGwpICE9IG51bGwgPyBfdGFibGVPcHRpb25zJGRlYnVnQWwgOiB0YWJsZU9wdGlvbnNbZGVidWdMZXZlbF07XG4gICAgfSxcbiAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGtleSxcbiAgICBvbkNoYW5nZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDZWxsKHRhYmxlLCByb3csIGNvbHVtbiwgY29sdW1uSWQpIHtcbiAgY29uc3QgZ2V0UmVuZGVyVmFsdWUgPSAoKSA9PiB7XG4gICAgdmFyIF9jZWxsJGdldFZhbHVlO1xuICAgIHJldHVybiAoX2NlbGwkZ2V0VmFsdWUgPSBjZWxsLmdldFZhbHVlKCkpICE9IG51bGwgPyBfY2VsbCRnZXRWYWx1ZSA6IHRhYmxlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZTtcbiAgfTtcbiAgY29uc3QgY2VsbCA9IHtcbiAgICBpZDogYCR7cm93LmlkfV8ke2NvbHVtbi5pZH1gLFxuICAgIHJvdyxcbiAgICBjb2x1bW4sXG4gICAgZ2V0VmFsdWU6ICgpID0+IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCksXG4gICAgcmVuZGVyVmFsdWU6IGdldFJlbmRlclZhbHVlLFxuICAgIGdldENvbnRleHQ6IG1lbW8oKCkgPT4gW3RhYmxlLCBjb2x1bW4sIHJvdywgY2VsbF0sICh0YWJsZSwgY29sdW1uLCByb3csIGNlbGwpID0+ICh7XG4gICAgICB0YWJsZSxcbiAgICAgIGNvbHVtbixcbiAgICAgIHJvdyxcbiAgICAgIGNlbGw6IGNlbGwsXG4gICAgICBnZXRWYWx1ZTogY2VsbC5nZXRWYWx1ZSxcbiAgICAgIHJlbmRlclZhbHVlOiBjZWxsLnJlbmRlclZhbHVlXG4gICAgfSksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NlbGxzJywgJ2NlbGwuZ2V0Q29udGV4dCcpKVxuICB9O1xuICB0YWJsZS5fZmVhdHVyZXMuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNlbGwgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUNlbGwoY2VsbCwgY29sdW1uLCByb3csIHRhYmxlKTtcbiAgfSwge30pO1xuICByZXR1cm4gY2VsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29sdW1uKHRhYmxlLCBjb2x1bW5EZWYsIGRlcHRoLCBwYXJlbnQpIHtcbiAgdmFyIF9yZWYsIF9yZXNvbHZlZENvbHVtbkRlZiRpZDtcbiAgY29uc3QgZGVmYXVsdENvbHVtbiA9IHRhYmxlLl9nZXREZWZhdWx0Q29sdW1uRGVmKCk7XG4gIGNvbnN0IHJlc29sdmVkQ29sdW1uRGVmID0ge1xuICAgIC4uLmRlZmF1bHRDb2x1bW4sXG4gICAgLi4uY29sdW1uRGVmXG4gIH07XG4gIGNvbnN0IGFjY2Vzc29yS2V5ID0gcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXk7XG4gIGxldCBpZCA9IChfcmVmID0gKF9yZXNvbHZlZENvbHVtbkRlZiRpZCA9IHJlc29sdmVkQ29sdW1uRGVmLmlkKSAhPSBudWxsID8gX3Jlc29sdmVkQ29sdW1uRGVmJGlkIDogYWNjZXNzb3JLZXkgPyBhY2Nlc3NvcktleS5yZXBsYWNlKCcuJywgJ18nKSA6IHVuZGVmaW5lZCkgIT0gbnVsbCA/IF9yZWYgOiB0eXBlb2YgcmVzb2x2ZWRDb2x1bW5EZWYuaGVhZGVyID09PSAnc3RyaW5nJyA/IHJlc29sdmVkQ29sdW1uRGVmLmhlYWRlciA6IHVuZGVmaW5lZDtcbiAgbGV0IGFjY2Vzc29yRm47XG4gIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuKSB7XG4gICAgYWNjZXNzb3JGbiA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm47XG4gIH0gZWxzZSBpZiAoYWNjZXNzb3JLZXkpIHtcbiAgICAvLyBTdXBwb3J0IGRlZXAgYWNjZXNzb3Iga2V5c1xuICAgIGlmIChhY2Nlc3NvcktleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICBhY2Nlc3NvckZuID0gb3JpZ2luYWxSb3cgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gb3JpZ2luYWxSb3c7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGFjY2Vzc29yS2V5LnNwbGl0KCcuJykpIHtcbiAgICAgICAgICB2YXIgX3Jlc3VsdDtcbiAgICAgICAgICByZXN1bHQgPSAoX3Jlc3VsdCA9IHJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHRba2V5XTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiByZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBcIiR7a2V5fVwiIGluIGRlZXBseSBuZXN0ZWQga2V5IFwiJHthY2Nlc3NvcktleX1cIiByZXR1cm5lZCB1bmRlZmluZWQuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2Nlc3NvckZuID0gb3JpZ2luYWxSb3cgPT4gb3JpZ2luYWxSb3dbcmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXldO1xuICAgIH1cbiAgfVxuICBpZiAoIWlkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuID8gYENvbHVtbnMgcmVxdWlyZSBhbiBpZCB3aGVuIHVzaW5nIGFuIGFjY2Vzc29yRm5gIDogYENvbHVtbnMgcmVxdWlyZSBhbiBpZCB3aGVuIHVzaW5nIGEgbm9uLXN0cmluZyBoZWFkZXJgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgbGV0IGNvbHVtbiA9IHtcbiAgICBpZDogYCR7U3RyaW5nKGlkKX1gLFxuICAgIGFjY2Vzc29yRm4sXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgZGVwdGgsXG4gICAgY29sdW1uRGVmOiByZXNvbHZlZENvbHVtbkRlZixcbiAgICBjb2x1bW5zOiBbXSxcbiAgICBnZXRGbGF0Q29sdW1uczogbWVtbygoKSA9PiBbdHJ1ZV0sICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnM7XG4gICAgICByZXR1cm4gW2NvbHVtbiwgLi4uKChfY29sdW1uJGNvbHVtbnMgPSBjb2x1bW4uY29sdW1ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jb2x1bW4kY29sdW1ucy5mbGF0TWFwKGQgPT4gZC5nZXRGbGF0Q29sdW1ucygpKSldO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnY29sdW1uLmdldEZsYXRDb2x1bW5zJykpLFxuICAgIGdldExlYWZDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4oKV0sIG9yZGVyQ29sdW1ucyA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5zMjtcbiAgICAgIGlmICgoX2NvbHVtbiRjb2x1bW5zMiA9IGNvbHVtbi5jb2x1bW5zKSAhPSBudWxsICYmIF9jb2x1bW4kY29sdW1uczIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBsZWFmQ29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zLmZsYXRNYXAoY29sdW1uID0+IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpKTtcbiAgICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2NvbHVtbl07XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdjb2x1bW4uZ2V0TGVhZkNvbHVtbnMnKSlcbiAgfTtcbiAgZm9yIChjb25zdCBmZWF0dXJlIG9mIHRhYmxlLl9mZWF0dXJlcykge1xuICAgIGZlYXR1cmUuY3JlYXRlQ29sdW1uID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVDb2x1bW4oY29sdW1uLCB0YWJsZSk7XG4gIH1cblxuICAvLyBZZXMsIHdlIGhhdmUgdG8gY29udmVydCB0YWJsZSB0byB1bmtub3duLCBiZWNhdXNlIHdlIGtub3cgbW9yZSB0aGFuIHRoZSBjb21waWxlciBoZXJlLlxuICByZXR1cm4gY29sdW1uO1xufVxuXG5jb25zdCBkZWJ1ZyA9ICdkZWJ1Z0hlYWRlcnMnO1xuLy9cblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGlkO1xuICBjb25zdCBpZCA9IChfb3B0aW9ucyRpZCA9IG9wdGlvbnMuaWQpICE9IG51bGwgPyBfb3B0aW9ucyRpZCA6IGNvbHVtbi5pZDtcbiAgbGV0IGhlYWRlciA9IHtcbiAgICBpZCxcbiAgICBjb2x1bW4sXG4gICAgaW5kZXg6IG9wdGlvbnMuaW5kZXgsXG4gICAgaXNQbGFjZWhvbGRlcjogISFvcHRpb25zLmlzUGxhY2Vob2xkZXIsXG4gICAgcGxhY2Vob2xkZXJJZDogb3B0aW9ucy5wbGFjZWhvbGRlcklkLFxuICAgIGRlcHRoOiBvcHRpb25zLmRlcHRoLFxuICAgIHN1YkhlYWRlcnM6IFtdLFxuICAgIGNvbFNwYW46IDAsXG4gICAgcm93U3BhbjogMCxcbiAgICBoZWFkZXJHcm91cDogbnVsbCxcbiAgICBnZXRMZWFmSGVhZGVyczogKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkhlYWRlcnMgPSBbXTtcbiAgICAgIGNvbnN0IHJlY3Vyc2VIZWFkZXIgPSBoID0+IHtcbiAgICAgICAgaWYgKGguc3ViSGVhZGVycyAmJiBoLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaC5zdWJIZWFkZXJzLm1hcChyZWN1cnNlSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZWFmSGVhZGVycy5wdXNoKGgpO1xuICAgICAgfTtcbiAgICAgIHJlY3Vyc2VIZWFkZXIoaGVhZGVyKTtcbiAgICAgIHJldHVybiBsZWFmSGVhZGVycztcbiAgICB9LFxuICAgIGdldENvbnRleHQ6ICgpID0+ICh7XG4gICAgICB0YWJsZSxcbiAgICAgIGhlYWRlcjogaGVhZGVyLFxuICAgICAgY29sdW1uXG4gICAgfSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgZmVhdHVyZS5jcmVhdGVIZWFkZXIgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZUhlYWRlcihoZWFkZXIsIHRhYmxlKTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXI7XG59XG5jb25zdCBIZWFkZXJzID0ge1xuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIC8vIEhlYWRlciBHcm91cHNcblxuICAgIHRhYmxlLmdldEhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX2xlZnQkbWFwJGZpbHRlciwgX3JpZ2h0JG1hcCRmaWx0ZXI7XG4gICAgICBjb25zdCBsZWZ0Q29sdW1ucyA9IChfbGVmdCRtYXAkZmlsdGVyID0gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX2xlZnQkbWFwJGZpbHRlciA6IFtdO1xuICAgICAgY29uc3QgcmlnaHRDb2x1bW5zID0gKF9yaWdodCRtYXAkZmlsdGVyID0gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfcmlnaHQkbWFwJGZpbHRlciA6IFtdO1xuICAgICAgY29uc3QgY2VudGVyQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIShsZWZ0ICE9IG51bGwgJiYgbGVmdC5pbmNsdWRlcyhjb2x1bW4uaWQpKSAmJiAhKHJpZ2h0ICE9IG51bGwgJiYgcmlnaHQuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xuICAgICAgY29uc3QgaGVhZGVyR3JvdXBzID0gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgWy4uLmxlZnRDb2x1bW5zLCAuLi5jZW50ZXJDb2x1bW5zLCAuLi5yaWdodENvbHVtbnNdLCB0YWJsZSk7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0SGVhZGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBsZWFmQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2x1bW4gPT4gIShsZWZ0ICE9IG51bGwgJiYgbGVmdC5pbmNsdWRlcyhjb2x1bW4uaWQpKSAmJiAhKHJpZ2h0ICE9IG51bGwgJiYgcmlnaHQuaW5jbHVkZXMoY29sdW1uLmlkKSkpO1xuICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCB0YWJsZSwgJ2NlbnRlcicpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVySGVhZGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldExlZnRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgbGVmdCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JG1hcCRmaWx0ZXIyO1xuICAgICAgY29uc3Qgb3JkZXJlZExlYWZDb2x1bW5zID0gKF9sZWZ0JG1hcCRmaWx0ZXIyID0gbGVmdCA9PSBudWxsID8gdm9pZCAwIDogbGVmdC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX2xlZnQkbWFwJGZpbHRlcjIgOiBbXTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBvcmRlcmVkTGVhZkNvbHVtbnMsIHRhYmxlLCAnbGVmdCcpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdEhlYWRlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKSwgdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgcmlnaHQpID0+IHtcbiAgICAgIHZhciBfcmlnaHQkbWFwJGZpbHRlcjI7XG4gICAgICBjb25zdCBvcmRlcmVkTGVhZkNvbHVtbnMgPSAoX3JpZ2h0JG1hcCRmaWx0ZXIyID0gcmlnaHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJpZ2h0Lm1hcChjb2x1bW5JZCA9PiBsZWFmQ29sdW1ucy5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbikpICE9IG51bGwgPyBfcmlnaHQkbWFwJGZpbHRlcjIgOiBbXTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBvcmRlcmVkTGVhZkNvbHVtbnMsIHRhYmxlLCAncmlnaHQnKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldFJpZ2h0SGVhZGVyR3JvdXBzJykpO1xuXG4gICAgLy8gRm9vdGVyIEdyb3Vwc1xuXG4gICAgdGFibGUuZ2V0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5oZWFkZXJHcm91cHNdLnJldmVyc2UoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEZvb3Rlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRMZWZ0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0Rm9vdGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldENlbnRlckZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJGb290ZXJHcm91cHMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEZvb3Rlckdyb3VwcycpKTtcblxuICAgIC8vIEZsYXQgSGVhZGVyc1xuXG4gICAgdGFibGUuZ2V0RmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gaGVhZGVyR3JvdXBzLm1hcChoZWFkZXJHcm91cCA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXJHcm91cC5oZWFkZXJzO1xuICAgICAgfSkuZmxhdCgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0RmxhdEhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0TGVmdEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldExlZnRGbGF0SGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldENlbnRlckZsYXRIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0RmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpXSwgbGVmdCA9PiB7XG4gICAgICByZXR1cm4gbGVmdC5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldFJpZ2h0RmxhdEhlYWRlcnMnKSk7XG5cbiAgICAvLyBMZWFmIEhlYWRlcnNcblxuICAgIHRhYmxlLmdldENlbnRlckxlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Q2VudGVyRmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVycztcbiAgICAgICAgcmV0dXJuICEoKF9oZWFkZXIkc3ViSGVhZGVycyA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVycy5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJMZWFmSGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRMZWZ0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRMZWZ0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVyczI7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMyID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMi5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0TGVhZkhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFJpZ2h0RmxhdEhlYWRlcnMoKV0sIGZsYXRIZWFkZXJzID0+IHtcbiAgICAgIHJldHVybiBmbGF0SGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IHtcbiAgICAgICAgdmFyIF9oZWFkZXIkc3ViSGVhZGVyczM7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMzID0gaGVhZGVyLnN1YkhlYWRlcnMpICE9IG51bGwgJiYgX2hlYWRlciRzdWJIZWFkZXJzMy5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodExlYWZIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldExlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpLCB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKSwgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIChsZWZ0LCBjZW50ZXIsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX2xlZnQkMCRoZWFkZXJzLCBfbGVmdCQsIF9jZW50ZXIkMCRoZWFkZXJzLCBfY2VudGVyJCwgX3JpZ2h0JDAkaGVhZGVycywgX3JpZ2h0JDtcbiAgICAgIHJldHVybiBbLi4uKChfbGVmdCQwJGhlYWRlcnMgPSAoX2xlZnQkID0gbGVmdFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sZWZ0JC5oZWFkZXJzKSAhPSBudWxsID8gX2xlZnQkMCRoZWFkZXJzIDogW10pLCAuLi4oKF9jZW50ZXIkMCRoZWFkZXJzID0gKF9jZW50ZXIkID0gY2VudGVyWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2NlbnRlciQuaGVhZGVycykgIT0gbnVsbCA/IF9jZW50ZXIkMCRoZWFkZXJzIDogW10pLCAuLi4oKF9yaWdodCQwJGhlYWRlcnMgPSAoX3JpZ2h0JCA9IHJpZ2h0WzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3JpZ2h0JC5oZWFkZXJzKSAhPSBudWxsID8gX3JpZ2h0JDAkaGVhZGVycyA6IFtdKV0ubWFwKGhlYWRlciA9PiB7XG4gICAgICAgIHJldHVybiBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKTtcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldExlYWZIZWFkZXJzJykpO1xuICB9XG59O1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgY29sdW1uc1RvR3JvdXAsIHRhYmxlLCBoZWFkZXJGYW1pbHkpIHtcbiAgdmFyIF9oZWFkZXJHcm91cHMkMCRoZWFkZSwgX2hlYWRlckdyb3VwcyQ7XG4gIC8vIEZpbmQgdGhlIG1heCBkZXB0aCBvZiB0aGUgY29sdW1uczpcbiAgLy8gYnVpbGQgdGhlIGxlYWYgY29sdW1uIHJvd1xuICAvLyBidWlsZCBlYWNoIGJ1ZmZlciByb3cgZ29pbmcgdXBcbiAgLy8gICAgcGxhY2Vob2xkZXIgZm9yIG5vbi1leGlzdGVudCBsZXZlbFxuICAvLyAgICByZWFsIGNvbHVtbiBmb3IgZXhpc3RpbmcgbGV2ZWxcblxuICBsZXQgbWF4RGVwdGggPSAwO1xuICBjb25zdCBmaW5kTWF4RGVwdGggPSBmdW5jdGlvbiAoY29sdW1ucywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAxO1xuICAgIH1cbiAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBkZXB0aCk7XG4gICAgY29sdW1ucy5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5nZXRJc1Zpc2libGUoKSkuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1ucztcbiAgICAgIGlmICgoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpICE9IG51bGwgJiYgX2NvbHVtbiRjb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICBmaW5kTWF4RGVwdGgoY29sdW1uLmNvbHVtbnMsIGRlcHRoICsgMSk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH07XG4gIGZpbmRNYXhEZXB0aChhbGxDb2x1bW5zKTtcbiAgbGV0IGhlYWRlckdyb3VwcyA9IFtdO1xuICBjb25zdCBjcmVhdGVIZWFkZXJHcm91cCA9IChoZWFkZXJzVG9Hcm91cCwgZGVwdGgpID0+IHtcbiAgICAvLyBUaGUgaGVhZGVyIGdyb3VwIHdlIGFyZSBjcmVhdGluZ1xuICAgIGNvbnN0IGhlYWRlckdyb3VwID0ge1xuICAgICAgZGVwdGgsXG4gICAgICBpZDogW2hlYWRlckZhbWlseSwgYCR7ZGVwdGh9YF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgIGhlYWRlcnM6IFtdXG4gICAgfTtcblxuICAgIC8vIFRoZSBwYXJlbnQgY29sdW1ucyB3ZSdyZSBnb2luZyB0byBzY2FuIG5leHRcbiAgICBjb25zdCBwZW5kaW5nUGFyZW50SGVhZGVycyA9IFtdO1xuXG4gICAgLy8gU2NhbiBlYWNoIGNvbHVtbiBmb3IgcGFyZW50c1xuICAgIGhlYWRlcnNUb0dyb3VwLmZvckVhY2goaGVhZGVyVG9Hcm91cCA9PiB7XG4gICAgICAvLyBXaGF0IGlzIHRoZSBsYXRlc3QgKGxhc3QpIHBhcmVudCBjb2x1bW4/XG5cbiAgICAgIGNvbnN0IGxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIgPSBbLi4ucGVuZGluZ1BhcmVudEhlYWRlcnNdLnJldmVyc2UoKVswXTtcbiAgICAgIGNvbnN0IGlzTGVhZkhlYWRlciA9IGhlYWRlclRvR3JvdXAuY29sdW1uLmRlcHRoID09PSBoZWFkZXJHcm91cC5kZXB0aDtcbiAgICAgIGxldCBjb2x1bW47XG4gICAgICBsZXQgaXNQbGFjZWhvbGRlciA9IGZhbHNlO1xuICAgICAgaWYgKGlzTGVhZkhlYWRlciAmJiBoZWFkZXJUb0dyb3VwLmNvbHVtbi5wYXJlbnQpIHtcbiAgICAgICAgLy8gVGhlIHBhcmVudCBoZWFkZXIgaXMgbmV3XG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uLnBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgaGVhZGVyIGlzIHJlcGVhdGVkXG4gICAgICAgIGNvbHVtbiA9IGhlYWRlclRvR3JvdXAuY29sdW1uO1xuICAgICAgICBpc1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyICYmIChsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyID09IG51bGwgPyB2b2lkIDAgOiBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLmNvbHVtbikgPT09IGNvbHVtbikge1xuICAgICAgICAvLyBUaGlzIGNvbHVtbiBpcyByZXBlYXRlZC4gQWRkIGl0IGFzIGEgc3ViIGhlYWRlciB0byB0aGUgbmV4dCBiYXRjaFxuICAgICAgICBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgaGVhZGVyLiBMZXQncyBjcmVhdGUgaXRcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcbiAgICAgICAgICBpZDogW2hlYWRlckZhbWlseSwgZGVwdGgsIGNvbHVtbi5pZCwgaGVhZGVyVG9Hcm91cCA9PSBudWxsID8gdm9pZCAwIDogaGVhZGVyVG9Hcm91cC5pZF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ18nKSxcbiAgICAgICAgICBpc1BsYWNlaG9sZGVyLFxuICAgICAgICAgIHBsYWNlaG9sZGVySWQ6IGlzUGxhY2Vob2xkZXIgPyBgJHtwZW5kaW5nUGFyZW50SGVhZGVycy5maWx0ZXIoZCA9PiBkLmNvbHVtbiA9PT0gY29sdW1uKS5sZW5ndGh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBpbmRleDogcGVuZGluZ1BhcmVudEhlYWRlcnMubGVuZ3RoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFkZCB0aGUgaGVhZGVyVG9Hcm91cCBhcyBhIHN1YkhlYWRlciBvZiB0aGUgbmV3IGhlYWRlclxuICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5wdXNoKGhlYWRlclRvR3JvdXApO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyBoZWFkZXIgdG8gdGhlIHBlbmRpbmdQYXJlbnRIZWFkZXJzIHRvIGdldCBncm91cGVkXG4gICAgICAgIC8vIGluIHRoZSBuZXh0IGJhdGNoXG4gICAgICAgIHBlbmRpbmdQYXJlbnRIZWFkZXJzLnB1c2goaGVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlckdyb3VwLmhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgIGhlYWRlclRvR3JvdXAuaGVhZGVyR3JvdXAgPSBoZWFkZXJHcm91cDtcbiAgICB9KTtcbiAgICBoZWFkZXJHcm91cHMucHVzaChoZWFkZXJHcm91cCk7XG4gICAgaWYgKGRlcHRoID4gMCkge1xuICAgICAgY3JlYXRlSGVhZGVyR3JvdXAocGVuZGluZ1BhcmVudEhlYWRlcnMsIGRlcHRoIC0gMSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBib3R0b21IZWFkZXJzID0gY29sdW1uc1RvR3JvdXAubWFwKChjb2x1bW4sIGluZGV4KSA9PiBjcmVhdGVIZWFkZXIodGFibGUsIGNvbHVtbiwge1xuICAgIGRlcHRoOiBtYXhEZXB0aCxcbiAgICBpbmRleFxuICB9KSk7XG4gIGNyZWF0ZUhlYWRlckdyb3VwKGJvdHRvbUhlYWRlcnMsIG1heERlcHRoIC0gMSk7XG4gIGhlYWRlckdyb3Vwcy5yZXZlcnNlKCk7XG5cbiAgLy8gaGVhZGVyR3JvdXBzID0gaGVhZGVyR3JvdXBzLmZpbHRlcihoZWFkZXJHcm91cCA9PiB7XG4gIC8vICAgcmV0dXJuICFoZWFkZXJHcm91cC5oZWFkZXJzLmV2ZXJ5KGhlYWRlciA9PiBoZWFkZXIuaXNQbGFjZWhvbGRlcilcbiAgLy8gfSlcblxuICBjb25zdCByZWN1cnNlSGVhZGVyc0ZvclNwYW5zID0gaGVhZGVycyA9PiB7XG4gICAgY29uc3QgZmlsdGVyZWRIZWFkZXJzID0gaGVhZGVycy5maWx0ZXIoaGVhZGVyID0+IGhlYWRlci5jb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIHJldHVybiBmaWx0ZXJlZEhlYWRlcnMubWFwKGhlYWRlciA9PiB7XG4gICAgICBsZXQgY29sU3BhbiA9IDA7XG4gICAgICBsZXQgcm93U3BhbiA9IDA7XG4gICAgICBsZXQgY2hpbGRSb3dTcGFucyA9IFswXTtcbiAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycyAmJiBoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgY2hpbGRSb3dTcGFucyA9IFtdO1xuICAgICAgICByZWN1cnNlSGVhZGVyc0ZvclNwYW5zKGhlYWRlci5zdWJIZWFkZXJzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBjb2xTcGFuOiBjaGlsZENvbFNwYW4sXG4gICAgICAgICAgICByb3dTcGFuOiBjaGlsZFJvd1NwYW5cbiAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICBjb2xTcGFuICs9IGNoaWxkQ29sU3BhbjtcbiAgICAgICAgICBjaGlsZFJvd1NwYW5zLnB1c2goY2hpbGRSb3dTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xTcGFuID0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1pbkNoaWxkUm93U3BhbiA9IE1hdGgubWluKC4uLmNoaWxkUm93U3BhbnMpO1xuICAgICAgcm93U3BhbiA9IHJvd1NwYW4gKyBtaW5DaGlsZFJvd1NwYW47XG4gICAgICBoZWFkZXIuY29sU3BhbiA9IGNvbFNwYW47XG4gICAgICBoZWFkZXIucm93U3BhbiA9IHJvd1NwYW47XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xTcGFuLFxuICAgICAgICByb3dTcGFuXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuICByZWN1cnNlSGVhZGVyc0ZvclNwYW5zKChfaGVhZGVyR3JvdXBzJDAkaGVhZGUgPSAoX2hlYWRlckdyb3VwcyQgPSBoZWFkZXJHcm91cHNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfaGVhZGVyR3JvdXBzJC5oZWFkZXJzKSAhPSBudWxsID8gX2hlYWRlckdyb3VwcyQwJGhlYWRlIDogW10pO1xuICByZXR1cm4gaGVhZGVyR3JvdXBzO1xufVxuXG5jb25zdCBjcmVhdGVSb3cgPSAodGFibGUsIGlkLCBvcmlnaW5hbCwgcm93SW5kZXgsIGRlcHRoLCBzdWJSb3dzLCBwYXJlbnRJZCkgPT4ge1xuICBsZXQgcm93ID0ge1xuICAgIGlkLFxuICAgIGluZGV4OiByb3dJbmRleCxcbiAgICBvcmlnaW5hbCxcbiAgICBkZXB0aCxcbiAgICBwYXJlbnRJZCxcbiAgICBfdmFsdWVzQ2FjaGU6IHt9LFxuICAgIF91bmlxdWVWYWx1ZXNDYWNoZToge30sXG4gICAgZ2V0VmFsdWU6IGNvbHVtbklkID0+IHtcbiAgICAgIGlmIChyb3cuX3ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpO1xuICAgICAgaWYgKCEoY29sdW1uICE9IG51bGwgJiYgY29sdW1uLmFjY2Vzc29yRm4pKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5hY2Nlc3NvckZuKHJvdy5vcmlnaW5hbCwgcm93SW5kZXgpO1xuICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgIH0sXG4gICAgZ2V0VW5pcXVlVmFsdWVzOiBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll91bmlxdWVWYWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5hY2Nlc3NvckZuKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKCFjb2x1bW4uY29sdW1uRGVmLmdldFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IFtyb3cuZ2V0VmFsdWUoY29sdW1uSWQpXTtcbiAgICAgICAgcmV0dXJuIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uY29sdW1uRGVmLmdldFVuaXF1ZVZhbHVlcyhyb3cub3JpZ2luYWwsIHJvd0luZGV4KTtcbiAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9LFxuICAgIHJlbmRlclZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICB2YXIgX3JvdyRnZXRWYWx1ZTtcbiAgICAgIHJldHVybiAoX3JvdyRnZXRWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpICE9IG51bGwgPyBfcm93JGdldFZhbHVlIDogdGFibGUub3B0aW9ucy5yZW5kZXJGYWxsYmFja1ZhbHVlO1xuICAgIH0sXG4gICAgc3ViUm93czogc3ViUm93cyAhPSBudWxsID8gc3ViUm93cyA6IFtdLFxuICAgIGdldExlYWZSb3dzOiAoKSA9PiBmbGF0dGVuQnkocm93LnN1YlJvd3MsIGQgPT4gZC5zdWJSb3dzKSxcbiAgICBnZXRQYXJlbnRSb3c6ICgpID0+IHJvdy5wYXJlbnRJZCA/IHRhYmxlLmdldFJvdyhyb3cucGFyZW50SWQsIHRydWUpIDogdW5kZWZpbmVkLFxuICAgIGdldFBhcmVudFJvd3M6ICgpID0+IHtcbiAgICAgIGxldCBwYXJlbnRSb3dzID0gW107XG4gICAgICBsZXQgY3VycmVudFJvdyA9IHJvdztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFJvdyA9IGN1cnJlbnRSb3cuZ2V0UGFyZW50Um93KCk7XG4gICAgICAgIGlmICghcGFyZW50Um93KSBicmVhaztcbiAgICAgICAgcGFyZW50Um93cy5wdXNoKHBhcmVudFJvdyk7XG4gICAgICAgIGN1cnJlbnRSb3cgPSBwYXJlbnRSb3c7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50Um93cy5yZXZlcnNlKCk7XG4gICAgfSxcbiAgICBnZXRBbGxDZWxsczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKV0sIGxlYWZDb2x1bW5zID0+IHtcbiAgICAgIHJldHVybiBsZWFmQ29sdW1ucy5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNlbGwodGFibGUsIHJvdywgY29sdW1uLCBjb2x1bW4uaWQpO1xuICAgICAgfSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRBbGxDZWxscycpKSxcbiAgICBfZ2V0QWxsQ2VsbHNCeUNvbHVtbklkOiBtZW1vKCgpID0+IFtyb3cuZ2V0QWxsQ2VsbHMoKV0sIGFsbENlbGxzID0+IHtcbiAgICAgIHJldHVybiBhbGxDZWxscy5yZWR1Y2UoKGFjYywgY2VsbCkgPT4ge1xuICAgICAgICBhY2NbY2VsbC5jb2x1bW4uaWRdID0gY2VsbDtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldEFsbENlbGxzQnlDb2x1bW5JZCcpKVxuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlLl9mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0YWJsZS5fZmVhdHVyZXNbaV07XG4gICAgZmVhdHVyZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlUm93ID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVSb3cocm93LCB0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIHJvdztcbn07XG5cbi8vXG5cbmNvbnN0IENvbHVtbkZhY2V0aW5nID0ge1xuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLl9nZXRGYWNldGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRSb3dNb2RlbCh0YWJsZSwgY29sdW1uLmlkKTtcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzKHRhYmxlLCBjb2x1bW4uaWQpO1xuICAgIGNvbHVtbi5nZXRGYWNldGVkVW5pcXVlVmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRVbmlxdWVWYWx1ZXMoKTtcbiAgICB9O1xuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXModGFibGUsIGNvbHVtbi5pZCk7XG4gICAgY29sdW1uLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIWNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbi5fZ2V0RmFjZXRlZE1pbk1heFZhbHVlcygpO1xuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IGluY2x1ZGVzU3RyaW5nID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlO1xuICBjb25zdCBzZWFyY2ggPSBmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gQm9vbGVhbigoX3JvdyRnZXRWYWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUgPSBfcm93JGdldFZhbHVlLnRvU3RyaW5nKCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUgPSBfcm93JGdldFZhbHVlLnRvTG93ZXJDYXNlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlLmluY2x1ZGVzKHNlYXJjaCkpO1xufTtcbmluY2x1ZGVzU3RyaW5nLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWUyO1xuICByZXR1cm4gQm9vbGVhbigoX3JvdyRnZXRWYWx1ZTIgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlMiA9IF9yb3ckZ2V0VmFsdWUyLnRvU3RyaW5nKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlMi5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSkpO1xufTtcbmluY2x1ZGVzU3RyaW5nU2Vuc2l0aXZlLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpO1xuY29uc3QgZXF1YWxzU3RyaW5nID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlMztcbiAgcmV0dXJuICgoX3JvdyRnZXRWYWx1ZTMgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsIHx8IChfcm93JGdldFZhbHVlMyA9IF9yb3ckZ2V0VmFsdWUzLnRvU3RyaW5nKCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlMy50b0xvd2VyQ2FzZSgpKSA9PT0gKGZpbHRlclZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBmaWx0ZXJWYWx1ZS50b0xvd2VyQ2FzZSgpKTtcbn07XG5lcXVhbHNTdHJpbmcuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBhcnJJbmNsdWRlcyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTQ7XG4gIHJldHVybiAoX3JvdyRnZXRWYWx1ZTQgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdyRnZXRWYWx1ZTQuaW5jbHVkZXMoZmlsdGVyVmFsdWUpO1xufTtcbmFyckluY2x1ZGVzLmF1dG9SZW1vdmUgPSB2YWwgPT4gdGVzdEZhbHNleSh2YWwpIHx8ICEodmFsICE9IG51bGwgJiYgdmFsLmxlbmd0aCk7XG5jb25zdCBhcnJJbmNsdWRlc0FsbCA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gIWZpbHRlclZhbHVlLnNvbWUodmFsID0+IHtcbiAgICB2YXIgX3JvdyRnZXRWYWx1ZTU7XG4gICAgcmV0dXJuICEoKF9yb3ckZ2V0VmFsdWU1ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCAmJiBfcm93JGdldFZhbHVlNS5pbmNsdWRlcyh2YWwpKTtcbiAgfSk7XG59O1xuYXJySW5jbHVkZXNBbGwuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcbmNvbnN0IGFyckluY2x1ZGVzU29tZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gZmlsdGVyVmFsdWUuc29tZSh2YWwgPT4ge1xuICAgIHZhciBfcm93JGdldFZhbHVlNjtcbiAgICByZXR1cm4gKF9yb3ckZ2V0VmFsdWU2ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWU2LmluY2x1ZGVzKHZhbCk7XG4gIH0pO1xufTtcbmFyckluY2x1ZGVzU29tZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xuY29uc3QgZXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09PSBmaWx0ZXJWYWx1ZTtcbn07XG5lcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCB3ZWFrRXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09IGZpbHRlclZhbHVlO1xufTtcbndlYWtFcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBpbk51bWJlclJhbmdlID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIGxldCBbbWluLCBtYXhdID0gZmlsdGVyVmFsdWU7XG4gIGNvbnN0IHJvd1ZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgcmV0dXJuIHJvd1ZhbHVlID49IG1pbiAmJiByb3dWYWx1ZSA8PSBtYXg7XG59O1xuaW5OdW1iZXJSYW5nZS5yZXNvbHZlRmlsdGVyVmFsdWUgPSB2YWwgPT4ge1xuICBsZXQgW3Vuc2FmZU1pbiwgdW5zYWZlTWF4XSA9IHZhbDtcbiAgbGV0IHBhcnNlZE1pbiA9IHR5cGVvZiB1bnNhZmVNaW4gIT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh1bnNhZmVNaW4pIDogdW5zYWZlTWluO1xuICBsZXQgcGFyc2VkTWF4ID0gdHlwZW9mIHVuc2FmZU1heCAhPT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHVuc2FmZU1heCkgOiB1bnNhZmVNYXg7XG4gIGxldCBtaW4gPSB1bnNhZmVNaW4gPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1pbikgPyAtSW5maW5pdHkgOiBwYXJzZWRNaW47XG4gIGxldCBtYXggPSB1bnNhZmVNYXggPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1heCkgPyBJbmZpbml0eSA6IHBhcnNlZE1heDtcbiAgaWYgKG1pbiA+IG1heCkge1xuICAgIGNvbnN0IHRlbXAgPSBtaW47XG4gICAgbWluID0gbWF4O1xuICAgIG1heCA9IHRlbXA7XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59O1xuaW5OdW1iZXJSYW5nZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCB0ZXN0RmFsc2V5KHZhbFswXSkgJiYgdGVzdEZhbHNleSh2YWxbMV0pO1xuXG4vLyBFeHBvcnRcblxuY29uc3QgZmlsdGVyRm5zID0ge1xuICBpbmNsdWRlc1N0cmluZyxcbiAgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUsXG4gIGVxdWFsc1N0cmluZyxcbiAgYXJySW5jbHVkZXMsXG4gIGFyckluY2x1ZGVzQWxsLFxuICBhcnJJbmNsdWRlc1NvbWUsXG4gIGVxdWFscyxcbiAgd2Vha0VxdWFscyxcbiAgaW5OdW1iZXJSYW5nZVxufTtcbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIHRlc3RGYWxzZXkodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwgfHwgdmFsID09PSAnJztcbn1cblxuLy9cblxuY29uc3QgQ29sdW1uRmlsdGVyaW5nID0ge1xuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbHRlckZuOiAnYXV0bydcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uRmlsdGVyczogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uRmlsdGVyc0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uRmlsdGVycycsIHRhYmxlKSxcbiAgICAgIGZpbHRlckZyb21MZWFmUm93czogZmFsc2UsXG4gICAgICBtYXhMZWFmUm93RmlsdGVyRGVwdGg6IDEwMFxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0QXV0b0ZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmlyc3RSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0Um93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmluY2x1ZGVzU3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5pbk51bWJlclJhbmdlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuZXF1YWxzO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5lcXVhbHM7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5hcnJJbmNsdWRlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWx0ZXJGbnMud2Vha0VxdWFscztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIsIF90YWJsZSRvcHRpb25zJGZpbHRlcjI7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4gOiBjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuID09PSAnYXV0bycgPyBjb2x1bW4uZ2V0QXV0b0ZpbHRlckZuKCkgOiAvLyBAdHMtaWdub3JlXG4gICAgICAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyID0gKF90YWJsZSRvcHRpb25zJGZpbHRlcjIgPSB0YWJsZS5vcHRpb25zLmZpbHRlckZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJGZpbHRlcjJbY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRmaWx0ZXIgOiBmaWx0ZXJGbnNbY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbl07XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuRmlsdGVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVDb2x1bW5GaWx0ZXIpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzRmlsdGVyZWQgPSAoKSA9PiBjb2x1bW4uZ2V0RmlsdGVySW5kZXgoKSA+IC0xO1xuICAgIGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW07XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycykgPT0gbnVsbCB8fCAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gX3RhYmxlJGdldFN0YXRlJGNvbHVtLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtLnZhbHVlO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpbHRlckluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIsIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTM7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMyA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgOiAtMTtcbiAgICB9O1xuICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSA9IHZhbHVlID0+IHtcbiAgICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMob2xkID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyRm4gPSBjb2x1bW4uZ2V0RmlsdGVyRm4oKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNGaWx0ZXIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgY29uc3QgbmV3RmlsdGVyID0gZnVuY3Rpb25hbFVwZGF0ZSh2YWx1ZSwgcHJldmlvdXNGaWx0ZXIgPyBwcmV2aW91c0ZpbHRlci52YWx1ZSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIG5ld0ZpbHRlciwgY29sdW1uKSkge1xuICAgICAgICAgIHZhciBfb2xkJGZpbHRlcjtcbiAgICAgICAgICByZXR1cm4gKF9vbGQkZmlsdGVyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF9vbGQkZmlsdGVyIDogW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RmlsdGVyT2JqID0ge1xuICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgdmFsdWU6IG5ld0ZpbHRlclxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJldmlvdXNGaWx0ZXIpIHtcbiAgICAgICAgICB2YXIgX29sZCRtYXA7XG4gICAgICAgICAgcmV0dXJuIChfb2xkJG1hcCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLm1hcChkID0+IHtcbiAgICAgICAgICAgIGlmIChkLmlkID09PSBjb2x1bW4uaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0ZpbHRlck9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pKSAhPSBudWxsID8gX29sZCRtYXAgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBbLi4ub2xkLCBuZXdGaWx0ZXJPYmpdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbmV3RmlsdGVyT2JqXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgX3RhYmxlKSA9PiB7XG4gICAgcm93LmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICByb3cuY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzID0gdXBkYXRlciA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1ucyA9IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCk7XG4gICAgICBjb25zdCB1cGRhdGVGbiA9IG9sZCA9PiB7XG4gICAgICAgIHZhciBfZnVuY3Rpb25hbFVwZGF0ZTtcbiAgICAgICAgcmV0dXJuIChfZnVuY3Rpb25hbFVwZGF0ZSA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mdW5jdGlvbmFsVXBkYXRlLmZpbHRlcihmaWx0ZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBmaWx0ZXIuaWQpO1xuICAgICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiwgZmlsdGVyLnZhbHVlLCBjb2x1bW4pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25Db2x1bW5GaWx0ZXJzQ2hhbmdlID09IG51bGwgfHwgdGFibGUub3B0aW9ucy5vbkNvbHVtbkZpbHRlcnNDaGFuZ2UodXBkYXRlRm4pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRDb2x1bW5GaWx0ZXJzID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiwgdmFsdWUsIGNvbHVtbikge1xuICByZXR1cm4gKGZpbHRlckZuICYmIGZpbHRlckZuLmF1dG9SZW1vdmUgPyBmaWx0ZXJGbi5hdXRvUmVtb3ZlKHZhbHVlLCBjb2x1bW4pIDogZmFsc2UpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhdmFsdWU7XG59XG5cbmNvbnN0IHN1bSA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgLy8gSXQncyBmYXN0ZXIgdG8ganVzdCBhZGQgdGhlIGFnZ3JlZ2F0aW9ucyB0b2dldGhlciBpbnN0ZWFkIG9mXG4gIC8vIHByb2Nlc3MgbGVhZiBub2RlcyBpbmRpdmlkdWFsbHlcbiAgcmV0dXJuIGNoaWxkUm93cy5yZWR1Y2UoKHN1bSwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IG5leHQuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIHJldHVybiBzdW0gKyAodHlwZW9mIG5leHRWYWx1ZSA9PT0gJ251bWJlcicgPyBuZXh0VmFsdWUgOiAwKTtcbiAgfSwgMCk7XG59O1xuY29uc3QgbWluID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICBsZXQgbWluO1xuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAobWluID4gdmFsdWUgfHwgbWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSB7XG4gICAgICBtaW4gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWluO1xufTtcbmNvbnN0IG1heCA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1heDtcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1heCA8IHZhbHVlIHx8IG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkge1xuICAgICAgbWF4ID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1heDtcbn07XG5jb25zdCBleHRlbnQgPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtaW47XG4gIGxldCBtYXg7XG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IHZhbHVlKSBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFttaW4sIG1heF07XG59O1xuY29uc3QgbWVhbiA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IHN1bSA9IDA7XG4gIGxlYWZSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBsZXQgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICsrY291bnQsIHN1bSArPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBpZiAoY291bnQpIHJldHVybiBzdW0gLyBjb3VudDtcbiAgcmV0dXJuO1xufTtcbmNvbnN0IG1lZGlhbiA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgaWYgKCFsZWFmUm93cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gbGVhZlJvd3MubWFwKHJvdyA9PiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKTtcbiAgaWYgKCFpc051bWJlckFycmF5KHZhbHVlcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdmFsdWVzWzBdO1xuICB9XG4gIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuICBjb25zdCBudW1zID0gdmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgcmV0dXJuIHZhbHVlcy5sZW5ndGggJSAyICE9PSAwID8gbnVtc1ttaWRdIDogKG51bXNbbWlkIC0gMV0gKyBudW1zW21pZF0pIC8gMjtcbn07XG5jb25zdCB1bmlxdWUgPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQobGVhZlJvd3MubWFwKGQgPT4gZC5nZXRWYWx1ZShjb2x1bW5JZCkpKS52YWx1ZXMoKSk7XG59O1xuY29uc3QgdW5pcXVlQ291bnQgPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIHJldHVybiBuZXcgU2V0KGxlYWZSb3dzLm1hcChkID0+IGQuZ2V0VmFsdWUoY29sdW1uSWQpKSkuc2l6ZTtcbn07XG5jb25zdCBjb3VudCA9IChfY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIHJldHVybiBsZWFmUm93cy5sZW5ndGg7XG59O1xuY29uc3QgYWdncmVnYXRpb25GbnMgPSB7XG4gIHN1bSxcbiAgbWluLFxuICBtYXgsXG4gIGV4dGVudCxcbiAgbWVhbixcbiAgbWVkaWFuLFxuICB1bmlxdWUsXG4gIHVuaXF1ZUNvdW50LFxuICBjb3VudFxufTtcblxuLy9cblxuY29uc3QgQ29sdW1uR3JvdXBpbmcgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgYWdncmVnYXRlZENlbGw6IHByb3BzID0+IHtcbiAgICAgICAgdmFyIF90b1N0cmluZywgX3Byb3BzJGdldFZhbHVlO1xuICAgICAgICByZXR1cm4gKF90b1N0cmluZyA9IChfcHJvcHMkZ2V0VmFsdWUgPSBwcm9wcy5nZXRWYWx1ZSgpKSA9PSBudWxsIHx8IF9wcm9wcyRnZXRWYWx1ZS50b1N0cmluZyA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdldFZhbHVlLnRvU3RyaW5nKCkpICE9IG51bGwgPyBfdG9TdHJpbmcgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGFnZ3JlZ2F0aW9uRm46ICdhdXRvJ1xuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBncm91cGluZzogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uR3JvdXBpbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2dyb3VwaW5nJywgdGFibGUpLFxuICAgICAgZ3JvdXBlZENvbHVtbk1vZGU6ICdyZW9yZGVyJ1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4udG9nZ2xlR3JvdXBpbmcgPSAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRHcm91cGluZyhvbGQgPT4ge1xuICAgICAgICAvLyBGaW5kIGFueSBleGlzdGluZyBncm91cGluZyBmb3IgdGhpcyBjb2x1bW5cbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5pbmNsdWRlcyhjb2x1bW4uaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZC5maWx0ZXIoZCA9PiBkICE9PSBjb2x1bW4uaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uKG9sZCAhPSBudWxsID8gb2xkIDogW10pLCBjb2x1bW4uaWRdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuR3JvdXAgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUdyb3VwaW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKCEhY29sdW1uLmFjY2Vzc29yRm4gfHwgISFjb2x1bW4uY29sdW1uRGVmLmdldEdyb3VwaW5nVmFsdWUpO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzR3JvdXBlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkZ3JvdXA7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRncm91cCA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRHcm91cGVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGdyb3VwMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGdyb3VwMiA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyLmluZGV4T2YoY29sdW1uLmlkKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVHcm91cGluZ0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5Hcm91cCA9IGNvbHVtbi5nZXRDYW5Hcm91cCgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFjYW5Hcm91cCkgcmV0dXJuO1xuICAgICAgICBjb2x1bW4udG9nZ2xlR3JvdXBpbmcoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QXV0b0FnZ3JlZ2F0aW9uRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5zdW07XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5leHRlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QWdncmVnYXRpb25GbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRhZ2dyZWcsIF90YWJsZSRvcHRpb25zJGFnZ3JlZzI7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbikgPyBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gOiBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvQWdncmVnYXRpb25GbigpIDogKF90YWJsZSRvcHRpb25zJGFnZ3JlZyA9IChfdGFibGUkb3B0aW9ucyRhZ2dyZWcyID0gdGFibGUub3B0aW9ucy5hZ2dyZWdhdGlvbkZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJGFnZ3JlZzJbY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGFnZ3JlZyA6IGFnZ3JlZ2F0aW9uRm5zW2NvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25Gbl07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRHcm91cGluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkdyb3VwaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uR3JvdXBpbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRHcm91cGluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRnLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0R3JvdXBpbmcoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRnID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmdyb3VwaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRnIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEdyb3VwZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRHcm91cGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsR3JvdXBpbmcgfHwgIXRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LmdldElzR3JvdXBlZCA9ICgpID0+ICEhcm93Lmdyb3VwaW5nQ29sdW1uSWQ7XG4gICAgcm93LmdldEdyb3VwaW5nVmFsdWUgPSBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uY29sdW1uRGVmLmdldEdyb3VwaW5nVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgICAgfVxuICAgICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZShyb3cub3JpZ2luYWwpO1xuICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfTtcbiAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUgPSB7fTtcbiAgfSxcbiAgY3JlYXRlQ2VsbDogKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSkgPT4ge1xuICAgIGNlbGwuZ2V0SXNHcm91cGVkID0gKCkgPT4gY29sdW1uLmdldElzR3JvdXBlZCgpICYmIGNvbHVtbi5pZCA9PT0gcm93Lmdyb3VwaW5nQ29sdW1uSWQ7XG4gICAgY2VsbC5nZXRJc1BsYWNlaG9sZGVyID0gKCkgPT4gIWNlbGwuZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uLmdldElzR3JvdXBlZCgpO1xuICAgIGNlbGwuZ2V0SXNBZ2dyZWdhdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgIHJldHVybiAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiAhY2VsbC5nZXRJc1BsYWNlaG9sZGVyKCkgJiYgISEoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSkge1xuICBpZiAoIShncm91cGluZyAhPSBudWxsICYmIGdyb3VwaW5nLmxlbmd0aCkgfHwgIWdyb3VwZWRDb2x1bW5Nb2RlKSB7XG4gICAgcmV0dXJuIGxlYWZDb2x1bW5zO1xuICB9XG4gIGNvbnN0IG5vbkdyb3VwaW5nQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2wgPT4gIWdyb3VwaW5nLmluY2x1ZGVzKGNvbC5pZCkpO1xuICBpZiAoZ3JvdXBlZENvbHVtbk1vZGUgPT09ICdyZW1vdmUnKSB7XG4gICAgcmV0dXJuIG5vbkdyb3VwaW5nQ29sdW1ucztcbiAgfVxuICBjb25zdCBncm91cGluZ0NvbHVtbnMgPSBncm91cGluZy5tYXAoZyA9PiBsZWFmQ29sdW1ucy5maW5kKGNvbCA9PiBjb2wuaWQgPT09IGcpKS5maWx0ZXIoQm9vbGVhbik7XG4gIHJldHVybiBbLi4uZ3JvdXBpbmdDb2x1bW5zLCAuLi5ub25Hcm91cGluZ0NvbHVtbnNdO1xufVxuXG4vL1xuXG5jb25zdCBDb2x1bW5PcmRlcmluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbk9yZGVyOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5PcmRlckNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uT3JkZXInLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldEluZGV4ID0gbWVtbyhwb3NpdGlvbiA9PiBbX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pXSwgY29sdW1ucyA9PiBjb2x1bW5zLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0SW5kZXgnKSk7XG4gICAgY29sdW1uLmdldElzRmlyc3RDb2x1bW4gPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX2NvbHVtbnMkO1xuICAgICAgY29uc3QgY29sdW1ucyA9IF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW5zJCA9IGNvbHVtbnNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfY29sdW1ucyQuaWQpID09PSBjb2x1bW4uaWQ7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNMYXN0Q29sdW1uID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9jb2x1bW5zO1xuICAgICAgY29uc3QgY29sdW1ucyA9IF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW5zID0gY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbHVtbnMuaWQpID09PSBjb2x1bW4uaWQ7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5PcmRlciA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtbk9yZGVyQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uT3JkZXJDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5PcmRlciA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjO1xuICAgICAgdGFibGUuc2V0Q29sdW1uT3JkZXIoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtbk9yZGVyKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5PcmRlciwgdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZywgdGFibGUub3B0aW9ucy5ncm91cGVkQ29sdW1uTW9kZV0sIChjb2x1bW5PcmRlciwgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKSA9PiBjb2x1bW5zID0+IHtcbiAgICAgIC8vIFNvcnQgZ3JvdXBlZCBjb2x1bW5zIHRvIHRoZSBzdGFydCBvZiB0aGUgY29sdW1uIGxpc3RcbiAgICAgIC8vIGJlZm9yZSB0aGUgaGVhZGVycyBhcmUgYnVpbHRcbiAgICAgIGxldCBvcmRlcmVkQ29sdW1ucyA9IFtdO1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBvcmRlciwgcmV0dXJuIHRoZSBub3JtYWwgY29sdW1uc1xuICAgICAgaWYgKCEoY29sdW1uT3JkZXIgIT0gbnVsbCAmJiBjb2x1bW5PcmRlci5sZW5ndGgpKSB7XG4gICAgICAgIG9yZGVyZWRDb2x1bW5zID0gY29sdW1ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbk9yZGVyQ29weSA9IFsuLi5jb2x1bW5PcmRlcl07XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gb3JkZXIsIG1ha2UgYSBjb3B5IG9mIHRoZSBjb2x1bW5zXG4gICAgICAgIGNvbnN0IGNvbHVtbnNDb3B5ID0gWy4uLmNvbHVtbnNdO1xuXG4gICAgICAgIC8vIEFuZCBtYWtlIGEgbmV3IG9yZGVyZWQgYXJyYXkgb2YgdGhlIGNvbHVtbnNcblxuICAgICAgICAvLyBMb29wIG92ZXIgdGhlIGNvbHVtbnMgYW5kIHBsYWNlIHRoZW0gaW4gb3JkZXIgaW50byB0aGUgbmV3IGFycmF5XG4gICAgICAgIHdoaWxlIChjb2x1bW5zQ29weS5sZW5ndGggJiYgY29sdW1uT3JkZXJDb3B5Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldENvbHVtbklkID0gY29sdW1uT3JkZXJDb3B5LnNoaWZ0KCk7XG4gICAgICAgICAgY29uc3QgZm91bmRJbmRleCA9IGNvbHVtbnNDb3B5LmZpbmRJbmRleChkID0+IGQuaWQgPT09IHRhcmdldENvbHVtbklkKTtcbiAgICAgICAgICBpZiAoZm91bmRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBvcmRlcmVkQ29sdW1ucy5wdXNoKGNvbHVtbnNDb3B5LnNwbGljZShmb3VuZEluZGV4LCAxKVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFueSBjb2x1bW5zIGxlZnQsIGFkZCB0aGVtIHRvIHRoZSBlbmRcbiAgICAgICAgb3JkZXJlZENvbHVtbnMgPSBbLi4ub3JkZXJlZENvbHVtbnMsIC4uLmNvbHVtbnNDb3B5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmRlckNvbHVtbnMob3JkZXJlZENvbHVtbnMsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnX2dldE9yZGVyQ29sdW1uc0ZuJykpO1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlID0gKCkgPT4gKHtcbiAgbGVmdDogW10sXG4gIHJpZ2h0OiBbXVxufSk7XG5jb25zdCBDb2x1bW5QaW5uaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uUGlubmluZzogZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtblBpbm5pbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblBpbm5pbmcnLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnBpbiA9IHBvc2l0aW9uID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbklkcyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpLm1hcChkID0+IGQuaWQpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHRhYmxlLnNldENvbHVtblBpbm5pbmcob2xkID0+IHtcbiAgICAgICAgdmFyIF9vbGQkbGVmdDMsIF9vbGQkcmlnaHQzO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB2YXIgX29sZCRsZWZ0LCBfb2xkJHJpZ2h0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAoKF9vbGQkbGVmdCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmxlZnQpICE9IG51bGwgPyBfb2xkJGxlZnQgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSxcbiAgICAgICAgICAgIHJpZ2h0OiBbLi4uKChfb2xkJHJpZ2h0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0IDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksIC4uLmNvbHVtbklkc11cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdmFyIF9vbGQkbGVmdDIsIF9vbGQkcmlnaHQyO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBbLi4uKChfb2xkJGxlZnQyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdDIgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSwgLi4uY29sdW1uSWRzXSxcbiAgICAgICAgICAgIHJpZ2h0OiAoKF9vbGQkcmlnaHQyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0MiA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6ICgoX29sZCRsZWZ0MyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmxlZnQpICE9IG51bGwgPyBfb2xkJGxlZnQzIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksXG4gICAgICAgICAgcmlnaHQ6ICgoX29sZCRyaWdodDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQzIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhblBpbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5zID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCk7XG4gICAgICByZXR1cm4gbGVhZkNvbHVtbnMuc29tZShkID0+IHtcbiAgICAgICAgdmFyIF9kJGNvbHVtbkRlZiRlbmFibGVQaSwgX3JlZiwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgICByZXR1cm4gKChfZCRjb2x1bW5EZWYkZW5hYmxlUGkgPSBkLmNvbHVtbkRlZi5lbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX2QkY29sdW1uRGVmJGVuYWJsZVBpIDogdHJ1ZSkgJiYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uUGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRhYmxlLm9wdGlvbnMuZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9yZWYgOiB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzUGlubmVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbklkcyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpLm1hcChkID0+IGQuaWQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodFxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZztcbiAgICAgIGNvbnN0IGlzTGVmdCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQuaW5jbHVkZXMoZCkpO1xuICAgICAgY29uc3QgaXNSaWdodCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5pbmNsdWRlcyhkKSk7XG4gICAgICByZXR1cm4gaXNMZWZ0ID8gJ2xlZnQnIDogaXNSaWdodCA/ICdyaWdodCcgOiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW0sIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTI7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGNvbHVtbi5nZXRJc1Bpbm5lZCgpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID8gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gX3RhYmxlJGdldFN0YXRlJGNvbHVtMltwb3NpdGlvbl0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0yLmluZGV4T2YoY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA6IC0xIDogMDtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LmdldENlbnRlclZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ2VsbHMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBsZWZ0QW5kUmlnaHQgPSBbLi4uKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSksIC4uLihyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSldO1xuICAgICAgcmV0dXJuIGFsbENlbGxzLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5jb2x1bW4uaWQpKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldENlbnRlclZpc2libGVDZWxscycpKTtcbiAgICByb3cuZ2V0TGVmdFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0XSwgKGFsbENlbGxzLCBsZWZ0KSA9PiB7XG4gICAgICBjb25zdCBjZWxscyA9IChsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDZWxscy5maW5kKGNlbGwgPT4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uOiAnbGVmdCdcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjZWxscztcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldExlZnRWaXNpYmxlQ2VsbHMnKSk7XG4gICAgcm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENlbGxzLCByaWdodCkgPT4ge1xuICAgICAgY29uc3QgY2VsbHMgPSAocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDZWxscy5maW5kKGNlbGwgPT4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRSaWdodFZpc2libGVDZWxscycpKTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5QaW5uaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uUGlubmluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblBpbm5pbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5QaW5uaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICByZXR1cm4gdGFibGUuc2V0Q29sdW1uUGlubmluZyhkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmNvbHVtblBpbm5pbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lQ29sdW1uc1Bpbm5lZCA9IHBvc2l0aW9uID0+IHtcbiAgICAgIHZhciBfcGlubmluZ1N0YXRlJHBvc2l0aW87XG4gICAgICBjb25zdCBwaW5uaW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmc7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfcGlubmluZ1N0YXRlJGxlZnQsIF9waW5uaW5nU3RhdGUkcmlnaHQ7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCgoX3Bpbm5pbmdTdGF0ZSRsZWZ0ID0gcGlubmluZ1N0YXRlLmxlZnQpID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJGxlZnQubGVuZ3RoKSB8fCAoKF9waW5uaW5nU3RhdGUkcmlnaHQgPSBwaW5uaW5nU3RhdGUucmlnaHQpID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJHJpZ2h0Lmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4oKF9waW5uaW5nU3RhdGUkcG9zaXRpbyA9IHBpbm5pbmdTdGF0ZVtwb3NpdGlvbl0pID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJHBvc2l0aW8ubGVuZ3RoKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldExlZnRMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0XSwgKGFsbENvbHVtbnMsIGxlZnQpID0+IHtcbiAgICAgIHJldHVybiAobGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ29sdW1ucy5maW5kKGNvbHVtbiA9PiBjb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0TGVmdExlYWZDb2x1bW5zJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0TGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgcmlnaHQpID0+IHtcbiAgICAgIHJldHVybiAocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRSaWdodExlYWZDb2x1bW5zJykpO1xuICAgIHRhYmxlLmdldENlbnRlckxlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgY29uc3QgbGVmdEFuZFJpZ2h0ID0gWy4uLihsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLCAuLi4ocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pXTtcbiAgICAgIHJldHVybiBhbGxDb2x1bW5zLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5pZCkpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0Q2VudGVyTGVhZkNvbHVtbnMnKSk7XG4gIH1cbn07XG5cbi8vXG5cbi8vXG5cbmNvbnN0IGRlZmF1bHRDb2x1bW5TaXppbmcgPSB7XG4gIHNpemU6IDE1MCxcbiAgbWluU2l6ZTogMjAsXG4gIG1heFNpemU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG59O1xuY29uc3QgZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSA9ICgpID0+ICh7XG4gIHN0YXJ0T2Zmc2V0OiBudWxsLFxuICBzdGFydFNpemU6IG51bGwsXG4gIGRlbHRhT2Zmc2V0OiBudWxsLFxuICBkZWx0YVBlcmNlbnRhZ2U6IG51bGwsXG4gIGlzUmVzaXppbmdDb2x1bW46IGZhbHNlLFxuICBjb2x1bW5TaXppbmdTdGFydDogW11cbn0pO1xuY29uc3QgQ29sdW1uU2l6aW5nID0ge1xuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIGRlZmF1bHRDb2x1bW5TaXppbmc7XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5TaXppbmc6IHt9LFxuICAgICAgY29sdW1uU2l6aW5nSW5mbzogZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5SZXNpemVNb2RlOiAnb25FbmQnLFxuICAgICAgY29sdW1uUmVzaXplRGlyZWN0aW9uOiAnbHRyJyxcbiAgICAgIG9uQ29sdW1uU2l6aW5nQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdjb2x1bW5TaXppbmcnLCB0YWJsZSksXG4gICAgICBvbkNvbHVtblNpemluZ0luZm9DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblNpemluZ0luZm8nLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkbWluLCBfcmVmLCBfY29sdW1uJGNvbHVtbkRlZiRtYXg7XG4gICAgICBjb25zdCBjb2x1bW5TaXplID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmdbY29sdW1uLmlkXTtcbiAgICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCgoX2NvbHVtbiRjb2x1bW5EZWYkbWluID0gY29sdW1uLmNvbHVtbkRlZi5taW5TaXplKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkbWluIDogZGVmYXVsdENvbHVtblNpemluZy5taW5TaXplLCAoX3JlZiA9IGNvbHVtblNpemUgIT0gbnVsbCA/IGNvbHVtblNpemUgOiBjb2x1bW4uY29sdW1uRGVmLnNpemUpICE9IG51bGwgPyBfcmVmIDogZGVmYXVsdENvbHVtblNpemluZy5zaXplKSwgKF9jb2x1bW4kY29sdW1uRGVmJG1heCA9IGNvbHVtbi5jb2x1bW5EZWYubWF4U2l6ZSkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJG1heCA6IGRlZmF1bHRDb2x1bW5TaXppbmcubWF4U2l6ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0U3RhcnQgPSBtZW1vKHBvc2l0aW9uID0+IFtwb3NpdGlvbiwgX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ10sIChwb3NpdGlvbiwgY29sdW1ucykgPT4gY29sdW1ucy5zbGljZSgwLCBjb2x1bW4uZ2V0SW5kZXgocG9zaXRpb24pKS5yZWR1Y2UoKHN1bSwgY29sdW1uKSA9PiBzdW0gKyBjb2x1bW4uZ2V0U2l6ZSgpLCAwKSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRTdGFydCcpKTtcbiAgICBjb2x1bW4uZ2V0QWZ0ZXIgPSBtZW1vKHBvc2l0aW9uID0+IFtwb3NpdGlvbiwgX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ10sIChwb3NpdGlvbiwgY29sdW1ucykgPT4gY29sdW1ucy5zbGljZShjb2x1bW4uZ2V0SW5kZXgocG9zaXRpb24pICsgMSkucmVkdWNlKChzdW0sIGNvbHVtbikgPT4gc3VtICsgY29sdW1uLmdldFNpemUoKSwgMCksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWZ0ZXInKSk7XG4gICAgY29sdW1uLnJlc2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgW2NvbHVtbi5pZF06IF8sXG4gICAgICAgICAgLi4ucmVzdFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiByZXN0O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuUmVzaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVSZXNpemluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVDb2x1bW5SZXNpemluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzUmVzaXppbmcgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5TaXppbmdJbmZvLmlzUmVzaXppbmdDb2x1bW4gPT09IGNvbHVtbi5pZDtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVIZWFkZXI6IChoZWFkZXIsIHRhYmxlKSA9PiB7XG4gICAgaGVhZGVyLmdldFNpemUgPSAoKSA9PiB7XG4gICAgICBsZXQgc3VtID0gMDtcbiAgICAgIGNvbnN0IHJlY3Vyc2UgPSBoZWFkZXIgPT4ge1xuICAgICAgICBpZiAoaGVhZGVyLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgaGVhZGVyLnN1YkhlYWRlcnMuZm9yRWFjaChyZWN1cnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2hlYWRlciRjb2x1bW4kZ2V0U2l6O1xuICAgICAgICAgIHN1bSArPSAoX2hlYWRlciRjb2x1bW4kZ2V0U2l6ID0gaGVhZGVyLmNvbHVtbi5nZXRTaXplKCkpICE9IG51bGwgPyBfaGVhZGVyJGNvbHVtbiRnZXRTaXogOiAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVjdXJzZShoZWFkZXIpO1xuICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuICAgIGhlYWRlci5nZXRTdGFydCA9ICgpID0+IHtcbiAgICAgIGlmIChoZWFkZXIuaW5kZXggPiAwKSB7XG4gICAgICAgIGNvbnN0IHByZXZTaWJsaW5nSGVhZGVyID0gaGVhZGVyLmhlYWRlckdyb3VwLmhlYWRlcnNbaGVhZGVyLmluZGV4IC0gMV07XG4gICAgICAgIHJldHVybiBwcmV2U2libGluZ0hlYWRlci5nZXRTdGFydCgpICsgcHJldlNpYmxpbmdIZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICBoZWFkZXIuZ2V0UmVzaXplSGFuZGxlciA9IF9jb250ZXh0RG9jdW1lbnQgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGhlYWRlci5jb2x1bW4uaWQpO1xuICAgICAgY29uc3QgY2FuUmVzaXplID0gY29sdW1uID09IG51bGwgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0Q2FuUmVzaXplKCk7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGlmICghY29sdW1uIHx8ICFjYW5SZXNpemUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wZXJzaXN0ID09IG51bGwgfHwgZS5wZXJzaXN0KCk7XG4gICAgICAgIGlmIChpc1RvdWNoU3RhcnRFdmVudChlKSkge1xuICAgICAgICAgIC8vIGxldHMgbm90IHJlc3BvbmQgdG8gbXVsdGlwbGUgdG91Y2hlcyAoZS5nLiAyIG9yIDMgZmluZ2VycylcbiAgICAgICAgICBpZiAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0U2l6ZSA9IGhlYWRlci5nZXRTaXplKCk7XG4gICAgICAgIGNvbnN0IGNvbHVtblNpemluZ1N0YXJ0ID0gaGVhZGVyID8gaGVhZGVyLmdldExlYWZIZWFkZXJzKCkubWFwKGQgPT4gW2QuY29sdW1uLmlkLCBkLmNvbHVtbi5nZXRTaXplKCldKSA6IFtbY29sdW1uLmlkLCBjb2x1bW4uZ2V0U2l6ZSgpXV07XG4gICAgICAgIGNvbnN0IGNsaWVudFggPSBpc1RvdWNoU3RhcnRFdmVudChlKSA/IE1hdGgucm91bmQoZS50b3VjaGVzWzBdLmNsaWVudFgpIDogZS5jbGllbnRYO1xuICAgICAgICBjb25zdCBuZXdDb2x1bW5TaXppbmcgPSB7fTtcbiAgICAgICAgY29uc3QgdXBkYXRlT2Zmc2V0ID0gKGV2ZW50VHlwZSwgY2xpZW50WFBvcykgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2xpZW50WFBvcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhvbGQgPT4ge1xuICAgICAgICAgICAgdmFyIF9vbGQkc3RhcnRPZmZzZXQsIF9vbGQkc3RhcnRTaXplO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFEaXJlY3Rpb24gPSB0YWJsZS5vcHRpb25zLmNvbHVtblJlc2l6ZURpcmVjdGlvbiA9PT0gJ3J0bCcgPyAtMSA6IDE7XG4gICAgICAgICAgICBjb25zdCBkZWx0YU9mZnNldCA9IChjbGllbnRYUG9zIC0gKChfb2xkJHN0YXJ0T2Zmc2V0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuc3RhcnRPZmZzZXQpICE9IG51bGwgPyBfb2xkJHN0YXJ0T2Zmc2V0IDogMCkpICogZGVsdGFEaXJlY3Rpb247XG4gICAgICAgICAgICBjb25zdCBkZWx0YVBlcmNlbnRhZ2UgPSBNYXRoLm1heChkZWx0YU9mZnNldCAvICgoX29sZCRzdGFydFNpemUgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5zdGFydFNpemUpICE9IG51bGwgPyBfb2xkJHN0YXJ0U2l6ZSA6IDApLCAtMC45OTk5OTkpO1xuICAgICAgICAgICAgb2xkLmNvbHVtblNpemluZ1N0YXJ0LmZvckVhY2goX3JlZjMgPT4ge1xuICAgICAgICAgICAgICBsZXQgW2NvbHVtbklkLCBoZWFkZXJTaXplXSA9IF9yZWYzO1xuICAgICAgICAgICAgICBuZXdDb2x1bW5TaXppbmdbY29sdW1uSWRdID0gTWF0aC5yb3VuZChNYXRoLm1heChoZWFkZXJTaXplICsgaGVhZGVyU2l6ZSAqIGRlbHRhUGVyY2VudGFnZSwgMCkgKiAxMDApIC8gMTAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgICAgIGRlbHRhT2Zmc2V0LFxuICAgICAgICAgICAgICBkZWx0YVBlcmNlbnRhZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRhYmxlLm9wdGlvbnMuY29sdW1uUmVzaXplTW9kZSA9PT0gJ29uQ2hhbmdlJyB8fCBldmVudFR5cGUgPT09ICdlbmQnKSB7XG4gICAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmcob2xkID0+ICh7XG4gICAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgICAgLi4ubmV3Q29sdW1uU2l6aW5nXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbk1vdmUgPSBjbGllbnRYUG9zID0+IHVwZGF0ZU9mZnNldCgnbW92ZScsIGNsaWVudFhQb3MpO1xuICAgICAgICBjb25zdCBvbkVuZCA9IGNsaWVudFhQb3MgPT4ge1xuICAgICAgICAgIHVwZGF0ZU9mZnNldCgnZW5kJywgY2xpZW50WFBvcyk7XG4gICAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhvbGQgPT4gKHtcbiAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgIGlzUmVzaXppbmdDb2x1bW46IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IG51bGwsXG4gICAgICAgICAgICBzdGFydFNpemU6IG51bGwsXG4gICAgICAgICAgICBkZWx0YU9mZnNldDogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhUGVyY2VudGFnZTogbnVsbCxcbiAgICAgICAgICAgIGNvbHVtblNpemluZ1N0YXJ0OiBbXVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29udGV4dERvY3VtZW50ID0gX2NvbnRleHREb2N1bWVudCB8fCB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsO1xuICAgICAgICBjb25zdCBtb3VzZUV2ZW50cyA9IHtcbiAgICAgICAgICBtb3ZlSGFuZGxlcjogZSA9PiBvbk1vdmUoZS5jbGllbnRYKSxcbiAgICAgICAgICB1cEhhbmRsZXI6IGUgPT4ge1xuICAgICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlRXZlbnRzLm1vdmVIYW5kbGVyKTtcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VFdmVudHMudXBIYW5kbGVyKTtcbiAgICAgICAgICAgIG9uRW5kKGUuY2xpZW50WCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b3VjaEV2ZW50cyA9IHtcbiAgICAgICAgICBtb3ZlSGFuZGxlcjogZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTW92ZShlLnRvdWNoZXNbMF0uY2xpZW50WCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB1cEhhbmRsZXI6IGUgPT4ge1xuICAgICAgICAgICAgdmFyIF9lJHRvdWNoZXMkO1xuICAgICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNoRXZlbnRzLm1vdmVIYW5kbGVyKTtcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoRXZlbnRzLnVwSGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uRW5kKChfZSR0b3VjaGVzJCA9IGUudG91Y2hlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lJHRvdWNoZXMkLmNsaWVudFgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFzc2l2ZUlmU3VwcG9ydGVkID0gcGFzc2l2ZUV2ZW50U3VwcG9ydGVkKCkgPyB7XG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSA6IGZhbHNlO1xuICAgICAgICBpZiAoaXNUb3VjaFN0YXJ0RXZlbnQoZSkpIHtcbiAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdG91Y2hFdmVudHMubW92ZUhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hFdmVudHMudXBIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZUV2ZW50cy5tb3ZlSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlRXZlbnRzLnVwSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiAoe1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBzdGFydE9mZnNldDogY2xpZW50WCxcbiAgICAgICAgICBzdGFydFNpemUsXG4gICAgICAgICAgZGVsdGFPZmZzZXQ6IDAsXG4gICAgICAgICAgZGVsdGFQZXJjZW50YWdlOiAwLFxuICAgICAgICAgIGNvbHVtblNpemluZ1N0YXJ0LFxuICAgICAgICAgIGlzUmVzaXppbmdDb2x1bW46IGNvbHVtbi5pZFxuICAgICAgICB9KSk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8gPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5TaXppbmdJbmZvQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtblNpemluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjO1xuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5TaXppbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldEhlYWRlclNpemVJbmZvID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMyO1xuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjMiA9IHRhYmxlLmluaXRpYWxTdGF0ZS5jb2x1bW5TaXppbmdJbmZvKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjMiA6IGdldERlZmF1bHRDb2x1bW5TaXppbmdJbmZvU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldEhlYWRlckdyb3VwLCBfdGFibGUkZ2V0SGVhZGVyR3JvdXAyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0SGVhZGVyR3JvdXAgPSAoX3RhYmxlJGdldEhlYWRlckdyb3VwMiA9IHRhYmxlLmdldEhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldEhlYWRlckdyb3VwMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRIZWFkZXJHcm91cCA6IDA7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRMZWZ0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRMZWZ0SGVhZGVyRywgX3RhYmxlJGdldExlZnRIZWFkZXJHMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldExlZnRIZWFkZXJHID0gKF90YWJsZSRnZXRMZWZ0SGVhZGVyRzIgPSB0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0TGVmdEhlYWRlckcyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldExlZnRIZWFkZXJHIDogMDtcbiAgICB9O1xuICAgIHRhYmxlLmdldENlbnRlclRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0Q2VudGVySGVhZGUsIF90YWJsZSRnZXRDZW50ZXJIZWFkZTI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRDZW50ZXJIZWFkZSA9IChfdGFibGUkZ2V0Q2VudGVySGVhZGUyID0gdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKClbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q2VudGVySGVhZGUyLmhlYWRlcnMucmVkdWNlKChzdW0sIGhlYWRlcikgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgaGVhZGVyLmdldFNpemUoKTtcbiAgICAgIH0sIDApKSAhPSBudWxsID8gX3RhYmxlJGdldENlbnRlckhlYWRlIDogMDtcbiAgICB9O1xuICAgIHRhYmxlLmdldFJpZ2h0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRSaWdodEhlYWRlciwgX3RhYmxlJGdldFJpZ2h0SGVhZGVyMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFJpZ2h0SGVhZGVyID0gKF90YWJsZSRnZXRSaWdodEhlYWRlcjIgPSB0YWJsZS5nZXRSaWdodEhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFJpZ2h0SGVhZGVyMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRSaWdodEhlYWRlciA6IDA7XG4gICAgfTtcbiAgfVxufTtcbmxldCBwYXNzaXZlU3VwcG9ydGVkID0gbnVsbDtcbmZ1bmN0aW9uIHBhc3NpdmVFdmVudFN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiBwYXNzaXZlU3VwcG9ydGVkID09PSAnYm9vbGVhbicpIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xuICBsZXQgc3VwcG9ydGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBub29wID0gKCkgPT4ge307XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBub29wLCBvcHRpb25zKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG5vb3ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuICBwYXNzaXZlU3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn1cbmZ1bmN0aW9uIGlzVG91Y2hTdGFydEV2ZW50KGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ3RvdWNoc3RhcnQnO1xufVxuXG4vL1xuXG5jb25zdCBDb2x1bW5WaXNpYmlsaXR5ID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uVmlzaWJpbGl0eToge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uVmlzaWJpbGl0eScsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eSA9IHZhbHVlID0+IHtcbiAgICAgIGlmIChjb2x1bW4uZ2V0Q2FuSGlkZSgpKSB7XG4gICAgICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkob2xkID0+ICh7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIFtjb2x1bW4uaWRdOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiAhY29sdW1uLmdldElzVmlzaWJsZSgpXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbHVtbi5nZXRJc1Zpc2libGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX3RhYmxlJGdldFN0YXRlJGNvbHVtO1xuICAgICAgY29uc3QgY2hpbGRDb2x1bW5zID0gY29sdW1uLmNvbHVtbnM7XG4gICAgICByZXR1cm4gKF9yZWYgPSBjaGlsZENvbHVtbnMubGVuZ3RoID8gY2hpbGRDb2x1bW5zLnNvbWUoYyA9PiBjLmdldElzVmlzaWJsZSgpKSA6IChfdGFibGUkZ2V0U3RhdGUkY29sdW0gPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW1bY29sdW1uLmlkXSkgIT0gbnVsbCA/IF9yZWYgOiB0cnVlO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbkhpZGUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUhpZGluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVIaWRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkgPT0gbnVsbCB8fCBjb2x1bW4udG9nZ2xlVmlzaWJpbGl0eShlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93LmdldEFsbENlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uVmlzaWJpbGl0eV0sIGNlbGxzID0+IHtcbiAgICAgIHJldHVybiBjZWxscy5maWx0ZXIoY2VsbCA9PiBjZWxsLmNvbHVtbi5nZXRJc1Zpc2libGUoKSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdfZ2V0QWxsVmlzaWJsZUNlbGxzJykpO1xuICAgIHJvdy5nZXRWaXNpYmxlQ2VsbHMgPSBtZW1vKCgpID0+IFtyb3cuZ2V0TGVmdFZpc2libGVDZWxscygpLCByb3cuZ2V0Q2VudGVyVmlzaWJsZUNlbGxzKCksIHJvdy5nZXRSaWdodFZpc2libGVDZWxscygpXSwgKGxlZnQsIGNlbnRlciwgcmlnaHQpID0+IFsuLi5sZWZ0LCAuLi5jZW50ZXIsIC4uLnJpZ2h0XSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRWaXNpYmxlQ2VsbHMnKSk7XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgY29uc3QgbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kID0gKGtleSwgZ2V0Q29sdW1ucykgPT4ge1xuICAgICAgcmV0dXJuIG1lbW8oKCkgPT4gW2dldENvbHVtbnMoKSwgZ2V0Q29sdW1ucygpLmZpbHRlcihkID0+IGQuZ2V0SXNWaXNpYmxlKCkpLm1hcChkID0+IGQuaWQpLmpvaW4oJ18nKV0sIGNvbHVtbnMgPT4ge1xuICAgICAgICByZXR1cm4gY29sdW1ucy5maWx0ZXIoZCA9PiBkLmdldElzVmlzaWJsZSA9PSBudWxsID8gdm9pZCAwIDogZC5nZXRJc1Zpc2libGUoKSk7XG4gICAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywga2V5KSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRWaXNpYmxlRmxhdENvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldFZpc2libGVGbGF0Q29sdW1ucycsICgpID0+IHRhYmxlLmdldEFsbEZsYXRDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0VmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldExlZnRMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRSaWdodExlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldENlbnRlclZpc2libGVMZWFmQ29sdW1ucyA9IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCgnZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0Q2VudGVyTGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eSA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblZpc2liaWxpdHlDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Q29sdW1uVmlzaWJpbGl0eSA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjO1xuICAgICAgdGFibGUuc2V0Q29sdW1uVmlzaWJpbGl0eShkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uVmlzaWJpbGl0eSkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYyA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlID0gdmFsdWUgPT4ge1xuICAgICAgdmFyIF92YWx1ZTtcbiAgICAgIHZhbHVlID0gKF92YWx1ZSA9IHZhbHVlKSAhPSBudWxsID8gX3ZhbHVlIDogIXRhYmxlLmdldElzQWxsQ29sdW1uc1Zpc2libGUoKTtcbiAgICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkodGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5yZWR1Y2UoKG9iaiwgY29sdW1uKSA9PiAoe1xuICAgICAgICAuLi5vYmosXG4gICAgICAgIFtjb2x1bW4uaWRdOiAhdmFsdWUgPyAhKGNvbHVtbi5nZXRDYW5IaWRlICE9IG51bGwgJiYgY29sdW1uLmdldENhbkhpZGUoKSkgOiB2YWx1ZVxuICAgICAgfSksIHt9KSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc0FsbENvbHVtbnNWaXNpYmxlID0gKCkgPT4gIXRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkuc29tZShjb2x1bW4gPT4gIShjb2x1bW4uZ2V0SXNWaXNpYmxlICE9IG51bGwgJiYgY29sdW1uLmdldElzVmlzaWJsZSgpKSk7XG4gICAgdGFibGUuZ2V0SXNTb21lQ29sdW1uc1Zpc2libGUgPSAoKSA9PiB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnNvbWUoY29sdW1uID0+IGNvbHVtbi5nZXRJc1Zpc2libGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRJc1Zpc2libGUoKSk7XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsQ29sdW1uc1Zpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB2YXIgX3RhcmdldDtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsQ29sdW1uc1Zpc2libGUoKF90YXJnZXQgPSBlLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbikge1xuICByZXR1cm4gIXBvc2l0aW9uID8gdGFibGUuZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKCkgOiBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgPyB0YWJsZS5nZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMoKSA6IHBvc2l0aW9uID09PSAnbGVmdCcgPyB0YWJsZS5nZXRMZWZ0VmlzaWJsZUxlYWZDb2x1bW5zKCkgOiB0YWJsZS5nZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucygpO1xufVxuXG4vL1xuXG5jb25zdCBHbG9iYWxGYWNldGluZyA9IHtcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwodGFibGUsICdfX2dsb2JhbF9fJyk7XG4gICAgdGFibGUuZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsRmlsdGVyaW5nIHx8ICF0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzKHRhYmxlLCAnX19nbG9iYWxfXycpO1xuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRVbmlxdWVWYWx1ZXMoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKTtcbiAgICB9O1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBHbG9iYWxGaWx0ZXJpbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnbG9iYWxGaWx0ZXI6IHVuZGVmaW5lZCxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25HbG9iYWxGaWx0ZXJDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2dsb2JhbEZpbHRlcicsIHRhYmxlKSxcbiAgICAgIGdsb2JhbEZpbHRlckZuOiAnYXV0bycsXG4gICAgICBnZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXI6IGNvbHVtbiA9PiB7XG4gICAgICAgIHZhciBfdGFibGUkZ2V0Q29yZVJvd01vZGU7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gKF90YWJsZSRnZXRDb3JlUm93TW9kZSA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0Q29yZVJvd01vZGUgPSBfdGFibGUkZ2V0Q29yZVJvd01vZGUuX2dldEFsbENlbGxzQnlDb2x1bW5JZCgpW2NvbHVtbi5pZF0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29yZVJvd01vZGUuZ2V0VmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldENhbkdsb2JhbEZpbHRlciA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRlbmEsIF90YWJsZSRvcHRpb25zJGVuYWJsZSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiwgX3RhYmxlJG9wdGlvbnMkZ2V0Q29sO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVHbG9iYWxGaWx0ZXIpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlR2xvYmFsRmlsdGVyKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVGaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZ2V0Q29sID0gdGFibGUub3B0aW9ucy5nZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyKGNvbHVtbikpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRDb2wgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuZ2V0R2xvYmFsQXV0b0ZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGZpbHRlckZucy5pbmNsdWRlc1N0cmluZztcbiAgICB9O1xuICAgIHRhYmxlLmdldEdsb2JhbEZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGZpbHRlciwgX3RhYmxlJG9wdGlvbnMkZmlsdGVyMjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZ2xvYmFsRmlsdGVyRm46IGdsb2JhbEZpbHRlckZuXG4gICAgICB9ID0gdGFibGUub3B0aW9ucztcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGdsb2JhbEZpbHRlckZuKSA/IGdsb2JhbEZpbHRlckZuIDogZ2xvYmFsRmlsdGVyRm4gPT09ICdhdXRvJyA/IHRhYmxlLmdldEdsb2JhbEF1dG9GaWx0ZXJGbigpIDogKF90YWJsZSRvcHRpb25zJGZpbHRlciA9IChfdGFibGUkb3B0aW9ucyRmaWx0ZXIyID0gdGFibGUub3B0aW9ucy5maWx0ZXJGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRmaWx0ZXIyW2dsb2JhbEZpbHRlckZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGZpbHRlciA6IGZpbHRlckZuc1tnbG9iYWxGaWx0ZXJGbl07XG4gICAgfTtcbiAgICB0YWJsZS5zZXRHbG9iYWxGaWx0ZXIgPSB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25HbG9iYWxGaWx0ZXJDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uR2xvYmFsRmlsdGVyQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRHbG9iYWxGaWx0ZXIgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdGFibGUuc2V0R2xvYmFsRmlsdGVyKGRlZmF1bHRTdGF0ZSA/IHVuZGVmaW5lZCA6IHRhYmxlLmluaXRpYWxTdGF0ZS5nbG9iYWxGaWx0ZXIpO1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IFJvd0V4cGFuZGluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cGFuZGVkOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25FeHBhbmRlZENoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignZXhwYW5kZWQnLCB0YWJsZSksXG4gICAgICBwYWdpbmF0ZUV4cGFuZGVkUm93czogdHJ1ZVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBsZXQgcXVldWVkID0gZmFsc2U7XG4gICAgdGFibGUuX2F1dG9SZXNldEV4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF90YWJsZSRvcHRpb25zJGF1dG9SZTtcbiAgICAgIGlmICghcmVnaXN0ZXJlZCkge1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHJlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGF1dG9SZSA9IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0QWxsKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkYXV0b1JlIDogdGFibGUub3B0aW9ucy5hdXRvUmVzZXRFeHBhbmRlZCkgIT0gbnVsbCA/IF9yZWYgOiAhdGFibGUub3B0aW9ucy5tYW51YWxFeHBhbmRpbmcpIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0RXhwYW5kZWQoKTtcbiAgICAgICAgICBxdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0YWJsZS5zZXRFeHBhbmRlZCA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkV4cGFuZGVkQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uRXhwYW5kZWRDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUudG9nZ2xlQWxsUm93c0V4cGFuZGVkID0gZXhwYW5kZWQgPT4ge1xuICAgICAgaWYgKGV4cGFuZGVkICE9IG51bGwgPyBleHBhbmRlZCA6ICF0YWJsZS5nZXRJc0FsbFJvd3NFeHBhbmRlZCgpKSB7XG4gICAgICAgIHRhYmxlLnNldEV4cGFuZGVkKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGUuc2V0RXhwYW5kZWQoe30pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUucmVzZXRFeHBhbmRlZCA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRlLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0RXhwYW5kZWQoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRlID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmV4cGFuZGVkKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRlIDoge30pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0Q2FuU29tZVJvd3NFeHBhbmQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3Muc29tZShyb3cgPT4gcm93LmdldENhbkV4cGFuZCgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFJvd3NFeHBhbmRlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxSb3dzRXhwYW5kZWQoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBleHBhbmRlZCA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQ7XG4gICAgICByZXR1cm4gZXhwYW5kZWQgPT09IHRydWUgfHwgT2JqZWN0LnZhbHVlcyhleHBhbmRlZCkuc29tZShCb29sZWFuKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsUm93c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuXG4gICAgICAvLyBJZiBleHBhbmRlZCBpcyB0cnVlLCBzYXZlIHNvbWUgY3ljbGVzIGFuZCByZXR1cm4gdHJ1ZVxuICAgICAgaWYgKHR5cGVvZiBleHBhbmRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRlZCA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghT2JqZWN0LmtleXMoZXhwYW5kZWQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFueSByb3cgaXMgbm90IGV4cGFuZGVkLCByZXR1cm4gZmFsc2VcbiAgICAgIGlmICh0YWJsZS5nZXRSb3dNb2RlbCgpLmZsYXRSb3dzLnNvbWUocm93ID0+ICFyb3cuZ2V0SXNFeHBhbmRlZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZXkgbXVzdCBhbGwgYmUgZXhwYW5kZWQgOnNocnVnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRFeHBhbmRlZERlcHRoID0gKCkgPT4ge1xuICAgICAgbGV0IG1heERlcHRoID0gMDtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQgPT09IHRydWUgPyBPYmplY3Qua2V5cyh0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3NCeUlkKSA6IE9iamVjdC5rZXlzKHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWQpO1xuICAgICAgcm93SWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICBjb25zdCBzcGxpdElkID0gaWQuc3BsaXQoJy4nKTtcbiAgICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgc3BsaXRJZC5sZW5ndGgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF4RGVwdGg7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0U29ydGVkUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRFeHBhbmRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldEV4cGFuZGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsRXhwYW5kaW5nIHx8ICF0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy50b2dnbGVFeHBhbmRlZCA9IGV4cGFuZGVkID0+IHtcbiAgICAgIHRhYmxlLnNldEV4cGFuZGVkKG9sZCA9PiB7XG4gICAgICAgIHZhciBfZXhwYW5kZWQ7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IG9sZCA9PT0gdHJ1ZSA/IHRydWUgOiAhIShvbGQgIT0gbnVsbCAmJiBvbGRbcm93LmlkXSk7XG4gICAgICAgIGxldCBvbGRFeHBhbmRlZCA9IHt9O1xuICAgICAgICBpZiAob2xkID09PSB0cnVlKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXModGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzQnlJZCkuZm9yRWFjaChyb3dJZCA9PiB7XG4gICAgICAgICAgICBvbGRFeHBhbmRlZFtyb3dJZF0gPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZEV4cGFuZGVkID0gb2xkO1xuICAgICAgICB9XG4gICAgICAgIGV4cGFuZGVkID0gKF9leHBhbmRlZCA9IGV4cGFuZGVkKSAhPSBudWxsID8gX2V4cGFuZGVkIDogIWV4aXN0cztcbiAgICAgICAgaWYgKCFleGlzdHMgJiYgZXhwYW5kZWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ub2xkRXhwYW5kZWQsXG4gICAgICAgICAgICBbcm93LmlkXTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4aXN0cyAmJiAhZXhwYW5kZWQpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBbcm93LmlkXTogXyxcbiAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgICB9ID0gb2xkRXhwYW5kZWQ7XG4gICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldElzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0SXNSO1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuICAgICAgcmV0dXJuICEhKChfdGFibGUkb3B0aW9ucyRnZXRJc1IgPSB0YWJsZS5vcHRpb25zLmdldElzUm93RXhwYW5kZWQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0SXNSb3dFeHBhbmRlZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0SXNSIDogZXhwYW5kZWQgPT09IHRydWUgfHwgKGV4cGFuZGVkID09IG51bGwgPyB2b2lkIDAgOiBleHBhbmRlZFtyb3cuaWRdKSk7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuRXhwYW5kID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldFJvdywgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfcm93JHN1YlJvd3M7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGdldFJvdyA9IHRhYmxlLm9wdGlvbnMuZ2V0Um93Q2FuRXhwYW5kID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldFJvd0NhbkV4cGFuZChyb3cpKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Um93IDogKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUV4cGFuZGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICEhKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoKTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc0FsbFBhcmVudHNFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGxldCBpc0Z1bGx5RXhwYW5kZWQgPSB0cnVlO1xuICAgICAgbGV0IGN1cnJlbnRSb3cgPSByb3c7XG4gICAgICB3aGlsZSAoaXNGdWxseUV4cGFuZGVkICYmIGN1cnJlbnRSb3cucGFyZW50SWQpIHtcbiAgICAgICAgY3VycmVudFJvdyA9IHRhYmxlLmdldFJvdyhjdXJyZW50Um93LnBhcmVudElkLCB0cnVlKTtcbiAgICAgICAgaXNGdWxseUV4cGFuZGVkID0gY3VycmVudFJvdy5nZXRJc0V4cGFuZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdWxseUV4cGFuZGVkO1xuICAgIH07XG4gICAgcm93LmdldFRvZ2dsZUV4cGFuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbkV4cGFuZCA9IHJvdy5nZXRDYW5FeHBhbmQoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmICghY2FuRXhwYW5kKSByZXR1cm47XG4gICAgICAgIHJvdy50b2dnbGVFeHBhbmRlZCgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBkZWZhdWx0UGFnZUluZGV4ID0gMDtcbmNvbnN0IGRlZmF1bHRQYWdlU2l6ZSA9IDEwO1xuY29uc3QgZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSA9ICgpID0+ICh7XG4gIHBhZ2VJbmRleDogZGVmYXVsdFBhZ2VJbmRleCxcbiAgcGFnZVNpemU6IGRlZmF1bHRQYWdlU2l6ZVxufSk7XG5jb25zdCBSb3dQYWdpbmF0aW9uID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgIC4uLmdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUoKSxcbiAgICAgICAgLi4uKHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5wYWdpbmF0aW9uKVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUGFnaW5hdGlvbkNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncGFnaW5hdGlvbicsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgbGV0IHJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBsZXQgcXVldWVkID0gZmFsc2U7XG4gICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfdGFibGUkb3B0aW9ucyRhdXRvUmU7XG4gICAgICBpZiAoIXJlZ2lzdGVyZWQpIHtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICByZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoX3JlZiA9IChfdGFibGUkb3B0aW9ucyRhdXRvUmUgPSB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEFsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGF1dG9SZSA6IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0UGFnZUluZGV4KSAhPSBudWxsID8gX3JlZiA6ICF0YWJsZS5vcHRpb25zLm1hbnVhbFBhZ2luYXRpb24pIHtcbiAgICAgICAgaWYgKHF1ZXVlZCkgcmV0dXJuO1xuICAgICAgICBxdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0YWJsZS5fcXVldWUoKCkgPT4ge1xuICAgICAgICAgIHRhYmxlLnJlc2V0UGFnZUluZGV4KCk7XG4gICAgICAgICAgcXVldWVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUuc2V0UGFnaW5hdGlvbiA9IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3Qgc2FmZVVwZGF0ZXIgPSBvbGQgPT4ge1xuICAgICAgICBsZXQgbmV3U3RhdGUgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZCk7XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5vblBhZ2luYXRpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlKHNhZmVVcGRhdGVyKTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnaW5hdGlvbiA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRwO1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRwID0gdGFibGUuaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHAgOiBnZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuc2V0UGFnZUluZGV4ID0gdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5zZXRQYWdpbmF0aW9uKG9sZCA9PiB7XG4gICAgICAgIGxldCBwYWdlSW5kZXggPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZC5wYWdlSW5kZXgpO1xuICAgICAgICBjb25zdCBtYXhQYWdlSW5kZXggPSB0eXBlb2YgdGFibGUub3B0aW9ucy5wYWdlQ291bnQgPT09ICd1bmRlZmluZWQnIHx8IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50ID09PSAtMSA/IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIDogdGFibGUub3B0aW9ucy5wYWdlQ291bnQgLSAxO1xuICAgICAgICBwYWdlSW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSW5kZXgsIG1heFBhZ2VJbmRleCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBwYWdlSW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRQYWdlSW5kZXggPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDIsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRQYWdlSW5kZXgoZGVmYXVsdFN0YXRlID8gZGVmYXVsdFBhZ2VJbmRleCA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAyID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgfHwgKF90YWJsZSRpbml0aWFsU3RhdGUgPSBfdGFibGUkaW5pdGlhbFN0YXRlLnBhZ2luYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLnBhZ2VJbmRleCkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcDIgOiBkZWZhdWx0UGFnZUluZGV4KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnZVNpemUgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDMsIF90YWJsZSRpbml0aWFsU3RhdGUyO1xuICAgICAgdGFibGUuc2V0UGFnZVNpemUoZGVmYXVsdFN0YXRlID8gZGVmYXVsdFBhZ2VTaXplIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcDMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZTIgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgfHwgKF90YWJsZSRpbml0aWFsU3RhdGUyID0gX3RhYmxlJGluaXRpYWxTdGF0ZTIucGFnaW5hdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUyLnBhZ2VTaXplKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwMyA6IGRlZmF1bHRQYWdlU2l6ZSk7XG4gICAgfTtcbiAgICB0YWJsZS5zZXRQYWdlU2l6ZSA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IE1hdGgubWF4KDEsIGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkLnBhZ2VTaXplKSk7XG4gICAgICAgIGNvbnN0IHRvcFJvd0luZGV4ID0gb2xkLnBhZ2VTaXplICogb2xkLnBhZ2VJbmRleDtcbiAgICAgICAgY29uc3QgcGFnZUluZGV4ID0gTWF0aC5mbG9vcih0b3BSb3dJbmRleCAvIHBhZ2VTaXplKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgcGFnZUluZGV4LFxuICAgICAgICAgIHBhZ2VTaXplXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vZGVwcmVjYXRlZFxuICAgIHRhYmxlLnNldFBhZ2VDb3VudCA9IHVwZGF0ZXIgPT4gdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHBhZ2VDbztcbiAgICAgIGxldCBuZXdQYWdlQ291bnQgPSBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIChfdGFibGUkb3B0aW9ucyRwYWdlQ28gPSB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHBhZ2VDbyA6IC0xKTtcbiAgICAgIGlmICh0eXBlb2YgbmV3UGFnZUNvdW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICBuZXdQYWdlQ291bnQgPSBNYXRoLm1heCgtMSwgbmV3UGFnZUNvdW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9sZCxcbiAgICAgICAgcGFnZUNvdW50OiBuZXdQYWdlQ291bnRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdGFibGUuZ2V0UGFnZU9wdGlvbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRQYWdlQ291bnQoKV0sIHBhZ2VDb3VudCA9PiB7XG4gICAgICBsZXQgcGFnZU9wdGlvbnMgPSBbXTtcbiAgICAgIGlmIChwYWdlQ291bnQgJiYgcGFnZUNvdW50ID4gMCkge1xuICAgICAgICBwYWdlT3B0aW9ucyA9IFsuLi5uZXcgQXJyYXkocGFnZUNvdW50KV0uZmlsbChudWxsKS5tYXAoKF8sIGkpID0+IGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VPcHRpb25zO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFBhZ2VPcHRpb25zJykpO1xuICAgIHRhYmxlLmdldENhblByZXZpb3VzUGFnZSA9ICgpID0+IHRhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbi5wYWdlSW5kZXggPiAwO1xuICAgIHRhYmxlLmdldENhbk5leHRQYWdlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYWdlSW5kZXhcbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb247XG4gICAgICBjb25zdCBwYWdlQ291bnQgPSB0YWJsZS5nZXRQYWdlQ291bnQoKTtcbiAgICAgIGlmIChwYWdlQ291bnQgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFnZUluZGV4IDwgcGFnZUNvdW50IC0gMTtcbiAgICB9O1xuICAgIHRhYmxlLnByZXZpb3VzUGFnZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRQYWdlSW5kZXgob2xkID0+IG9sZCAtIDEpO1xuICAgIH07XG4gICAgdGFibGUubmV4dFBhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KG9sZCA9PiB7XG4gICAgICAgIHJldHVybiBvbGQgKyAxO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS5maXJzdFBhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KDApO1xuICAgIH07XG4gICAgdGFibGUubGFzdFBhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KHRhYmxlLmdldFBhZ2VDb3VudCgpIC0gMSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRFeHBhbmRlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0UGFnaW5hdGlvblJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRQYWdpbmF0aW9uUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldFBhZ2luYXRpb25Sb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxQYWdpbmF0aW9uIHx8ICF0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsKCk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQYWdlQ291bnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkcGFnZUNvMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiA9IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiA6IE1hdGguY2VpbCh0YWJsZS5nZXRSb3dDb3VudCgpIC8gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLnBhZ2VTaXplKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFJvd0NvdW50ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHJvd0NvdTtcbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkcm93Q291ID0gdGFibGUub3B0aW9ucy5yb3dDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHJvd0NvdSA6IHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLnJvd3MubGVuZ3RoO1xuICAgIH07XG4gIH1cbn07XG5cbi8vXG5cbmNvbnN0IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUgPSAoKSA9PiAoe1xuICB0b3A6IFtdLFxuICBib3R0b206IFtdXG59KTtcbmNvbnN0IFJvd1Bpbm5pbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByb3dQaW5uaW5nOiBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUm93UGlubmluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncm93UGlubmluZycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cucGluID0gKHBvc2l0aW9uLCBpbmNsdWRlTGVhZlJvd3MsIGluY2x1ZGVQYXJlbnRSb3dzKSA9PiB7XG4gICAgICBjb25zdCBsZWFmUm93SWRzID0gaW5jbHVkZUxlYWZSb3dzID8gcm93LmdldExlYWZSb3dzKCkubWFwKF9yZWYgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KSA6IFtdO1xuICAgICAgY29uc3QgcGFyZW50Um93SWRzID0gaW5jbHVkZVBhcmVudFJvd3MgPyByb3cuZ2V0UGFyZW50Um93cygpLm1hcChfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KSA6IFtdO1xuICAgICAgY29uc3Qgcm93SWRzID0gbmV3IFNldChbLi4ucGFyZW50Um93SWRzLCByb3cuaWQsIC4uLmxlYWZSb3dJZHNdKTtcbiAgICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcob2xkID0+IHtcbiAgICAgICAgdmFyIF9vbGQkdG9wMywgX29sZCRib3R0b20zO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdmFyIF9vbGQkdG9wLCBfb2xkJGJvdHRvbTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiAoKF9vbGQkdG9wID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksXG4gICAgICAgICAgICBib3R0b206IFsuLi4oKF9vbGQkYm90dG9tID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20gOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSksIC4uLkFycmF5LmZyb20ocm93SWRzKV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB2YXIgX29sZCR0b3AyLCBfb2xkJGJvdHRvbTI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogWy4uLigoX29sZCR0b3AyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AyIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLCAuLi5BcnJheS5mcm9tKHJvd0lkcyldLFxuICAgICAgICAgICAgYm90dG9tOiAoKF9vbGQkYm90dG9tMiA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmJvdHRvbSkgIT0gbnVsbCA/IF9vbGQkYm90dG9tMiA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6ICgoX29sZCR0b3AzID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQudG9wKSAhPSBudWxsID8gX29sZCR0b3AzIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLFxuICAgICAgICAgIGJvdHRvbTogKChfb2xkJGJvdHRvbTMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbTMgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcm93LmdldENhblBpbiA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmMztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5hYmxlUm93UGlubmluZyxcbiAgICAgICAgZW5hYmxlUGlubmluZ1xuICAgICAgfSA9IHRhYmxlLm9wdGlvbnM7XG4gICAgICBpZiAodHlwZW9mIGVuYWJsZVJvd1Bpbm5pbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZVJvd1Bpbm5pbmcocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3JlZjMgPSBlbmFibGVSb3dQaW5uaW5nICE9IG51bGwgPyBlbmFibGVSb3dQaW5uaW5nIDogZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9yZWYzIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc1Bpbm5lZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IFtyb3cuaWRdO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbVxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZztcbiAgICAgIGNvbnN0IGlzVG9wID0gcm93SWRzLnNvbWUoZCA9PiB0b3AgPT0gbnVsbCA/IHZvaWQgMCA6IHRvcC5pbmNsdWRlcyhkKSk7XG4gICAgICBjb25zdCBpc0JvdHRvbSA9IHJvd0lkcy5zb21lKGQgPT4gYm90dG9tID09IG51bGwgPyB2b2lkIDAgOiBib3R0b20uaW5jbHVkZXMoZCkpO1xuICAgICAgcmV0dXJuIGlzVG9wID8gJ3RvcCcgOiBpc0JvdHRvbSA/ICdib3R0b20nIDogZmFsc2U7XG4gICAgfTtcbiAgICByb3cuZ2V0UGlubmVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZjQsIF92aXNpYmxlUGlubmVkUm93SWRzJDtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcm93LmdldElzUGlubmVkKCk7XG4gICAgICBpZiAoIXBvc2l0aW9uKSByZXR1cm4gLTE7XG4gICAgICBjb25zdCB2aXNpYmxlUGlubmVkUm93SWRzID0gKF9yZWY0ID0gcG9zaXRpb24gPT09ICd0b3AnID8gdGFibGUuZ2V0VG9wUm93cygpIDogdGFibGUuZ2V0Qm90dG9tUm93cygpKSA9PSBudWxsID8gdm9pZCAwIDogX3JlZjQubWFwKF9yZWY1ID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjU7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIChfdmlzaWJsZVBpbm5lZFJvd0lkcyQgPSB2aXNpYmxlUGlubmVkUm93SWRzID09IG51bGwgPyB2b2lkIDAgOiB2aXNpYmxlUGlubmVkUm93SWRzLmluZGV4T2Yocm93LmlkKSkgIT0gbnVsbCA/IF92aXNpYmxlUGlubmVkUm93SWRzJCA6IC0xO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0Um93UGlubmluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vblJvd1Bpbm5pbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Sb3dQaW5uaW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0Um93UGlubmluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRyLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFJvd1Bpbm5pbmcoZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkciA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5yb3dQaW5uaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRyIDogZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVJvd3NQaW5uZWQgPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvO1xuICAgICAgY29uc3QgcGlubmluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dQaW5uaW5nO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICB2YXIgX3Bpbm5pbmdTdGF0ZSR0b3AsIF9waW5uaW5nU3RhdGUkYm90dG9tO1xuICAgICAgICByZXR1cm4gQm9vbGVhbigoKF9waW5uaW5nU3RhdGUkdG9wID0gcGlubmluZ1N0YXRlLnRvcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkdG9wLmxlbmd0aCkgfHwgKChfcGlubmluZ1N0YXRlJGJvdHRvbSA9IHBpbm5pbmdTdGF0ZS5ib3R0b20pID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJGJvdHRvbS5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCb29sZWFuKChfcGlubmluZ1N0YXRlJHBvc2l0aW8gPSBwaW5uaW5nU3RhdGVbcG9zaXRpb25dKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvLmxlbmd0aCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0UGlubmVkUm93cyA9ICh2aXNpYmxlUm93cywgcGlubmVkUm93SWRzLCBwb3NpdGlvbikgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGtlZXBQaTtcbiAgICAgIGNvbnN0IHJvd3MgPSAoKF90YWJsZSRvcHRpb25zJGtlZXBQaSA9IHRhYmxlLm9wdGlvbnMua2VlcFBpbm5lZFJvd3MpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRrZWVwUGkgOiB0cnVlKSA/XG4gICAgICAvL2dldCBhbGwgcm93cyB0aGF0IGFyZSBwaW5uZWQgZXZlbiBpZiB0aGV5IHdvdWxkIG5vdCBiZSBvdGhlcndpc2UgdmlzaWJsZVxuICAgICAgLy9hY2NvdW50IGZvciBleHBhbmRlZCBwYXJlbnQgcm93cywgYnV0IG5vdCBwYWdpbmF0aW9uIG9yIGZpbHRlcmluZ1xuICAgICAgKHBpbm5lZFJvd0lkcyAhPSBudWxsID8gcGlubmVkUm93SWRzIDogW10pLm1hcChyb3dJZCA9PiB7XG4gICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhyb3dJZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByb3cuZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQoKSA/IHJvdyA6IG51bGw7XG4gICAgICB9KSA6XG4gICAgICAvL2Vsc2UgZ2V0IG9ubHkgdmlzaWJsZSByb3dzIHRoYXQgYXJlIHBpbm5lZFxuICAgICAgKHBpbm5lZFJvd0lkcyAhPSBudWxsID8gcGlubmVkUm93SWRzIDogW10pLm1hcChyb3dJZCA9PiB2aXNpYmxlUm93cy5maW5kKHJvdyA9PiByb3cuaWQgPT09IHJvd0lkKSk7XG4gICAgICByZXR1cm4gcm93cy5maWx0ZXIoQm9vbGVhbikubWFwKGQgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIH0pKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvcFJvd3MgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy50b3BdLCAoYWxsUm93cywgdG9wUGlubmVkUm93SWRzKSA9PiB0YWJsZS5fZ2V0UGlubmVkUm93cyhhbGxSb3dzLCB0b3BQaW5uZWRSb3dJZHMsICd0b3AnKSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRUb3BSb3dzJykpO1xuICAgIHRhYmxlLmdldEJvdHRvbVJvd3MgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy5ib3R0b21dLCAoYWxsUm93cywgYm90dG9tUGlubmVkUm93SWRzKSA9PiB0YWJsZS5fZ2V0UGlubmVkUm93cyhhbGxSb3dzLCBib3R0b21QaW5uZWRSb3dJZHMsICdib3R0b20nKSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRCb3R0b21Sb3dzJykpO1xuICAgIHRhYmxlLmdldENlbnRlclJvd3MgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy50b3AsIHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZy5ib3R0b21dLCAoYWxsUm93cywgdG9wLCBib3R0b20pID0+IHtcbiAgICAgIGNvbnN0IHRvcEFuZEJvdHRvbSA9IG5ldyBTZXQoWy4uLih0b3AgIT0gbnVsbCA/IHRvcCA6IFtdKSwgLi4uKGJvdHRvbSAhPSBudWxsID8gYm90dG9tIDogW10pXSk7XG4gICAgICByZXR1cm4gYWxsUm93cy5maWx0ZXIoZCA9PiAhdG9wQW5kQm90dG9tLmhhcyhkLmlkKSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRDZW50ZXJSb3dzJykpO1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBSb3dTZWxlY3Rpb24gPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByb3dTZWxlY3Rpb246IHt9LFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblJvd1NlbGVjdGlvbkNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcigncm93U2VsZWN0aW9uJywgdGFibGUpLFxuICAgICAgZW5hYmxlUm93U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb246IHRydWUsXG4gICAgICBlbmFibGVTdWJSb3dTZWxlY3Rpb246IHRydWVcbiAgICAgIC8vIGVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uOiBmYWxzZSxcbiAgICAgIC8vIGlzQWRkaXRpdmVTZWxlY3RFdmVudDogKGU6IHVua25vd24pID0+ICEhZS5tZXRhS2V5LFxuICAgICAgLy8gaXNJbmNsdXNpdmVTZWxlY3RFdmVudDogKGU6IHVua25vd24pID0+ICEhZS5zaGlmdEtleSxcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbiA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vblJvd1NlbGVjdGlvbkNoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vblJvd1NlbGVjdGlvbkNoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldFJvd1NlbGVjdGlvbiA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRyO1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFJvd1NlbGVjdGlvbihkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHIgPSB0YWJsZS5pbml0aWFsU3RhdGUucm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRyIDoge30pO1xuICAgIH07XG4gICAgdGFibGUudG9nZ2xlQWxsUm93c1NlbGVjdGVkID0gdmFsdWUgPT4ge1xuICAgICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIXRhYmxlLmdldElzQWxsUm93c1NlbGVjdGVkKCk7XG4gICAgICAgIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHtcbiAgICAgICAgICAuLi5vbGRcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJlR3JvdXBlZEZsYXRSb3dzID0gdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCkuZmxhdFJvd3M7XG5cbiAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIGBtdXRhdGVSb3dJc1NlbGVjdGVkYCBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuICAgICAgICAvLyBBbGwgb2YgdGhlIHJvd3MgYXJlIGZsYXQgYWxyZWFkeSwgc28gaXQgd291bGRuJ3QgYmUgd29ydGggaXRcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgcHJlR3JvdXBlZEZsYXRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGlmICghcm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd1NlbGVjdGlvbltyb3cuaWRdID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmVHcm91cGVkRmxhdFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHJvd1NlbGVjdGlvbltyb3cuaWRdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dTZWxlY3Rpb247XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLnRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQgPSB2YWx1ZSA9PiB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkVmFsdWUgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkKCk7XG4gICAgICBjb25zdCByb3dTZWxlY3Rpb24gPSB7XG4gICAgICAgIC4uLm9sZFxuICAgICAgfTtcbiAgICAgIHRhYmxlLmdldFJvd01vZGVsKCkucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIG11dGF0ZVJvd0lzU2VsZWN0ZWQocm93U2VsZWN0aW9uLCByb3cuaWQsIHJlc29sdmVkVmFsdWUsIHRydWUsIHRhYmxlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJvd1NlbGVjdGlvbjtcbiAgICB9KTtcblxuICAgIC8vIGFkZFJvd1NlbGVjdGlvblJhbmdlOiByb3dJZCA9PiB7XG4gICAgLy8gICBjb25zdCB7XG4gICAgLy8gICAgIHJvd3MsXG4gICAgLy8gICAgIHJvd3NCeUlkLFxuICAgIC8vICAgICBvcHRpb25zOiB7IHNlbGVjdEdyb3VwaW5nUm93cywgc2VsZWN0U3ViUm93cyB9LFxuICAgIC8vICAgfSA9IHRhYmxlXG5cbiAgICAvLyAgIGNvbnN0IGZpbmRTZWxlY3RlZFJvdyA9IChyb3dzOiBSb3dbXSkgPT4ge1xuICAgIC8vICAgICBsZXQgZm91bmRcbiAgICAvLyAgICAgcm93cy5maW5kKGQgPT4ge1xuICAgIC8vICAgICAgIGlmIChkLmdldElzU2VsZWN0ZWQoKSkge1xuICAgIC8vICAgICAgICAgZm91bmQgPSBkXG4gICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgICBjb25zdCBzdWJGb3VuZCA9IGZpbmRTZWxlY3RlZFJvdyhkLnN1YlJvd3MgfHwgW10pXG4gICAgLy8gICAgICAgaWYgKHN1YkZvdW5kKSB7XG4gICAgLy8gICAgICAgICBmb3VuZCA9IHN1YkZvdW5kXG4gICAgLy8gICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgICByZXR1cm4gZmFsc2VcbiAgICAvLyAgICAgfSlcbiAgICAvLyAgICAgcmV0dXJuIGZvdW5kXG4gICAgLy8gICB9XG5cbiAgICAvLyAgIGNvbnN0IGZpcnN0Um93ID0gZmluZFNlbGVjdGVkUm93KHJvd3MpIHx8IHJvd3NbMF1cbiAgICAvLyAgIGNvbnN0IGxhc3RSb3cgPSByb3dzQnlJZFtyb3dJZF1cblxuICAgIC8vICAgbGV0IGluY2x1ZGUgPSBmYWxzZVxuICAgIC8vICAgY29uc3Qgc2VsZWN0ZWRSb3dJZHMgPSB7fVxuXG4gICAgLy8gICBjb25zdCBhZGRSb3cgPSAocm93OiBSb3cpID0+IHtcbiAgICAvLyAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB0cnVlLCB7XG4gICAgLy8gICAgICAgcm93c0J5SWQsXG4gICAgLy8gICAgICAgc2VsZWN0R3JvdXBpbmdSb3dzOiBzZWxlY3RHcm91cGluZ1Jvd3MhLFxuICAgIC8vICAgICAgIHNlbGVjdFN1YlJvd3M6IHNlbGVjdFN1YlJvd3MhLFxuICAgIC8vICAgICB9KVxuICAgIC8vICAgfVxuXG4gICAgLy8gICB0YWJsZS5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAvLyAgICAgY29uc3QgaXNGaXJzdFJvdyA9IHJvdy5pZCA9PT0gZmlyc3RSb3cuaWRcbiAgICAvLyAgICAgY29uc3QgaXNMYXN0Um93ID0gcm93LmlkID09PSBsYXN0Um93LmlkXG5cbiAgICAvLyAgICAgaWYgKGlzRmlyc3RSb3cgfHwgaXNMYXN0Um93KSB7XG4gICAgLy8gICAgICAgaWYgKCFpbmNsdWRlKSB7XG4gICAgLy8gICAgICAgICBpbmNsdWRlID0gdHJ1ZVxuICAgIC8vICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZSkge1xuICAgIC8vICAgICAgICAgYWRkUm93KHJvdylcbiAgICAvLyAgICAgICAgIGluY2x1ZGUgPSBmYWxzZVxuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgfVxuXG4gICAgLy8gICAgIGlmIChpbmNsdWRlKSB7XG4gICAgLy8gICAgICAgYWRkUm93KHJvdylcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfSlcblxuICAgIC8vICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKHNlbGVjdGVkUm93SWRzKVxuICAgIC8vIH0sXG4gICAgdGFibGUuZ2V0UHJlU2VsZWN0ZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldFNlbGVjdGVkUm93TW9kZWwgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0Q29yZVJvd01vZGVsKCldLCAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICByb3dzQnlJZDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRTZWxlY3RlZFJvd01vZGVsJykpO1xuICAgIHRhYmxlLmdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uLCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCldLCAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICByb3dzQnlJZDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwnKSk7XG4gICAgdGFibGUuZ2V0R3JvdXBlZFNlbGVjdGVkUm93TW9kZWwgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0U29ydGVkUm93TW9kZWwoKV0sIChyb3dTZWxlY3Rpb24sIHJvd01vZGVsKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHJvd1NlbGVjdGlvbikubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm93czogW10sXG4gICAgICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgICAgIHJvd3NCeUlkOiB7fVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsJykpO1xuXG4gICAgLy8vXG5cbiAgICAvLyBnZXRHcm91cGluZ1Jvd0NhblNlbGVjdDogcm93SWQgPT4ge1xuICAgIC8vICAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KHJvd0lkKVxuXG4gICAgLy8gICBpZiAoIXJvdykge1xuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICAgIC8vICAgfVxuXG4gICAgLy8gICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24ocm93KVxuICAgIC8vICAgfVxuXG4gICAgLy8gICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbiA/PyBmYWxzZVxuICAgIC8vIH0sXG5cbiAgICB0YWJsZS5nZXRJc0FsbFJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHByZUdyb3VwZWRGbGF0Um93cyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIGxldCBpc0FsbFJvd3NTZWxlY3RlZCA9IEJvb2xlYW4ocHJlR3JvdXBlZEZsYXRSb3dzLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCk7XG4gICAgICBpZiAoaXNBbGxSb3dzU2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKHByZUdyb3VwZWRGbGF0Um93cy5zb21lKHJvdyA9PiByb3cuZ2V0Q2FuU2VsZWN0KCkgJiYgIXJvd1NlbGVjdGlvbltyb3cuaWRdKSkge1xuICAgICAgICAgIGlzQWxsUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FsbFJvd3NTZWxlY3RlZDtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25GbGF0Um93cyA9IHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzLmZpbHRlcihyb3cgPT4gcm93LmdldENhblNlbGVjdCgpKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIGxldCBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSAhIXBhZ2luYXRpb25GbGF0Um93cy5sZW5ndGg7XG4gICAgICBpZiAoaXNBbGxQYWdlUm93c1NlbGVjdGVkICYmIHBhZ2luYXRpb25GbGF0Um93cy5zb21lKHJvdyA9PiAhcm93U2VsZWN0aW9uW3Jvdy5pZF0pKSB7XG4gICAgICAgIGlzQWxsUGFnZVJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQWxsUGFnZVJvd3NTZWxlY3RlZDtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVJvd3NTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkcm93U2U7XG4gICAgICBjb25zdCB0b3RhbFNlbGVjdGVkID0gT2JqZWN0LmtleXMoKF90YWJsZSRnZXRTdGF0ZSRyb3dTZSA9IHRhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJHJvd1NlIDoge30pLmxlbmd0aDtcbiAgICAgIHJldHVybiB0b3RhbFNlbGVjdGVkID4gMCAmJiB0b3RhbFNlbGVjdGVkIDwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzLmxlbmd0aDtcbiAgICB9O1xuICAgIHRhYmxlLmdldElzU29tZVBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uRmxhdFJvd3MgPSB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cztcbiAgICAgIHJldHVybiB0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQoKSA/IGZhbHNlIDogcGFnaW5hdGlvbkZsYXRSb3dzLmZpbHRlcihyb3cgPT4gcm93LmdldENhblNlbGVjdCgpKS5zb21lKGQgPT4gZC5nZXRJc1NlbGVjdGVkKCkgfHwgZC5nZXRJc1NvbWVTZWxlY3RlZCgpKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZChlLnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlUm93OiAocm93LCB0YWJsZSkgPT4ge1xuICAgIHJvdy50b2dnbGVTZWxlY3RlZCA9ICh2YWx1ZSwgb3B0cykgPT4ge1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHJvdy5nZXRJc1NlbGVjdGVkKCk7XG4gICAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24ob2xkID0+IHtcbiAgICAgICAgdmFyIF9vcHRzJHNlbGVjdENoaWxkcmVuO1xuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICFpc1NlbGVjdGVkO1xuICAgICAgICBpZiAocm93LmdldENhblNlbGVjdCgpICYmIGlzU2VsZWN0ZWQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3RlZFJvd0lkcyA9IHtcbiAgICAgICAgICAuLi5vbGRcbiAgICAgICAgfTtcbiAgICAgICAgbXV0YXRlUm93SXNTZWxlY3RlZChzZWxlY3RlZFJvd0lkcywgcm93LmlkLCB2YWx1ZSwgKF9vcHRzJHNlbGVjdENoaWxkcmVuID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5zZWxlY3RDaGlsZHJlbikgIT0gbnVsbCA/IF9vcHRzJHNlbGVjdENoaWxkcmVuIDogdHJ1ZSwgdGFibGUpO1xuICAgICAgICByZXR1cm4gc2VsZWN0ZWRSb3dJZHM7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGlzUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pO1xuICAgIH07XG4gICAgcm93LmdldElzU29tZVNlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGlzU3ViUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pID09PSAnc29tZSc7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNBbGxTdWJSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICByZXR1cm4gaXNTdWJSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbikgPT09ICdhbGwnO1xuICAgIH07XG4gICAgcm93LmdldENhblNlbGVjdCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbihyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuU2VsZWN0U3ViUm93cyA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xuICAgICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24ocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0Q2FuTXVsdGlTZWxlY3QgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMztcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbihyb3cpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRlbmFibGUzID0gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTMgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldFRvZ2dsZVNlbGVjdGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhblNlbGVjdCA9IHJvdy5nZXRDYW5TZWxlY3QoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdmFyIF90YXJnZXQ7XG4gICAgICAgIGlmICghY2FuU2VsZWN0KSByZXR1cm47XG4gICAgICAgIHJvdy50b2dnbGVTZWxlY3RlZCgoX3RhcmdldCA9IGUudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldC5jaGVja2VkKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IG11dGF0ZVJvd0lzU2VsZWN0ZWQgPSAoc2VsZWN0ZWRSb3dJZHMsIGlkLCB2YWx1ZSwgaW5jbHVkZUNoaWxkcmVuLCB0YWJsZSkgPT4ge1xuICB2YXIgX3JvdyRzdWJSb3dzO1xuICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3coaWQsIHRydWUpO1xuXG4gIC8vIGNvbnN0IGlzR3JvdXBlZCA9IHJvdy5nZXRJc0dyb3VwZWQoKVxuXG4gIC8vIGlmICggLy8gVE9ETzogZW5mb3JjZSBncm91cGluZyByb3cgc2VsZWN0aW9uIHJ1bGVzXG4gIC8vICAgIWlzR3JvdXBlZCB8fFxuICAvLyAgIChpc0dyb3VwZWQgJiYgdGFibGUub3B0aW9ucy5lbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbilcbiAgLy8gKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghcm93LmdldENhbk11bHRpU2VsZWN0KCkpIHtcbiAgICAgIE9iamVjdC5rZXlzKHNlbGVjdGVkUm93SWRzKS5mb3JFYWNoKGtleSA9PiBkZWxldGUgc2VsZWN0ZWRSb3dJZHNba2V5XSk7XG4gICAgfVxuICAgIGlmIChyb3cuZ2V0Q2FuU2VsZWN0KCkpIHtcbiAgICAgIHNlbGVjdGVkUm93SWRzW2lkXSA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBzZWxlY3RlZFJvd0lkc1tpZF07XG4gIH1cbiAgLy8gfVxuXG4gIGlmIChpbmNsdWRlQ2hpbGRyZW4gJiYgKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgcm93LmdldENhblNlbGVjdFN1YlJvd3MoKSkge1xuICAgIHJvdy5zdWJSb3dzLmZvckVhY2gocm93ID0+IG11dGF0ZVJvd0lzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dJZHMsIHJvdy5pZCwgdmFsdWUsIGluY2x1ZGVDaGlsZHJlbiwgdGFibGUpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHNlbGVjdFJvd3NGbih0YWJsZSwgcm93TW9kZWwpIHtcbiAgY29uc3Qgcm93U2VsZWN0aW9uID0gdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb247XG4gIGNvbnN0IG5ld1NlbGVjdGVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3U2VsZWN0ZWRSb3dzQnlJZCA9IHt9O1xuXG4gIC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xuICBjb25zdCByZWN1cnNlUm93cyA9IGZ1bmN0aW9uIChyb3dzLCBkZXB0aCkge1xuICAgIHJldHVybiByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgdmFyIF9yb3ckc3ViUm93czI7XG4gICAgICBjb25zdCBpc1NlbGVjdGVkID0gaXNSb3dTZWxlY3RlZChyb3csIHJvd1NlbGVjdGlvbik7XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICBuZXdTZWxlY3RlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3U2VsZWN0ZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgfVxuICAgICAgaWYgKChfcm93JHN1YlJvd3MyID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMi5sZW5ndGgpIHtcbiAgICAgICAgcm93ID0ge1xuICAgICAgICAgIC4uLnJvdyxcbiAgICAgICAgICBzdWJSb3dzOiByZWN1cnNlUm93cyhyb3cuc3ViUm93cylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VSb3dzKHJvd01vZGVsLnJvd3MpLFxuICAgIGZsYXRSb3dzOiBuZXdTZWxlY3RlZEZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiBuZXdTZWxlY3RlZFJvd3NCeUlkXG4gIH07XG59XG5mdW5jdGlvbiBpc1Jvd1NlbGVjdGVkKHJvdywgc2VsZWN0aW9uKSB7XG4gIHZhciBfc2VsZWN0aW9uJHJvdyRpZDtcbiAgcmV0dXJuIChfc2VsZWN0aW9uJHJvdyRpZCA9IHNlbGVjdGlvbltyb3cuaWRdKSAhPSBudWxsID8gX3NlbGVjdGlvbiRyb3ckaWQgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzU3ViUm93U2VsZWN0ZWQocm93LCBzZWxlY3Rpb24sIHRhYmxlKSB7XG4gIHZhciBfcm93JHN1YlJvd3MzO1xuICBpZiAoISgoX3JvdyRzdWJSb3dzMyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93czMubGVuZ3RoKSkgcmV0dXJuIGZhbHNlO1xuICBsZXQgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IHRydWU7XG4gIGxldCBzb21lU2VsZWN0ZWQgPSBmYWxzZTtcbiAgcm93LnN1YlJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xuICAgIC8vIEJhaWwgb3V0IGVhcmx5IGlmIHdlIGtub3cgYm90aCBvZiB0aGVzZVxuICAgIGlmIChzb21lU2VsZWN0ZWQgJiYgIWFsbENoaWxkcmVuU2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN1YlJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgaWYgKGlzUm93U2VsZWN0ZWQoc3ViUm93LCBzZWxlY3Rpb24pKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxDaGlsZHJlblNlbGVjdGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgcm93IHNlbGVjdGlvbiBvZiBuZXN0ZWQgc3Vicm93c1xuICAgIGlmIChzdWJSb3cuc3ViUm93cyAmJiBzdWJSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN1YlJvd0NoaWxkcmVuU2VsZWN0ZWQgPSBpc1N1YlJvd1NlbGVjdGVkKHN1YlJvdywgc2VsZWN0aW9uKTtcbiAgICAgIGlmIChzdWJSb3dDaGlsZHJlblNlbGVjdGVkID09PSAnYWxsJykge1xuICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdWJSb3dDaGlsZHJlblNlbGVjdGVkID09PSAnc29tZScpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhbGxDaGlsZHJlblNlbGVjdGVkID8gJ2FsbCcgOiBzb21lU2VsZWN0ZWQgPyAnc29tZScgOiBmYWxzZTtcbn1cblxuY29uc3QgcmVTcGxpdEFscGhhTnVtZXJpYyA9IC8oWzAtOV0rKS9nbTtcbmNvbnN0IGFscGhhbnVtZXJpYyA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUFscGhhbnVtZXJpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCkpO1xufTtcbmNvbnN0IGFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmUgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVBbHBoYW51bWVyaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkpO1xufTtcblxuLy8gVGhlIHRleHQgZmlsdGVyIGlzIG1vcmUgYmFzaWMgKGxlc3MgbnVtZXJpYyBzdXBwb3J0KVxuLy8gYnV0IGlzIG11Y2ggZmFzdGVyXG5jb25zdCB0ZXh0ID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQmFzaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpKTtcbn07XG5cbi8vIFRoZSB0ZXh0IGZpbHRlciBpcyBtb3JlIGJhc2ljIChsZXNzIG51bWVyaWMgc3VwcG9ydClcbi8vIGJ1dCBpcyBtdWNoIGZhc3RlclxuY29uc3QgdGV4dENhc2VTZW5zaXRpdmUgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyh0b1N0cmluZyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKSk7XG59O1xuY29uc3QgZGF0ZXRpbWUgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgY29uc3QgYSA9IHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICBjb25zdCBiID0gcm93Qi5nZXRWYWx1ZShjb2x1bW5JZCk7XG5cbiAgLy8gQ2FuIGhhbmRsZSBudWxsaXNoIHZhbHVlc1xuICAvLyBVc2UgPiBhbmQgPCBiZWNhdXNlID09IChhbmQgPT09KSBkb2Vzbid0IHdvcmsgd2l0aFxuICAvLyBEYXRlIG9iamVjdHMgKHdvdWxkIHJlcXVpcmUgY2FsbGluZyBnZXRUaW1lKCkpLlxuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDA7XG59O1xuY29uc3QgYmFzaWMgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVCYXNpYyhyb3dBLmdldFZhbHVlKGNvbHVtbklkKSwgcm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpO1xufTtcblxuLy8gVXRpbHNcblxuZnVuY3Rpb24gY29tcGFyZUJhc2ljKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhhKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoaXNOYU4oYSkgfHwgYSA9PT0gSW5maW5pdHkgfHwgYSA9PT0gLUluZmluaXR5KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLy8gTWl4ZWQgc29ydGluZyBpcyBzbG93LCBidXQgdmVyeSBpbmNsdXNpdmUgb2YgbWFueSBlZGdlIGNhc2VzLlxuLy8gSXQgaGFuZGxlcyBudW1iZXJzLCBtaXhlZCBhbHBoYW51bWVyaWMgY29tYmluYXRpb25zLCBhbmQgZXZlblxuLy8gbnVsbCwgdW5kZWZpbmVkLCBhbmQgSW5maW5pdHlcbmZ1bmN0aW9uIGNvbXBhcmVBbHBoYW51bWVyaWMoYVN0ciwgYlN0cikge1xuICAvLyBTcGxpdCBvbiBudW1iZXIgZ3JvdXBzLCBidXQga2VlcCB0aGUgZGVsaW1pdGVyXG4gIC8vIFRoZW4gcmVtb3ZlIGZhbHNleSBzcGxpdCB2YWx1ZXNcbiAgY29uc3QgYSA9IGFTdHIuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBiID0gYlN0ci5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgLy8gV2hpbGVcbiAgd2hpbGUgKGEubGVuZ3RoICYmIGIubGVuZ3RoKSB7XG4gICAgY29uc3QgYWEgPSBhLnNoaWZ0KCk7XG4gICAgY29uc3QgYmIgPSBiLnNoaWZ0KCk7XG4gICAgY29uc3QgYW4gPSBwYXJzZUludChhYSwgMTApO1xuICAgIGNvbnN0IGJuID0gcGFyc2VJbnQoYmIsIDEwKTtcbiAgICBjb25zdCBjb21ibyA9IFthbiwgYm5dLnNvcnQoKTtcblxuICAgIC8vIEJvdGggYXJlIHN0cmluZ1xuICAgIGlmIChpc05hTihjb21ib1swXSkpIHtcbiAgICAgIGlmIChhYSA+IGJiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgaWYgKGJiID4gYWEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gT25lIGlzIGEgc3RyaW5nLCBvbmUgaXMgYSBudW1iZXJcbiAgICBpZiAoaXNOYU4oY29tYm9bMV0pKSB7XG4gICAgICByZXR1cm4gaXNOYU4oYW4pID8gLTEgOiAxO1xuICAgIH1cblxuICAgIC8vIEJvdGggYXJlIG51bWJlcnNcbiAgICBpZiAoYW4gPiBibikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChibiA+IGFuKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xufVxuXG4vLyBFeHBvcnRzXG5cbmNvbnN0IHNvcnRpbmdGbnMgPSB7XG4gIGFscGhhbnVtZXJpYyxcbiAgYWxwaGFudW1lcmljQ2FzZVNlbnNpdGl2ZSxcbiAgdGV4dCxcbiAgdGV4dENhc2VTZW5zaXRpdmUsXG4gIGRhdGV0aW1lLFxuICBiYXNpY1xufTtcblxuLy9cblxuY29uc3QgUm93U29ydGluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvcnRpbmc6IFtdLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNvcnRpbmdGbjogJ2F1dG8nLFxuICAgICAgc29ydFVuZGVmaW5lZDogMVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uU29ydGluZ0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignc29ydGluZycsIHRhYmxlKSxcbiAgICAgIGlzTXVsdGlTb3J0RXZlbnQ6IGUgPT4ge1xuICAgICAgICByZXR1cm4gZS5zaGlmdEtleTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldEF1dG9Tb3J0aW5nRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvd3MgPSB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3Muc2xpY2UoMTApO1xuICAgICAgbGV0IGlzU3RyaW5nID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiBmaXJzdFJvd3MpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMuZGF0ZXRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpc1N0cmluZyA9IHRydWU7XG4gICAgICAgICAgaWYgKHZhbHVlLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0aW5nRm5zLmFscGhhbnVtZXJpYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICByZXR1cm4gc29ydGluZ0Zucy50ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNvcnRpbmdGbnMuYmFzaWM7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QXV0b1NvcnREaXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93c1swXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmlyc3RSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0Um93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gJ2FzYyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ2Rlc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldFNvcnRpbmdGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRzb3J0aW4sIF90YWJsZSRvcHRpb25zJHNvcnRpbjI7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuIDogY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvU29ydGluZ0ZuKCkgOiAoX3RhYmxlJG9wdGlvbnMkc29ydGluID0gKF90YWJsZSRvcHRpb25zJHNvcnRpbjIgPSB0YWJsZS5vcHRpb25zLnNvcnRpbmdGbnMpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkb3B0aW9ucyRzb3J0aW4yW2NvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHNvcnRpbiA6IHNvcnRpbmdGbnNbY29sdW1uLmNvbHVtbkRlZi5zb3J0aW5nRm5dO1xuICAgIH07XG4gICAgY29sdW1uLnRvZ2dsZVNvcnRpbmcgPSAoZGVzYywgbXVsdGkpID0+IHtcbiAgICAgIC8vIGlmIChjb2x1bW4uY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIC8vICAgY29sdW1uLmNvbHVtbnMuZm9yRWFjaCgoYywgaSkgPT4ge1xuICAgICAgLy8gICAgIGlmIChjLmlkKSB7XG4gICAgICAvLyAgICAgICB0YWJsZS50b2dnbGVDb2x1bW5Tb3J0aW5nKGMuaWQsIHVuZGVmaW5lZCwgbXVsdGkgfHwgISFpKVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfSlcbiAgICAgIC8vICAgcmV0dXJuXG4gICAgICAvLyB9XG5cbiAgICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgb3V0c2lkZSBvZiB0YWJsZS5zZXRTb3J0aW5nIHRvIGJlIGluIHN5bmMgd2l0aCByZXJlbmRlclxuICAgICAgY29uc3QgbmV4dFNvcnRpbmdPcmRlciA9IGNvbHVtbi5nZXROZXh0U29ydGluZ09yZGVyKCk7XG4gICAgICBjb25zdCBoYXNNYW51YWxWYWx1ZSA9IHR5cGVvZiBkZXNjICE9PSAndW5kZWZpbmVkJyAmJiBkZXNjICE9PSBudWxsO1xuICAgICAgdGFibGUuc2V0U29ydGluZyhvbGQgPT4ge1xuICAgICAgICAvLyBGaW5kIGFueSBleGlzdGluZyBzb3J0aW5nIGZvciB0aGlzIGNvbHVtblxuICAgICAgICBjb25zdCBleGlzdGluZ1NvcnRpbmcgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJbmRleCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICAgIGxldCBuZXdTb3J0aW5nID0gW107XG5cbiAgICAgICAgLy8gV2hhdCBzaG91bGQgd2UgZG8gd2l0aCB0aGlzIHNvcnQgYWN0aW9uP1xuICAgICAgICBsZXQgc29ydEFjdGlvbjtcbiAgICAgICAgbGV0IG5leHREZXNjID0gaGFzTWFudWFsVmFsdWUgPyBkZXNjIDogbmV4dFNvcnRpbmdPcmRlciA9PT0gJ2Rlc2MnO1xuXG4gICAgICAgIC8vIE11bHRpLW1vZGVcbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggJiYgY29sdW1uLmdldENhbk11bHRpU29ydCgpICYmIG11bHRpKSB7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nU29ydGluZykge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICd0b2dnbGUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ2FkZCc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vcm1hbCBtb2RlXG4gICAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5sZW5ndGggJiYgZXhpc3RpbmdJbmRleCAhPT0gb2xkLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVwbGFjZSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1NvcnRpbmcpIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAndG9nZ2xlJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdyZXBsYWNlJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgdG9nZ2xlIHN0YXRlcyB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBzb3J0aW5nXG4gICAgICAgIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIC8vIElmIHdlIGFyZSBcImFjdHVhbGx5XCIgdG9nZ2xpbmcgKG5vdCBhIG1hbnVhbCBzZXQgdmFsdWUpLCBzaG91bGQgd2UgcmVtb3ZlIHRoZSBzb3J0aW5nP1xuICAgICAgICAgIGlmICghaGFzTWFudWFsVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElzIG91ciBpbnRlbnRpb24gdG8gcmVtb3ZlP1xuICAgICAgICAgICAgaWYgKCFuZXh0U29ydGluZ09yZGVyKSB7XG4gICAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVtb3ZlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvcnRBY3Rpb24gPT09ICdhZGQnKSB7XG4gICAgICAgICAgdmFyIF90YWJsZSRvcHRpb25zJG1heE11bDtcbiAgICAgICAgICBuZXdTb3J0aW5nID0gWy4uLm9sZCwge1xuICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICAgIGRlc2M6IG5leHREZXNjXG4gICAgICAgICAgfV07XG4gICAgICAgICAgLy8gVGFrZSBsYXRlc3QgbiBjb2x1bW5zXG4gICAgICAgICAgbmV3U29ydGluZy5zcGxpY2UoMCwgbmV3U29ydGluZy5sZW5ndGggLSAoKF90YWJsZSRvcHRpb25zJG1heE11bCA9IHRhYmxlLm9wdGlvbnMubWF4TXVsdGlTb3J0Q29sQ291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRtYXhNdWwgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpO1xuICAgICAgICB9IGVsc2UgaWYgKHNvcnRBY3Rpb24gPT09ICd0b2dnbGUnKSB7XG4gICAgICAgICAgLy8gVGhpcyBmbGlwcyAob3Igc2V0cykgdGhlXG4gICAgICAgICAgbmV3U29ydGluZyA9IG9sZC5tYXAoZCA9PiB7XG4gICAgICAgICAgICBpZiAoZC5pZCA9PT0gY29sdW1uLmlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uZCxcbiAgICAgICAgICAgICAgICBkZXNjOiBuZXh0RGVzY1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc29ydEFjdGlvbiA9PT0gJ3JlbW92ZScpIHtcbiAgICAgICAgICBuZXdTb3J0aW5nID0gb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3U29ydGluZyA9IFt7XG4gICAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U29ydGluZztcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpcnN0U29ydERpciA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfY29sdW1uJGNvbHVtbkRlZiRzb3I7XG4gICAgICBjb25zdCBzb3J0RGVzY0ZpcnN0ID0gKF9yZWYgPSAoX2NvbHVtbiRjb2x1bW5EZWYkc29yID0gY29sdW1uLmNvbHVtbkRlZi5zb3J0RGVzY0ZpcnN0KSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkc29yIDogdGFibGUub3B0aW9ucy5zb3J0RGVzY0ZpcnN0KSAhPSBudWxsID8gX3JlZiA6IGNvbHVtbi5nZXRBdXRvU29ydERpcigpID09PSAnZGVzYyc7XG4gICAgICByZXR1cm4gc29ydERlc2NGaXJzdCA/ICdkZXNjJyA6ICdhc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldE5leHRTb3J0aW5nT3JkZXIgPSBtdWx0aSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xuICAgICAgY29uc3QgZmlyc3RTb3J0RGlyZWN0aW9uID0gY29sdW1uLmdldEZpcnN0U29ydERpcigpO1xuICAgICAgY29uc3QgaXNTb3J0ZWQgPSBjb2x1bW4uZ2V0SXNTb3J0ZWQoKTtcbiAgICAgIGlmICghaXNTb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0U29ydERpcmVjdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NvcnRlZCAhPT0gZmlyc3RTb3J0RGlyZWN0aW9uICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVTb3J0aW5nUmVtb3ZhbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmIChcbiAgICAgIC8vIElmIGVuYWJsZVNvcnRSZW1vdmUsIGVuYWJsZSBpbiBnZW5lcmFsXG4gICAgICBtdWx0aSA/IChfdGFibGUkb3B0aW9ucyRlbmFibGUyID0gdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVJlbW92ZSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlIDogdHJ1ZSkgLy8gSWYgbXVsdGksIGRvbid0IGFsbG93IGlmIGVuYWJsZU11bHRpUmVtb3ZlKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTb3J0ZWQgPT09ICdkZXNjJyA/ICdhc2MnIDogJ2Rlc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhblNvcnQgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUzO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVTb3J0aW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUzID0gdGFibGUub3B0aW9ucy5lbmFibGVTb3J0aW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA6IHRydWUpICYmICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuTXVsdGlTb3J0ID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYyLCBfY29sdW1uJGNvbHVtbkRlZiRlbmEyO1xuICAgICAgcmV0dXJuIChfcmVmMiA9IChfY29sdW1uJGNvbHVtbkRlZiRlbmEyID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVNdWx0aVNvcnQpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEyIDogdGFibGUub3B0aW9ucy5lbmFibGVNdWx0aVNvcnQpICE9IG51bGwgPyBfcmVmMiA6ICEhY29sdW1uLmFjY2Vzc29yRm47XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNTb3J0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJHNvcnRpO1xuICAgICAgY29uc3QgY29sdW1uU29ydCA9IChfdGFibGUkZ2V0U3RhdGUkc29ydGkgPSB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkc29ydGkuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICByZXR1cm4gIWNvbHVtblNvcnQgPyBmYWxzZSA6IGNvbHVtblNvcnQuZGVzYyA/ICdkZXNjJyA6ICdhc2MnO1xuICAgIH07XG4gICAgY29sdW1uLmdldFNvcnRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkc29ydGkyLCBfdGFibGUkZ2V0U3RhdGUkc29ydGkzO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0U3RhdGUkc29ydGkyID0gKF90YWJsZSRnZXRTdGF0ZSRzb3J0aTMgPSB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkc29ydGkzLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCkpICE9IG51bGwgPyBfdGFibGUkZ2V0U3RhdGUkc29ydGkyIDogLTE7XG4gICAgfTtcbiAgICBjb2x1bW4uY2xlYXJTb3J0aW5nID0gKCkgPT4ge1xuICAgICAgLy9jbGVhciBzb3J0aW5nIGZvciBqdXN0IDEgY29sdW1uXG4gICAgICB0YWJsZS5zZXRTb3J0aW5nKG9sZCA9PiBvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoID8gb2xkLmZpbHRlcihkID0+IGQuaWQgIT09IGNvbHVtbi5pZCkgOiBbXSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0VG9nZ2xlU29ydGluZ0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5Tb3J0ID0gY29sdW1uLmdldENhblNvcnQoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgaWYgKCFjYW5Tb3J0KSByZXR1cm47XG4gICAgICAgIGUucGVyc2lzdCA9PSBudWxsIHx8IGUucGVyc2lzdCgpO1xuICAgICAgICBjb2x1bW4udG9nZ2xlU29ydGluZyA9PSBudWxsIHx8IGNvbHVtbi50b2dnbGVTb3J0aW5nKHVuZGVmaW5lZCwgY29sdW1uLmdldENhbk11bHRpU29ydCgpID8gdGFibGUub3B0aW9ucy5pc011bHRpU29ydEV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmlzTXVsdGlTb3J0RXZlbnQoZSkgOiBmYWxzZSk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuc2V0U29ydGluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vblNvcnRpbmdDaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Tb3J0aW5nQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnJlc2V0U29ydGluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRzLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0U29ydGluZyhkZWZhdWx0U3RhdGUgPyBbXSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHMgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUuc29ydGluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcyA6IFtdKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0R3JvdXBlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0U29ydGVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldFNvcnRlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0U29ydGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsU29ydGluZyB8fCAhdGFibGUuX2dldFNvcnRlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gIH1cbn07XG5cbmNvbnN0IGJ1aWx0SW5GZWF0dXJlcyA9IFtIZWFkZXJzLCBDb2x1bW5WaXNpYmlsaXR5LCBDb2x1bW5PcmRlcmluZywgQ29sdW1uUGlubmluZywgQ29sdW1uRmFjZXRpbmcsIENvbHVtbkZpbHRlcmluZywgR2xvYmFsRmFjZXRpbmcsXG4vL2RlcGVuZHMgb24gQ29sdW1uRmFjZXRpbmdcbkdsb2JhbEZpbHRlcmluZyxcbi8vZGVwZW5kcyBvbiBDb2x1bW5GaWx0ZXJpbmdcblJvd1NvcnRpbmcsIENvbHVtbkdyb3VwaW5nLFxuLy9kZXBlbmRzIG9uIFJvd1NvcnRpbmdcblJvd0V4cGFuZGluZywgUm93UGFnaW5hdGlvbiwgUm93UGlubmluZywgUm93U2VsZWN0aW9uLCBDb2x1bW5TaXppbmddO1xuXG4vL1xuXG5mdW5jdGlvbiBjcmVhdGVUYWJsZShvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRfZmVhdHVyZXMsIF9vcHRpb25zJGluaXRpYWxTdGF0ZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKG9wdGlvbnMuZGVidWdBbGwgfHwgb3B0aW9ucy5kZWJ1Z1RhYmxlKSkge1xuICAgIGNvbnNvbGUuaW5mbygnQ3JlYXRpbmcgVGFibGUgSW5zdGFuY2UuLi4nKTtcbiAgfVxuICBjb25zdCBfZmVhdHVyZXMgPSBbLi4uYnVpbHRJbkZlYXR1cmVzLCAuLi4oKF9vcHRpb25zJF9mZWF0dXJlcyA9IG9wdGlvbnMuX2ZlYXR1cmVzKSAhPSBudWxsID8gX29wdGlvbnMkX2ZlYXR1cmVzIDogW10pXTtcbiAgbGV0IHRhYmxlID0ge1xuICAgIF9mZWF0dXJlc1xuICB9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHRhYmxlLl9mZWF0dXJlcy5yZWR1Y2UoKG9iaiwgZmVhdHVyZSkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgZmVhdHVyZS5nZXREZWZhdWx0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogZmVhdHVyZS5nZXREZWZhdWx0T3B0aW9ucyh0YWJsZSkpO1xuICB9LCB7fSk7XG4gIGNvbnN0IG1lcmdlT3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICAgIGlmICh0YWJsZS5vcHRpb25zLm1lcmdlT3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMubWVyZ2VPcHRpb25zKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gIH07XG4gIGNvbnN0IGNvcmVJbml0aWFsU3RhdGUgPSB7fTtcbiAgbGV0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICAuLi5jb3JlSW5pdGlhbFN0YXRlLFxuICAgIC4uLigoX29wdGlvbnMkaW5pdGlhbFN0YXRlID0gb3B0aW9ucy5pbml0aWFsU3RhdGUpICE9IG51bGwgPyBfb3B0aW9ucyRpbml0aWFsU3RhdGUgOiB7fSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgdmFyIF9mZWF0dXJlJGdldEluaXRpYWxTdDtcbiAgICBpbml0aWFsU3RhdGUgPSAoX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0ID0gZmVhdHVyZS5nZXRJbml0aWFsU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0SW5pdGlhbFN0YXRlKGluaXRpYWxTdGF0ZSkpICE9IG51bGwgPyBfZmVhdHVyZSRnZXRJbml0aWFsU3QgOiBpbml0aWFsU3RhdGU7XG4gIH0pO1xuICBjb25zdCBxdWV1ZWQgPSBbXTtcbiAgbGV0IHF1ZXVlZFRpbWVvdXQgPSBmYWxzZTtcbiAgY29uc3QgY29yZUluc3RhbmNlID0ge1xuICAgIF9mZWF0dXJlcyxcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9LFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICBfcXVldWU6IGNiID0+IHtcbiAgICAgIHF1ZXVlZC5wdXNoKGNiKTtcbiAgICAgIGlmICghcXVldWVkVGltZW91dCkge1xuICAgICAgICBxdWV1ZWRUaW1lb3V0ID0gdHJ1ZTtcblxuICAgICAgICAvLyBTY2hlZHVsZSBhIG1pY3JvdGFzayB0byBydW4gdGhlIHF1ZXVlZCBjYWxsYmFja3MgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgY2FsbCBzdGFjayAocmVuZGVyLCBldGMpIGhhcyBmaW5pc2hlZC5cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgd2hpbGUgKHF1ZXVlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHF1ZXVlZC5zaGlmdCgpKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHF1ZXVlZFRpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRTdGF0ZSh0YWJsZS5pbml0aWFsU3RhdGUpO1xuICAgIH0sXG4gICAgc2V0T3B0aW9uczogdXBkYXRlciA9PiB7XG4gICAgICBjb25zdCBuZXdPcHRpb25zID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCB0YWJsZS5vcHRpb25zKTtcbiAgICAgIHRhYmxlLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgfSxcbiAgICBnZXRTdGF0ZTogKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuc3RhdGU7XG4gICAgfSxcbiAgICBzZXRTdGF0ZTogdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5vcHRpb25zLm9uU3RhdGVDaGFuZ2UgPT0gbnVsbCB8fCB0YWJsZS5vcHRpb25zLm9uU3RhdGVDaGFuZ2UodXBkYXRlcik7XG4gICAgfSxcbiAgICBfZ2V0Um93SWQ6IChyb3csIGluZGV4LCBwYXJlbnQpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRnZXRSb3c7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGdldFJvdyA9IHRhYmxlLm9wdGlvbnMuZ2V0Um93SWQgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMuZ2V0Um93SWQocm93LCBpbmRleCwgcGFyZW50KSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldFJvdyA6IGAke3BhcmVudCA/IFtwYXJlbnQuaWQsIGluZGV4XS5qb2luKCcuJykgOiBpbmRleH1gO1xuICAgIH0sXG4gICAgZ2V0Q29yZVJvd01vZGVsOiAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRDb3JlUm93TW9kZWwpIHtcbiAgICAgICAgdGFibGUuX2dldENvcmVSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0Q29yZVJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0Q29yZVJvd01vZGVsKCk7XG4gICAgfSxcbiAgICAvLyBUaGUgZmluYWwgY2FsbHMgc3RhcnQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgbW9kZWwsXG4gICAgLy8gZXhwYW5kZWQgcm93cywgd2hpY2ggdGhlbiB3b3JrIHRoZWlyIHdheSB1cFxuXG4gICAgZ2V0Um93TW9kZWw6ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKTtcbiAgICB9LFxuICAgIC8vaW4gbmV4dCB2ZXJzaW9uLCB3ZSBzaG91bGQganVzdCBwYXNzIGluIHRoZSByb3cgbW9kZWwgYXMgdGhlIG9wdGlvbmFsIDJuZCBhcmdcbiAgICBnZXRSb3c6IChpZCwgc2VhcmNoQWxsKSA9PiB7XG4gICAgICBsZXQgcm93ID0gKHNlYXJjaEFsbCA/IHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpIDogdGFibGUuZ2V0Um93TW9kZWwoKSkucm93c0J5SWRbaWRdO1xuICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgcm93ID0gdGFibGUuZ2V0Q29yZVJvd01vZGVsKCkucm93c0J5SWRbaWRdO1xuICAgICAgICBpZiAoIXJvdykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFJvdyBjb3VsZCBub3QgZmluZCByb3cgd2l0aCBJRDogJHtpZH1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3c7XG4gICAgfSxcbiAgICBfZ2V0RGVmYXVsdENvbHVtbkRlZjogbWVtbygoKSA9PiBbdGFibGUub3B0aW9ucy5kZWZhdWx0Q29sdW1uXSwgZGVmYXVsdENvbHVtbiA9PiB7XG4gICAgICB2YXIgX2RlZmF1bHRDb2x1bW47XG4gICAgICBkZWZhdWx0Q29sdW1uID0gKF9kZWZhdWx0Q29sdW1uID0gZGVmYXVsdENvbHVtbikgIT0gbnVsbCA/IF9kZWZhdWx0Q29sdW1uIDoge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWFkZXI6IHByb3BzID0+IHtcbiAgICAgICAgICBjb25zdCByZXNvbHZlZENvbHVtbkRlZiA9IHByb3BzLmhlYWRlci5jb2x1bW4uY29sdW1uRGVmO1xuICAgICAgICAgIGlmIChyZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkQ29sdW1uRGVmLmlkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZm9vdGVyOiBwcm9wcyA9PiBwcm9wcy5oZWFkZXIuY29sdW1uLmlkLFxuICAgICAgICBjZWxsOiBwcm9wcyA9PiB7XG4gICAgICAgICAgdmFyIF9wcm9wcyRyZW5kZXJWYWx1ZSR0bywgX3Byb3BzJHJlbmRlclZhbHVlO1xuICAgICAgICAgIHJldHVybiAoX3Byb3BzJHJlbmRlclZhbHVlJHRvID0gKF9wcm9wcyRyZW5kZXJWYWx1ZSA9IHByb3BzLnJlbmRlclZhbHVlKCkpID09IG51bGwgfHwgX3Byb3BzJHJlbmRlclZhbHVlLnRvU3RyaW5nID09IG51bGwgPyB2b2lkIDAgOiBfcHJvcHMkcmVuZGVyVmFsdWUudG9TdHJpbmcoKSkgIT0gbnVsbCA/IF9wcm9wcyRyZW5kZXJWYWx1ZSR0byA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC4uLnRhYmxlLl9mZWF0dXJlcy5yZWR1Y2UoKG9iaiwgZmVhdHVyZSkgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgZmVhdHVyZS5nZXREZWZhdWx0Q29sdW1uRGVmID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldERlZmF1bHRDb2x1bW5EZWYoKSk7XG4gICAgICAgIH0sIHt9KSxcbiAgICAgICAgLi4uZGVmYXVsdENvbHVtblxuICAgICAgfTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ19nZXREZWZhdWx0Q29sdW1uRGVmJykpLFxuICAgIF9nZXRDb2x1bW5EZWZzOiAoKSA9PiB0YWJsZS5vcHRpb25zLmNvbHVtbnMsXG4gICAgZ2V0QWxsQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuX2dldENvbHVtbkRlZnMoKV0sIGNvbHVtbkRlZnMgPT4ge1xuICAgICAgY29uc3QgcmVjdXJzZUNvbHVtbnMgPSBmdW5jdGlvbiAoY29sdW1uRGVmcywgcGFyZW50LCBkZXB0aCkge1xuICAgICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlcHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sdW1uRGVmcy5tYXAoY29sdW1uRGVmID0+IHtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjcmVhdGVDb2x1bW4odGFibGUsIGNvbHVtbkRlZiwgZGVwdGgsIHBhcmVudCk7XG4gICAgICAgICAgY29uc3QgZ3JvdXBpbmdDb2x1bW5EZWYgPSBjb2x1bW5EZWY7XG4gICAgICAgICAgY29sdW1uLmNvbHVtbnMgPSBncm91cGluZ0NvbHVtbkRlZi5jb2x1bW5zID8gcmVjdXJzZUNvbHVtbnMoZ3JvdXBpbmdDb2x1bW5EZWYuY29sdW1ucywgY29sdW1uLCBkZXB0aCArIDEpIDogW107XG4gICAgICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlY3Vyc2VDb2x1bW5zKGNvbHVtbkRlZnMpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsQ29sdW1ucycpKSxcbiAgICBnZXRBbGxGbGF0Q29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpXSwgYWxsQ29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gYWxsQ29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiB7XG4gICAgICAgIHJldHVybiBjb2x1bW4uZ2V0RmxhdENvbHVtbnMoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsRmxhdENvbHVtbnMnKSksXG4gICAgX2dldEFsbEZsYXRDb2x1bW5zQnlJZDogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsRmxhdENvbHVtbnMoKV0sIGZsYXRDb2x1bW5zID0+IHtcbiAgICAgIHJldHVybiBmbGF0Q29sdW1ucy5yZWR1Y2UoKGFjYywgY29sdW1uKSA9PiB7XG4gICAgICAgIGFjY1tjb2x1bW4uaWRdID0gY29sdW1uO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSwge30pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKG9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0QWxsRmxhdENvbHVtbnNCeUlkJykpLFxuICAgIGdldEFsbExlYWZDb2x1bW5zOiBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLl9nZXRPcmRlckNvbHVtbnNGbigpXSwgKGFsbENvbHVtbnMsIG9yZGVyQ29sdW1ucykgPT4ge1xuICAgICAgbGV0IGxlYWZDb2x1bW5zID0gYWxsQ29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKSk7XG4gICAgICByZXR1cm4gb3JkZXJDb2x1bW5zKGxlYWZDb2x1bW5zKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEFsbExlYWZDb2x1bW5zJykpLFxuICAgIGdldENvbHVtbjogY29sdW1uSWQgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuX2dldEFsbEZsYXRDb2x1bW5zQnlJZCgpW2NvbHVtbklkXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb2x1bW4pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW1RhYmxlXSBDb2x1bW4gd2l0aCBpZCAnJHtjb2x1bW5JZH0nIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbHVtbjtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24odGFibGUsIGNvcmVJbnN0YW5jZSk7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0YWJsZS5fZmVhdHVyZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IHRhYmxlLl9mZWF0dXJlc1tpbmRleF07XG4gICAgZmVhdHVyZSA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlVGFibGUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVRhYmxlKHRhYmxlKTtcbiAgfVxuICByZXR1cm4gdGFibGU7XG59XG5cbmZ1bmN0aW9uIGdldENvcmVSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLm9wdGlvbnMuZGF0YV0sIGRhdGEgPT4ge1xuICAgIGNvbnN0IHJvd01vZGVsID0ge1xuICAgICAgcm93czogW10sXG4gICAgICBmbGF0Um93czogW10sXG4gICAgICByb3dzQnlJZDoge31cbiAgICB9O1xuICAgIGNvbnN0IGFjY2Vzc1Jvd3MgPSBmdW5jdGlvbiAob3JpZ2luYWxSb3dzLCBkZXB0aCwgcGFyZW50Um93KSB7XG4gICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgICB9XG4gICAgICBjb25zdCByb3dzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yaWdpbmFsUm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBUaGlzIGNvdWxkIGJlIGFuIGV4cGVuc2l2ZSBjaGVjayBhdCBzY2FsZSwgc28gd2Ugc2hvdWxkIG1vdmUgaXQgc29tZXdoZXJlIGVsc2UsIGJ1dCB3aGVyZT9cbiAgICAgICAgLy8gaWYgKCFpZCkge1xuICAgICAgICAvLyAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoYGdldFJvd0lkIGV4cGVjdGVkIGFuIElELCBidXQgZ290ICR7aWR9YClcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBNYWtlIHRoZSByb3dcbiAgICAgICAgY29uc3Qgcm93ID0gY3JlYXRlUm93KHRhYmxlLCB0YWJsZS5fZ2V0Um93SWQob3JpZ2luYWxSb3dzW2ldLCBpLCBwYXJlbnRSb3cpLCBvcmlnaW5hbFJvd3NbaV0sIGksIGRlcHRoLCB1bmRlZmluZWQsIHBhcmVudFJvdyA9PSBudWxsID8gdm9pZCAwIDogcGFyZW50Um93LmlkKTtcblxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBpbiBhIGZsYXQgYXJyYXlcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAvLyBBbHNvIGtlZXAgdHJhY2sgb2YgZXZlcnkgcm93IGJ5IGl0cyBJRFxuICAgICAgICByb3dNb2RlbC5yb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAvLyBQdXNoIHRhYmxlIHJvdyBpbnRvIHBhcmVudFxuICAgICAgICByb3dzLnB1c2gocm93KTtcblxuICAgICAgICAvLyBHZXQgdGhlIG9yaWdpbmFsIHN1YnJvd3NcbiAgICAgICAgaWYgKHRhYmxlLm9wdGlvbnMuZ2V0U3ViUm93cykge1xuICAgICAgICAgIHZhciBfcm93JG9yaWdpbmFsU3ViUm93cztcbiAgICAgICAgICByb3cub3JpZ2luYWxTdWJSb3dzID0gdGFibGUub3B0aW9ucy5nZXRTdWJSb3dzKG9yaWdpbmFsUm93c1tpXSwgaSk7XG5cbiAgICAgICAgICAvLyBUaGVuIHJlY3Vyc2l2ZWx5IGFjY2VzcyB0aGVtXG4gICAgICAgICAgaWYgKChfcm93JG9yaWdpbmFsU3ViUm93cyA9IHJvdy5vcmlnaW5hbFN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRvcmlnaW5hbFN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByb3cuc3ViUm93cyA9IGFjY2Vzc1Jvd3Mocm93Lm9yaWdpbmFsU3ViUm93cywgZGVwdGggKyAxLCByb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfTtcbiAgICByb3dNb2RlbC5yb3dzID0gYWNjZXNzUm93cyhkYXRhKTtcbiAgICByZXR1cm4gcm93TW9kZWw7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFJvd01vZGVsJywgKCkgPT4gdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpKSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkLCB0YWJsZS5nZXRQcmVFeHBhbmRlZFJvd01vZGVsKCksIHRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3NdLCAoZXhwYW5kZWQsIHJvd01vZGVsLCBwYWdpbmF0ZUV4cGFuZGVkUm93cykgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgZXhwYW5kZWQgIT09IHRydWUgJiYgIU9iamVjdC5rZXlzKGV4cGFuZGVkICE9IG51bGwgPyBleHBhbmRlZCA6IHt9KS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgaWYgKCFwYWdpbmF0ZUV4cGFuZGVkUm93cykge1xuICAgICAgLy8gT25seSBleHBhbmQgcm93cyBhdCB0aGlzIHBvaW50IGlmIHRoZXkgYXJlIGJlaW5nIHBhZ2luYXRlZFxuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICByZXR1cm4gZXhwYW5kUm93cyhyb3dNb2RlbCk7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEV4cGFuZGVkUm93TW9kZWwnKSk7XG59XG5mdW5jdGlvbiBleHBhbmRSb3dzKHJvd01vZGVsKSB7XG4gIGNvbnN0IGV4cGFuZGVkUm93cyA9IFtdO1xuICBjb25zdCBoYW5kbGVSb3cgPSByb3cgPT4ge1xuICAgIHZhciBfcm93JHN1YlJvd3M7XG4gICAgZXhwYW5kZWRSb3dzLnB1c2gocm93KTtcbiAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGggJiYgcm93LmdldElzRXhwYW5kZWQoKSkge1xuICAgICAgcm93LnN1YlJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgIH1cbiAgfTtcbiAgcm93TW9kZWwucm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gIHJldHVybiB7XG4gICAgcm93czogZXhwYW5kZWRSb3dzLFxuICAgIGZsYXRSb3dzOiByb3dNb2RlbC5mbGF0Um93cyxcbiAgICByb3dzQnlJZDogcm93TW9kZWwucm93c0J5SWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RmFjZXRlZE1pbk1heFZhbHVlcygpIHtcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4ge1xuICAgIHZhciBfdGFibGUkZ2V0Q29sdW1uO1xuICAgIHJldHVybiBbKF90YWJsZSRnZXRDb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvbHVtbi5nZXRGYWNldGVkUm93TW9kZWwoKV07XG4gIH0sIGZhY2V0ZWRSb3dNb2RlbCA9PiB7XG4gICAgdmFyIF9mYWNldGVkUm93TW9kZWwkZmxhdDtcbiAgICBpZiAoIWZhY2V0ZWRSb3dNb2RlbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gKF9mYWNldGVkUm93TW9kZWwkZmxhdCA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93c1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mYWNldGVkUm93TW9kZWwkZmxhdC5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpO1xuICAgIGlmICh0eXBlb2YgZmlyc3RWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBmYWNldGVkTWluTWF4VmFsdWVzID0gW2ZpcnN0VmFsdWUsIGZpcnN0VmFsdWVdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3NbaV0uZ2V0VW5pcXVlVmFsdWVzKGNvbHVtbklkKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2pdO1xuICAgICAgICBpZiAodmFsdWUgPCBmYWNldGVkTWluTWF4VmFsdWVzWzBdKSB7XG4gICAgICAgICAgZmFjZXRlZE1pbk1heFZhbHVlc1swXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID4gZmFjZXRlZE1pbk1heFZhbHVlc1sxXSkge1xuICAgICAgICAgIGZhY2V0ZWRNaW5NYXhWYWx1ZXNbMV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFjZXRlZE1pbk1heFZhbHVlcztcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RmFjZXRlZE1pbk1heFZhbHVlcycpKTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyUm93cyhyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSkge1xuICBpZiAodGFibGUub3B0aW9ucy5maWx0ZXJGcm9tTGVhZlJvd3MpIHtcbiAgICByZXR1cm4gZmlsdGVyUm93TW9kZWxGcm9tTGVhZnMocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpO1xuICB9XG4gIHJldHVybiBmaWx0ZXJSb3dNb2RlbEZyb21Sb290KHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKTtcbn1cbmZ1bmN0aW9uIGZpbHRlclJvd01vZGVsRnJvbUxlYWZzKHJvd3NUb0ZpbHRlciwgZmlsdGVyUm93LCB0YWJsZSkge1xuICB2YXIgX3RhYmxlJG9wdGlvbnMkbWF4TGVhO1xuICBjb25zdCBuZXdGaWx0ZXJlZEZsYXRSb3dzID0gW107XG4gIGNvbnN0IG5ld0ZpbHRlcmVkUm93c0J5SWQgPSB7fTtcbiAgY29uc3QgbWF4RGVwdGggPSAoX3RhYmxlJG9wdGlvbnMkbWF4TGVhID0gdGFibGUub3B0aW9ucy5tYXhMZWFmUm93RmlsdGVyRGVwdGgpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRtYXhMZWEgOiAxMDA7XG4gIGNvbnN0IHJlY3Vyc2VGaWx0ZXJSb3dzID0gZnVuY3Rpb24gKHJvd3NUb0ZpbHRlciwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAwO1xuICAgIH1cbiAgICBjb25zdCByb3dzID0gW107XG5cbiAgICAvLyBGaWx0ZXIgZnJvbSBjaGlsZHJlbiB1cCBmaXJzdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93c1RvRmlsdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3JvdyRzdWJSb3dzO1xuICAgICAgbGV0IHJvdyA9IHJvd3NUb0ZpbHRlcltpXTtcbiAgICAgIGNvbnN0IG5ld1JvdyA9IGNyZWF0ZVJvdyh0YWJsZSwgcm93LmlkLCByb3cub3JpZ2luYWwsIHJvdy5pbmRleCwgcm93LmRlcHRoLCB1bmRlZmluZWQsIHJvdy5wYXJlbnRJZCk7XG4gICAgICBuZXdSb3cuY29sdW1uRmlsdGVycyA9IHJvdy5jb2x1bW5GaWx0ZXJzO1xuICAgICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoICYmIGRlcHRoIDwgbWF4RGVwdGgpIHtcbiAgICAgICAgbmV3Um93LnN1YlJvd3MgPSByZWN1cnNlRmlsdGVyUm93cyhyb3cuc3ViUm93cywgZGVwdGggKyAxKTtcbiAgICAgICAgcm93ID0gbmV3Um93O1xuICAgICAgICBpZiAoZmlsdGVyUm93KHJvdykgJiYgIW5ld1Jvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyUm93KHJvdykgfHwgbmV3Um93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3cgPSBuZXdSb3c7XG4gICAgICAgIGlmIChmaWx0ZXJSb3cocm93KSkge1xuICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm93cztcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiByZWN1cnNlRmlsdGVyUm93cyhyb3dzVG9GaWx0ZXIpLFxuICAgIGZsYXRSb3dzOiBuZXdGaWx0ZXJlZEZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiBuZXdGaWx0ZXJlZFJvd3NCeUlkXG4gIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJSb3dNb2RlbEZyb21Sb290KHJvd3NUb0ZpbHRlciwgZmlsdGVyUm93LCB0YWJsZSkge1xuICB2YXIgX3RhYmxlJG9wdGlvbnMkbWF4TGVhMjtcbiAgY29uc3QgbmV3RmlsdGVyZWRGbGF0Um93cyA9IFtdO1xuICBjb25zdCBuZXdGaWx0ZXJlZFJvd3NCeUlkID0ge307XG4gIGNvbnN0IG1heERlcHRoID0gKF90YWJsZSRvcHRpb25zJG1heExlYTIgPSB0YWJsZS5vcHRpb25zLm1heExlYWZSb3dGaWx0ZXJEZXB0aCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJG1heExlYTIgOiAxMDA7XG5cbiAgLy8gRmlsdGVycyB0b3AgbGV2ZWwgYW5kIG5lc3RlZCByb3dzXG4gIGNvbnN0IHJlY3Vyc2VGaWx0ZXJSb3dzID0gZnVuY3Rpb24gKHJvd3NUb0ZpbHRlciwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgZGVwdGggPSAwO1xuICAgIH1cbiAgICAvLyBGaWx0ZXIgZnJvbSBwYXJlbnRzIGRvd253YXJkIGZpcnN0XG5cbiAgICBjb25zdCByb3dzID0gW107XG5cbiAgICAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIGFueSBzdWJSb3dzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9GaWx0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCByb3cgPSByb3dzVG9GaWx0ZXJbaV07XG4gICAgICBjb25zdCBwYXNzID0gZmlsdGVyUm93KHJvdyk7XG4gICAgICBpZiAocGFzcykge1xuICAgICAgICB2YXIgX3JvdyRzdWJSb3dzMjtcbiAgICAgICAgaWYgKChfcm93JHN1YlJvd3MyID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzMi5sZW5ndGggJiYgZGVwdGggPCBtYXhEZXB0aCkge1xuICAgICAgICAgIGNvbnN0IG5ld1JvdyA9IGNyZWF0ZVJvdyh0YWJsZSwgcm93LmlkLCByb3cub3JpZ2luYWwsIHJvdy5pbmRleCwgcm93LmRlcHRoLCB1bmRlZmluZWQsIHJvdy5wYXJlbnRJZCk7XG4gICAgICAgICAgbmV3Um93LnN1YlJvd3MgPSByZWN1cnNlRmlsdGVyUm93cyhyb3cuc3ViUm93cywgZGVwdGggKyAxKTtcbiAgICAgICAgICByb3cgPSBuZXdSb3c7XG4gICAgICAgIH1cbiAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgIG5ld0ZpbHRlcmVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb3dzO1xuICB9O1xuICByZXR1cm4ge1xuICAgIHJvd3M6IHJlY3Vyc2VGaWx0ZXJSb3dzKHJvd3NUb0ZpbHRlciksXG4gICAgZmxhdFJvd3M6IG5ld0ZpbHRlcmVkRmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IG5ld0ZpbHRlcmVkUm93c0J5SWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RmFjZXRlZFJvd01vZGVsKCkge1xuICByZXR1cm4gKHRhYmxlLCBjb2x1bW5JZCkgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMsIHRhYmxlLmdldFN0YXRlKCkuZ2xvYmFsRmlsdGVyLCB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCldLCAocHJlUm93TW9kZWwsIGNvbHVtbkZpbHRlcnMsIGdsb2JhbEZpbHRlcikgPT4ge1xuICAgIGlmICghcHJlUm93TW9kZWwucm93cy5sZW5ndGggfHwgIShjb2x1bW5GaWx0ZXJzICE9IG51bGwgJiYgY29sdW1uRmlsdGVycy5sZW5ndGgpICYmICFnbG9iYWxGaWx0ZXIpIHtcbiAgICAgIHJldHVybiBwcmVSb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyYWJsZUlkcyA9IFsuLi5jb2x1bW5GaWx0ZXJzLm1hcChkID0+IGQuaWQpLmZpbHRlcihkID0+IGQgIT09IGNvbHVtbklkKSwgZ2xvYmFsRmlsdGVyID8gJ19fZ2xvYmFsX18nIDogdW5kZWZpbmVkXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgY29uc3QgZmlsdGVyUm93c0ltcGwgPSByb3cgPT4ge1xuICAgICAgLy8gSG9yaXpvbnRhbGx5IGZpbHRlciByb3dzIHRocm91Z2ggZWFjaCBjb2x1bW5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyYWJsZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnNbZmlsdGVyYWJsZUlkc1tpXV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHJldHVybiBmaWx0ZXJSb3dzKHByZVJvd01vZGVsLnJvd3MsIGZpbHRlclJvd3NJbXBsLCB0YWJsZSk7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZhY2V0ZWRSb3dNb2RlbCcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcygpIHtcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4ge1xuICAgIHZhciBfdGFibGUkZ2V0Q29sdW1uO1xuICAgIHJldHVybiBbKF90YWJsZSRnZXRDb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvbHVtbi5nZXRGYWNldGVkUm93TW9kZWwoKV07XG4gIH0sIGZhY2V0ZWRSb3dNb2RlbCA9PiB7XG4gICAgaWYgKCFmYWNldGVkUm93TW9kZWwpIHJldHVybiBuZXcgTWFwKCk7XG4gICAgbGV0IGZhY2V0ZWRVbmlxdWVWYWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93c1tpXS5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbal07XG4gICAgICAgIGlmIChmYWNldGVkVW5pcXVlVmFsdWVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgX2ZhY2V0ZWRVbmlxdWVWYWx1ZXMkO1xuICAgICAgICAgIGZhY2V0ZWRVbmlxdWVWYWx1ZXMuc2V0KHZhbHVlLCAoKF9mYWNldGVkVW5pcXVlVmFsdWVzJCA9IGZhY2V0ZWRVbmlxdWVWYWx1ZXMuZ2V0KHZhbHVlKSkgIT0gbnVsbCA/IF9mYWNldGVkVW5pcXVlVmFsdWVzJCA6IDApICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmFjZXRlZFVuaXF1ZVZhbHVlcy5zZXQodmFsdWUsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWNldGVkVW5pcXVlVmFsdWVzO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsIGBnZXRGYWNldGVkVW5pcXVlVmFsdWVzXyR7Y29sdW1uSWR9YCkpO1xufVxuXG5mdW5jdGlvbiBnZXRGaWx0ZXJlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtbkZpbHRlcnMsIHRhYmxlLmdldFN0YXRlKCkuZ2xvYmFsRmlsdGVyXSwgKHJvd01vZGVsLCBjb2x1bW5GaWx0ZXJzLCBnbG9iYWxGaWx0ZXIpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoY29sdW1uRmlsdGVycyAhPSBudWxsICYmIGNvbHVtbkZpbHRlcnMubGVuZ3RoKSAmJiAhZ2xvYmFsRmlsdGVyKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvd01vZGVsLmZsYXRSb3dzW2ldLmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICAgICAgcm93TW9kZWwuZmxhdFJvd3NbaV0uY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzID0gW107XG4gICAgY29uc3QgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzID0gW107XG4gICAgKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCA/IGNvbHVtbkZpbHRlcnMgOiBbXSkuZm9yRWFjaChkID0+IHtcbiAgICAgIHZhciBfZmlsdGVyRm4kcmVzb2x2ZUZpbHQ7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oZC5pZCk7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmaWx0ZXJGbiA9IGNvbHVtbi5nZXRGaWx0ZXJGbigpO1xuICAgICAgaWYgKCFmaWx0ZXJGbikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYSB2YWxpZCAnY29sdW1uLmZpbHRlckZuJyBmb3IgY29sdW1uIHdpdGggdGhlIElEOiAke2NvbHVtbi5pZH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLnB1c2goe1xuICAgICAgICBpZDogZC5pZCxcbiAgICAgICAgZmlsdGVyRm4sXG4gICAgICAgIHJlc29sdmVkVmFsdWU6IChfZmlsdGVyRm4kcmVzb2x2ZUZpbHQgPSBmaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZShkLnZhbHVlKSkgIT0gbnVsbCA/IF9maWx0ZXJGbiRyZXNvbHZlRmlsdCA6IGQudmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGZpbHRlcmFibGVJZHMgPSAoY29sdW1uRmlsdGVycyAhPSBudWxsID8gY29sdW1uRmlsdGVycyA6IFtdKS5tYXAoZCA9PiBkLmlkKTtcbiAgICBjb25zdCBnbG9iYWxGaWx0ZXJGbiA9IHRhYmxlLmdldEdsb2JhbEZpbHRlckZuKCk7XG4gICAgY29uc3QgZ2xvYmFsbHlGaWx0ZXJhYmxlQ29sdW1ucyA9IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uZ2V0Q2FuR2xvYmFsRmlsdGVyKCkpO1xuICAgIGlmIChnbG9iYWxGaWx0ZXIgJiYgZ2xvYmFsRmlsdGVyRm4gJiYgZ2xvYmFsbHlGaWx0ZXJhYmxlQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgIGZpbHRlcmFibGVJZHMucHVzaCgnX19nbG9iYWxfXycpO1xuICAgICAgZ2xvYmFsbHlGaWx0ZXJhYmxlQ29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgIHZhciBfZ2xvYmFsRmlsdGVyRm4kcmVzb2w7XG4gICAgICAgIHJlc29sdmVkR2xvYmFsRmlsdGVycy5wdXNoKHtcbiAgICAgICAgICBpZDogY29sdW1uLmlkLFxuICAgICAgICAgIGZpbHRlckZuOiBnbG9iYWxGaWx0ZXJGbixcbiAgICAgICAgICByZXNvbHZlZFZhbHVlOiAoX2dsb2JhbEZpbHRlckZuJHJlc29sID0gZ2xvYmFsRmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxGaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUoZ2xvYmFsRmlsdGVyKSkgIT0gbnVsbCA/IF9nbG9iYWxGaWx0ZXJGbiRyZXNvbCA6IGdsb2JhbEZpbHRlclxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgY3VycmVudENvbHVtbkZpbHRlcjtcbiAgICBsZXQgY3VycmVudEdsb2JhbEZpbHRlcjtcblxuICAgIC8vIEZsYWcgdGhlIHByZWZpbHRlcmVkIHJvdyBtb2RlbCB3aXRoIGVhY2ggZmlsdGVyIHN0YXRlXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3Qgcm93ID0gcm93TW9kZWwuZmxhdFJvd3Nbal07XG4gICAgICByb3cuY29sdW1uRmlsdGVycyA9IHt9O1xuICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZENvbHVtbkZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjdXJyZW50Q29sdW1uRmlsdGVyID0gcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IGlkID0gY3VycmVudENvbHVtbkZpbHRlci5pZDtcblxuICAgICAgICAgIC8vIFRhZyB0aGUgcm93IHdpdGggdGhlIGNvbHVtbiBmaWx0ZXIgc3RhdGVcbiAgICAgICAgICByb3cuY29sdW1uRmlsdGVyc1tpZF0gPSBjdXJyZW50Q29sdW1uRmlsdGVyLmZpbHRlckZuKHJvdywgaWQsIGN1cnJlbnRDb2x1bW5GaWx0ZXIucmVzb2x2ZWRWYWx1ZSwgZmlsdGVyTWV0YSA9PiB7XG4gICAgICAgICAgICByb3cuY29sdW1uRmlsdGVyc01ldGFbaWRdID0gZmlsdGVyTWV0YTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc29sdmVkR2xvYmFsRmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNvbHZlZEdsb2JhbEZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjdXJyZW50R2xvYmFsRmlsdGVyID0gcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzW2ldO1xuICAgICAgICAgIGNvbnN0IGlkID0gY3VycmVudEdsb2JhbEZpbHRlci5pZDtcbiAgICAgICAgICAvLyBUYWcgdGhlIHJvdyB3aXRoIHRoZSBmaXJzdCB0cnV0aHkgZ2xvYmFsIGZpbHRlciBzdGF0ZVxuICAgICAgICAgIGlmIChjdXJyZW50R2xvYmFsRmlsdGVyLmZpbHRlckZuKHJvdywgaWQsIGN1cnJlbnRHbG9iYWxGaWx0ZXIucmVzb2x2ZWRWYWx1ZSwgZmlsdGVyTWV0YSA9PiB7XG4gICAgICAgICAgICByb3cuY29sdW1uRmlsdGVyc01ldGFbaWRdID0gZmlsdGVyTWV0YTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gIT09IHRydWUpIHtcbiAgICAgICAgICByb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlsdGVyUm93c0ltcGwgPSByb3cgPT4ge1xuICAgICAgLy8gSG9yaXpvbnRhbGx5IGZpbHRlciByb3dzIHRocm91Z2ggZWFjaCBjb2x1bW5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyYWJsZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocm93LmNvbHVtbkZpbHRlcnNbZmlsdGVyYWJsZUlkc1tpXV0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gRmlsdGVyIGZpbmFsIHJvd3MgdXNpbmcgYWxsIG9mIHRoZSBhY3RpdmUgZmlsdGVyc1xuICAgIHJldHVybiBmaWx0ZXJSb3dzKHJvd01vZGVsLnJvd3MsIGZpbHRlclJvd3NJbXBsLCB0YWJsZSk7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZpbHRlcmVkUm93TW9kZWwnLCAoKSA9PiB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0R3JvdXBlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZywgdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsKCldLCAoZ3JvdXBpbmcsIHJvd01vZGVsKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhZ3JvdXBpbmcubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuXG4gICAgLy8gRmlsdGVyIHRoZSBncm91cGluZyBsaXN0IGRvd24gdG8gY29sdW1ucyB0aGF0IGV4aXN0XG4gICAgY29uc3QgZXhpc3RpbmdHcm91cGluZyA9IGdyb3VwaW5nLmZpbHRlcihjb2x1bW5JZCA9PiB0YWJsZS5nZXRDb2x1bW4oY29sdW1uSWQpKTtcbiAgICBjb25zdCBncm91cGVkRmxhdFJvd3MgPSBbXTtcbiAgICBjb25zdCBncm91cGVkUm93c0J5SWQgPSB7fTtcbiAgICAvLyBjb25zdCBvbmx5R3JvdXBlZEZsYXRSb3dzOiBSb3dbXSA9IFtdO1xuICAgIC8vIGNvbnN0IG9ubHlHcm91cGVkUm93c0J5SWQ6IFJlY29yZDxSb3dJZCwgUm93PiA9IHt9O1xuICAgIC8vIGNvbnN0IG5vbkdyb3VwZWRGbGF0Um93czogUm93W10gPSBbXTtcbiAgICAvLyBjb25zdCBub25Hcm91cGVkUm93c0J5SWQ6IFJlY29yZDxSb3dJZCwgUm93PiA9IHt9O1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgZ3JvdXAgdGhlIGRhdGFcbiAgICBjb25zdCBncm91cFVwUmVjdXJzaXZlbHkgPSBmdW5jdGlvbiAocm93cywgZGVwdGgsIHBhcmVudElkKSB7XG4gICAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgICB9XG4gICAgICAvLyBHcm91cGluZyBkZXB0aCBoYXMgYmVlbiBiZWVuIG1ldFxuICAgICAgLy8gU3RvcCBncm91cGluZyBhbmQgc2ltcGx5IHJld3JpdGUgdGhkIGRlcHRoIGFuZCByb3cgcmVsYXRpb25zaGlwc1xuICAgICAgaWYgKGRlcHRoID49IGV4aXN0aW5nR3JvdXBpbmcubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByb3dzLm1hcChyb3cgPT4ge1xuICAgICAgICAgIHJvdy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgZ3JvdXBlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgaWYgKHJvdy5zdWJSb3dzKSB7XG4gICAgICAgICAgICByb3cuc3ViUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShyb3cuc3ViUm93cywgZGVwdGggKyAxLCByb3cuaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbklkID0gZXhpc3RpbmdHcm91cGluZ1tkZXB0aF07XG5cbiAgICAgIC8vIEdyb3VwIHRoZSByb3dzIHRvZ2V0aGVyIGZvciB0aGlzIGxldmVsXG4gICAgICBjb25zdCByb3dHcm91cHNNYXAgPSBncm91cEJ5KHJvd3MsIGNvbHVtbklkKTtcblxuICAgICAgLy8gUGVmb3JtIGFnZ3JlZ2F0aW9ucyBmb3IgZWFjaCBncm91cFxuICAgICAgY29uc3QgYWdncmVnYXRlZEdyb3VwZWRSb3dzID0gQXJyYXkuZnJvbShyb3dHcm91cHNNYXAuZW50cmllcygpKS5tYXAoKF9yZWYsIGluZGV4KSA9PiB7XG4gICAgICAgIGxldCBbZ3JvdXBpbmdWYWx1ZSwgZ3JvdXBlZFJvd3NdID0gX3JlZjtcbiAgICAgICAgbGV0IGlkID0gYCR7Y29sdW1uSWR9OiR7Z3JvdXBpbmdWYWx1ZX1gO1xuICAgICAgICBpZCA9IHBhcmVudElkID8gYCR7cGFyZW50SWR9PiR7aWR9YCA6IGlkO1xuXG4gICAgICAgIC8vIEZpcnN0LCBSZWN1cnNlIHRvIGdyb3VwIHN1YiByb3dzIGJlZm9yZSBhZ2dyZWdhdGlvblxuICAgICAgICBjb25zdCBzdWJSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KGdyb3VwZWRSb3dzLCBkZXB0aCArIDEsIGlkKTtcblxuICAgICAgICAvLyBGbGF0dGVuIHRoZSBsZWFmIHJvd3Mgb2YgdGhlIHJvd3MgaW4gdGhpcyBncm91cFxuICAgICAgICBjb25zdCBsZWFmUm93cyA9IGRlcHRoID8gZmxhdHRlbkJ5KGdyb3VwZWRSb3dzLCByb3cgPT4gcm93LnN1YlJvd3MpIDogZ3JvdXBlZFJvd3M7XG4gICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZVJvdyh0YWJsZSwgaWQsIGxlYWZSb3dzWzBdLm9yaWdpbmFsLCBpbmRleCwgZGVwdGgsIHVuZGVmaW5lZCwgcGFyZW50SWQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHJvdywge1xuICAgICAgICAgIGdyb3VwaW5nQ29sdW1uSWQ6IGNvbHVtbklkLFxuICAgICAgICAgIGdyb3VwaW5nVmFsdWUsXG4gICAgICAgICAgc3ViUm93cyxcbiAgICAgICAgICBsZWFmUm93cyxcbiAgICAgICAgICBnZXRWYWx1ZTogY29sdW1uSWQgPT4ge1xuICAgICAgICAgICAgLy8gRG9uJ3QgYWdncmVnYXRlIGNvbHVtbnMgdGhhdCBhcmUgaW4gdGhlIGdyb3VwaW5nXG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdHcm91cGluZy5pbmNsdWRlcyhjb2x1bW5JZCkpIHtcbiAgICAgICAgICAgICAgaWYgKHJvdy5fdmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChncm91cGVkUm93c1swXSkge1xuICAgICAgICAgICAgICAgIHZhciBfZ3JvdXBlZFJvd3MkMCRnZXRWYWw7XG4gICAgICAgICAgICAgICAgcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSAoX2dyb3VwZWRSb3dzJDAkZ2V0VmFsID0gZ3JvdXBlZFJvd3NbMF0uZ2V0VmFsdWUoY29sdW1uSWQpKSAhPSBudWxsID8gX2dyb3VwZWRSb3dzJDAkZ2V0VmFsIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZ2dyZWdhdGUgdGhlIHZhbHVlc1xuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGFnZ3JlZ2F0ZUZuID0gY29sdW1uID09IG51bGwgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0QWdncmVnYXRpb25GbigpO1xuICAgICAgICAgICAgaWYgKGFnZ3JlZ2F0ZUZuKSB7XG4gICAgICAgICAgICAgIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBhZ2dyZWdhdGVGbihjb2x1bW5JZCwgbGVhZlJvd3MsIGdyb3VwZWRSb3dzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3ViUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgICAgICAgZ3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICBncm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyBpZiAoc3ViUm93LmdldElzR3JvdXBlZD8uKCkpIHtcbiAgICAgICAgICAvLyAgIG9ubHlHcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIC8vICAgb25seUdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgLy8gICBub25Hcm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgICAgIC8vICAgbm9uR3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgLy8gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZWRHcm91cGVkUm93cztcbiAgICB9O1xuICAgIGNvbnN0IGdyb3VwZWRSb3dzID0gZ3JvdXBVcFJlY3Vyc2l2ZWx5KHJvd01vZGVsLnJvd3MsIDApO1xuICAgIGdyb3VwZWRSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICBncm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgIC8vIGlmIChzdWJSb3cuZ2V0SXNHcm91cGVkPy4oKSkge1xuICAgICAgLy8gICBvbmx5R3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgIC8vICAgb25seUdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgbm9uR3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgIC8vICAgbm9uR3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAvLyB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd3M6IGdyb3VwZWRSb3dzLFxuICAgICAgZmxhdFJvd3M6IGdyb3VwZWRGbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiBncm91cGVkUm93c0J5SWRcbiAgICB9O1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRHcm91cGVkUm93TW9kZWwnLCAoKSA9PiB7XG4gICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRFeHBhbmRlZCgpO1xuICAgICAgdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpO1xuICAgIH0pO1xuICB9KSk7XG59XG5mdW5jdGlvbiBncm91cEJ5KHJvd3MsIGNvbHVtbklkKSB7XG4gIGNvbnN0IGdyb3VwTWFwID0gbmV3IE1hcCgpO1xuICByZXR1cm4gcm93cy5yZWR1Y2UoKG1hcCwgcm93KSA9PiB7XG4gICAgY29uc3QgcmVzS2V5ID0gYCR7cm93LmdldEdyb3VwaW5nVmFsdWUoY29sdW1uSWQpfWA7XG4gICAgY29uc3QgcHJldmlvdXMgPSBtYXAuZ2V0KHJlc0tleSk7XG4gICAgaWYgKCFwcmV2aW91cykge1xuICAgICAgbWFwLnNldChyZXNLZXksIFtyb3ddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXMucHVzaChyb3cpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9LCBncm91cE1hcCk7XG59XG5cbmZ1bmN0aW9uIGdldFBhZ2luYXRpb25Sb3dNb2RlbChvcHRzKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24sIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLCB0YWJsZS5vcHRpb25zLnBhZ2luYXRlRXhwYW5kZWRSb3dzID8gdW5kZWZpbmVkIDogdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZF0sIChwYWdpbmF0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVNpemUsXG4gICAgICBwYWdlSW5kZXhcbiAgICB9ID0gcGFnaW5hdGlvbjtcbiAgICBsZXQge1xuICAgICAgcm93cyxcbiAgICAgIGZsYXRSb3dzLFxuICAgICAgcm93c0J5SWRcbiAgICB9ID0gcm93TW9kZWw7XG4gICAgY29uc3QgcGFnZVN0YXJ0ID0gcGFnZVNpemUgKiBwYWdlSW5kZXg7XG4gICAgY29uc3QgcGFnZUVuZCA9IHBhZ2VTdGFydCArIHBhZ2VTaXplO1xuICAgIHJvd3MgPSByb3dzLnNsaWNlKHBhZ2VTdGFydCwgcGFnZUVuZCk7XG4gICAgbGV0IHBhZ2luYXRlZFJvd01vZGVsO1xuICAgIGlmICghdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93cykge1xuICAgICAgcGFnaW5hdGVkUm93TW9kZWwgPSBleHBhbmRSb3dzKHtcbiAgICAgICAgcm93cyxcbiAgICAgICAgZmxhdFJvd3MsXG4gICAgICAgIHJvd3NCeUlkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnaW5hdGVkUm93TW9kZWwgPSB7XG4gICAgICAgIHJvd3MsXG4gICAgICAgIGZsYXRSb3dzLFxuICAgICAgICByb3dzQnlJZFxuICAgICAgfTtcbiAgICB9XG4gICAgcGFnaW5hdGVkUm93TW9kZWwuZmxhdFJvd3MgPSBbXTtcbiAgICBjb25zdCBoYW5kbGVSb3cgPSByb3cgPT4ge1xuICAgICAgcGFnaW5hdGVkUm93TW9kZWwuZmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgaWYgKHJvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICByb3cuc3ViUm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBwYWdpbmF0ZWRSb3dNb2RlbC5yb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgICByZXR1cm4gcGFnaW5hdGVkUm93TW9kZWw7XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFBhZ2luYXRpb25Sb3dNb2RlbCcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0U29ydGVkUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmcsIHRhYmxlLmdldFByZVNvcnRlZFJvd01vZGVsKCldLCAoc29ydGluZywgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoc29ydGluZyAhPSBudWxsICYmIHNvcnRpbmcubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cbiAgICBjb25zdCBzb3J0aW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLnNvcnRpbmc7XG4gICAgY29uc3Qgc29ydGVkRmxhdFJvd3MgPSBbXTtcblxuICAgIC8vIEZpbHRlciBvdXQgc29ydGluZ3MgdGhhdCBjb3JyZXNwb25kIHRvIG5vbiBleGlzdGluZyBjb2x1bW5zXG4gICAgY29uc3QgYXZhaWxhYmxlU29ydGluZyA9IHNvcnRpbmdTdGF0ZS5maWx0ZXIoc29ydCA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldENvbHVtbiA9IHRhYmxlLmdldENvbHVtbihzb3J0LmlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0Q2FuU29ydCgpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbHVtbkluZm9CeUlkID0ge307XG4gICAgYXZhaWxhYmxlU29ydGluZy5mb3JFYWNoKHNvcnRFbnRyeSA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oc29ydEVudHJ5LmlkKTtcbiAgICAgIGlmICghY29sdW1uKSByZXR1cm47XG4gICAgICBjb2x1bW5JbmZvQnlJZFtzb3J0RW50cnkuaWRdID0ge1xuICAgICAgICBzb3J0VW5kZWZpbmVkOiBjb2x1bW4uY29sdW1uRGVmLnNvcnRVbmRlZmluZWQsXG4gICAgICAgIGludmVydFNvcnRpbmc6IGNvbHVtbi5jb2x1bW5EZWYuaW52ZXJ0U29ydGluZyxcbiAgICAgICAgc29ydGluZ0ZuOiBjb2x1bW4uZ2V0U29ydGluZ0ZuKClcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3Qgc29ydERhdGEgPSByb3dzID0+IHtcbiAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIHBlcmZvcm0gYSBzdGFibGUgc29ydGluZyB1c2luZyB0aGUgcm93IGluZGV4XG4gICAgICAvLyBpZiBuZWVkZWQuXG4gICAgICBjb25zdCBzb3J0ZWREYXRhID0gcm93cy5tYXAocm93ID0+ICh7XG4gICAgICAgIC4uLnJvd1xuICAgICAgfSkpO1xuICAgICAgc29ydGVkRGF0YS5zb3J0KChyb3dBLCByb3dCKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXZhaWxhYmxlU29ydGluZy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBfc29ydEVudHJ5JGRlc2M7XG4gICAgICAgICAgY29uc3Qgc29ydEVudHJ5ID0gYXZhaWxhYmxlU29ydGluZ1tpXTtcbiAgICAgICAgICBjb25zdCBjb2x1bW5JbmZvID0gY29sdW1uSW5mb0J5SWRbc29ydEVudHJ5LmlkXTtcbiAgICAgICAgICBjb25zdCBzb3J0VW5kZWZpbmVkID0gY29sdW1uSW5mby5zb3J0VW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnN0IGlzRGVzYyA9IChfc29ydEVudHJ5JGRlc2MgPSBzb3J0RW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHNvcnRFbnRyeS5kZXNjKSAhPSBudWxsID8gX3NvcnRFbnRyeSRkZXNjIDogZmFsc2U7XG4gICAgICAgICAgbGV0IHNvcnRJbnQgPSAwO1xuXG4gICAgICAgICAgLy8gQWxsIHNvcnRpbmcgaW50cyBzaG91bGQgYWx3YXlzIHJldHVybiBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICAgICAgICBpZiAoc29ydFVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgYVZhbHVlID0gcm93QS5nZXRWYWx1ZShzb3J0RW50cnkuaWQpO1xuICAgICAgICAgICAgY29uc3QgYlZhbHVlID0gcm93Qi5nZXRWYWx1ZShzb3J0RW50cnkuaWQpO1xuICAgICAgICAgICAgY29uc3QgYVVuZGVmaW5lZCA9IGFWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgYlVuZGVmaW5lZCA9IGJWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGFVbmRlZmluZWQgfHwgYlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBpZiAoc29ydFVuZGVmaW5lZCA9PT0gJ2ZpcnN0JykgcmV0dXJuIGFVbmRlZmluZWQgPyAtMSA6IDE7XG4gICAgICAgICAgICAgIGlmIChzb3J0VW5kZWZpbmVkID09PSAnbGFzdCcpIHJldHVybiBhVW5kZWZpbmVkID8gMSA6IC0xO1xuICAgICAgICAgICAgICBzb3J0SW50ID0gYVVuZGVmaW5lZCAmJiBiVW5kZWZpbmVkID8gMCA6IGFVbmRlZmluZWQgPyBzb3J0VW5kZWZpbmVkIDogLXNvcnRVbmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3J0SW50ID09PSAwKSB7XG4gICAgICAgICAgICBzb3J0SW50ID0gY29sdW1uSW5mby5zb3J0aW5nRm4ocm93QSwgcm93Qiwgc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBzb3J0aW5nIGlzIG5vbi16ZXJvLCB0YWtlIGNhcmUgb2YgZGVzYyBhbmQgaW52ZXJzaW9uXG4gICAgICAgICAgaWYgKHNvcnRJbnQgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChpc0Rlc2MpIHtcbiAgICAgICAgICAgICAgc29ydEludCAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2x1bW5JbmZvLmludmVydFNvcnRpbmcpIHtcbiAgICAgICAgICAgICAgc29ydEludCAqPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3J0SW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93QS5pbmRleCAtIHJvd0IuaW5kZXg7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgdGhlcmUgYXJlIHN1Yi1yb3dzLCBzb3J0IHRoZW1cbiAgICAgIHNvcnRlZERhdGEuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICB2YXIgX3JvdyRzdWJSb3dzO1xuICAgICAgICBzb3J0ZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIGlmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgIHJvdy5zdWJSb3dzID0gc29ydERhdGEocm93LnN1YlJvd3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3J0ZWREYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvd3M6IHNvcnREYXRhKHJvd01vZGVsLnJvd3MpLFxuICAgICAgZmxhdFJvd3M6IHNvcnRlZEZsYXRSb3dzLFxuICAgICAgcm93c0J5SWQ6IHJvd01vZGVsLnJvd3NCeUlkXG4gICAgfTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0U29ydGVkUm93TW9kZWwnLCAoKSA9PiB0YWJsZS5fYXV0b1Jlc2V0UGFnZUluZGV4KCkpKTtcbn1cblxuZXhwb3J0IHsgQ29sdW1uRmFjZXRpbmcsIENvbHVtbkZpbHRlcmluZywgQ29sdW1uR3JvdXBpbmcsIENvbHVtbk9yZGVyaW5nLCBDb2x1bW5QaW5uaW5nLCBDb2x1bW5TaXppbmcsIENvbHVtblZpc2liaWxpdHksIEdsb2JhbEZhY2V0aW5nLCBHbG9iYWxGaWx0ZXJpbmcsIEhlYWRlcnMsIFJvd0V4cGFuZGluZywgUm93UGFnaW5hdGlvbiwgUm93UGlubmluZywgUm93U2VsZWN0aW9uLCBSb3dTb3J0aW5nLCBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zLCBhZ2dyZWdhdGlvbkZucywgYnVpbGRIZWFkZXJHcm91cHMsIGNyZWF0ZUNlbGwsIGNyZWF0ZUNvbHVtbiwgY3JlYXRlQ29sdW1uSGVscGVyLCBjcmVhdGVSb3csIGNyZWF0ZVRhYmxlLCBkZWZhdWx0Q29sdW1uU2l6aW5nLCBleHBhbmRSb3dzLCBmaWx0ZXJGbnMsIGZsYXR0ZW5CeSwgZnVuY3Rpb25hbFVwZGF0ZSwgZ2V0Q29yZVJvd01vZGVsLCBnZXRFeHBhbmRlZFJvd01vZGVsLCBnZXRGYWNldGVkTWluTWF4VmFsdWVzLCBnZXRGYWNldGVkUm93TW9kZWwsIGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMsIGdldEZpbHRlcmVkUm93TW9kZWwsIGdldEdyb3VwZWRSb3dNb2RlbCwgZ2V0TWVtb09wdGlvbnMsIGdldFBhZ2luYXRpb25Sb3dNb2RlbCwgZ2V0U29ydGVkUm93TW9kZWwsIGlzRnVuY3Rpb24sIGlzTnVtYmVyQXJyYXksIGlzUm93U2VsZWN0ZWQsIGlzU3ViUm93U2VsZWN0ZWQsIG1ha2VTdGF0ZVVwZGF0ZXIsIG1lbW8sIG5vb3AsIG9yZGVyQ29sdW1ucywgcGFzc2l2ZUV2ZW50U3VwcG9ydGVkLCByZVNwbGl0QWxwaGFOdW1lcmljLCBzZWxlY3RSb3dzRm4sIHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIsIHNvcnRpbmdGbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb2x1bW5IZWxwZXIiLCJhY2Nlc3NvciIsImNvbHVtbiIsImFjY2Vzc29yRm4iLCJhY2Nlc3NvcktleSIsImRpc3BsYXkiLCJncm91cCIsImZ1bmN0aW9uYWxVcGRhdGUiLCJ1cGRhdGVyIiwiaW5wdXQiLCJub29wIiwibWFrZVN0YXRlVXBkYXRlciIsImtleSIsImluc3RhbmNlIiwic2V0U3RhdGUiLCJvbGQiLCJpc0Z1bmN0aW9uIiwiZCIsIkZ1bmN0aW9uIiwiaXNOdW1iZXJBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImV2ZXJ5IiwidmFsIiwiZmxhdHRlbkJ5IiwiYXJyIiwiZ2V0Q2hpbGRyZW4iLCJmbGF0IiwicmVjdXJzZSIsInN1YkFyciIsImZvckVhY2giLCJpdGVtIiwicHVzaCIsImNoaWxkcmVuIiwibGVuZ3RoIiwibWVtbyIsImdldERlcHMiLCJmbiIsIm9wdHMiLCJkZXBzIiwicmVzdWx0IiwiZGVwQXJncyIsImRlcFRpbWUiLCJkZWJ1ZyIsIkRhdGUiLCJub3ciLCJuZXdEZXBzIiwiZGVwc0NoYW5nZWQiLCJzb21lIiwiZGVwIiwiaW5kZXgiLCJyZXN1bHRUaW1lIiwib25DaGFuZ2UiLCJkZXBFbmRUaW1lIiwiTWF0aCIsInJvdW5kIiwicmVzdWx0RW5kVGltZSIsInJlc3VsdEZwc1BlcmNlbnRhZ2UiLCJwYWQiLCJzdHIiLCJudW0iLCJTdHJpbmciLCJjb25zb2xlIiwiaW5mbyIsIm1heCIsIm1pbiIsImdldE1lbW9PcHRpb25zIiwidGFibGVPcHRpb25zIiwiZGVidWdMZXZlbCIsIl90YWJsZU9wdGlvbnMkZGVidWdBbCIsImRlYnVnQWxsIiwicHJvY2VzcyIsImNyZWF0ZUNlbGwiLCJ0YWJsZSIsInJvdyIsImNvbHVtbklkIiwiZ2V0UmVuZGVyVmFsdWUiLCJfY2VsbCRnZXRWYWx1ZSIsImNlbGwiLCJnZXRWYWx1ZSIsIm9wdGlvbnMiLCJyZW5kZXJGYWxsYmFja1ZhbHVlIiwiaWQiLCJyZW5kZXJWYWx1ZSIsImdldENvbnRleHQiLCJfZmVhdHVyZXMiLCJmZWF0dXJlIiwiY3JlYXRlQ29sdW1uIiwiY29sdW1uRGVmIiwiZGVwdGgiLCJwYXJlbnQiLCJfcmVmIiwiX3Jlc29sdmVkQ29sdW1uRGVmJGlkIiwiZGVmYXVsdENvbHVtbiIsIl9nZXREZWZhdWx0Q29sdW1uRGVmIiwicmVzb2x2ZWRDb2x1bW5EZWYiLCJyZXBsYWNlIiwidW5kZWZpbmVkIiwiaGVhZGVyIiwiaW5jbHVkZXMiLCJvcmlnaW5hbFJvdyIsInNwbGl0IiwiX3Jlc3VsdCIsIndhcm4iLCJFcnJvciIsImNvbHVtbnMiLCJnZXRGbGF0Q29sdW1ucyIsIl9jb2x1bW4kY29sdW1ucyIsImZsYXRNYXAiLCJnZXRMZWFmQ29sdW1ucyIsIl9nZXRPcmRlckNvbHVtbnNGbiIsIm9yZGVyQ29sdW1ucyIsIl9jb2x1bW4kY29sdW1uczIiLCJsZWFmQ29sdW1ucyIsImNyZWF0ZUhlYWRlciIsIl9vcHRpb25zJGlkIiwiaXNQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVySWQiLCJzdWJIZWFkZXJzIiwiY29sU3BhbiIsInJvd1NwYW4iLCJoZWFkZXJHcm91cCIsImdldExlYWZIZWFkZXJzIiwibGVhZkhlYWRlcnMiLCJyZWN1cnNlSGVhZGVyIiwiaCIsIm1hcCIsIkhlYWRlcnMiLCJjcmVhdGVUYWJsZSIsImdldEhlYWRlckdyb3VwcyIsImdldEFsbENvbHVtbnMiLCJnZXRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRTdGF0ZSIsImNvbHVtblBpbm5pbmciLCJsZWZ0IiwicmlnaHQiLCJhbGxDb2x1bW5zIiwiX2xlZnQkbWFwJGZpbHRlciIsIl9yaWdodCRtYXAkZmlsdGVyIiwibGVmdENvbHVtbnMiLCJmaW5kIiwiZmlsdGVyIiwiQm9vbGVhbiIsInJpZ2h0Q29sdW1ucyIsImNlbnRlckNvbHVtbnMiLCJoZWFkZXJHcm91cHMiLCJidWlsZEhlYWRlckdyb3VwcyIsImdldENlbnRlckhlYWRlckdyb3VwcyIsImdldExlZnRIZWFkZXJHcm91cHMiLCJfbGVmdCRtYXAkZmlsdGVyMiIsIm9yZGVyZWRMZWFmQ29sdW1ucyIsImdldFJpZ2h0SGVhZGVyR3JvdXBzIiwiX3JpZ2h0JG1hcCRmaWx0ZXIyIiwiZ2V0Rm9vdGVyR3JvdXBzIiwicmV2ZXJzZSIsImdldExlZnRGb290ZXJHcm91cHMiLCJnZXRDZW50ZXJGb290ZXJHcm91cHMiLCJnZXRSaWdodEZvb3Rlckdyb3VwcyIsImdldEZsYXRIZWFkZXJzIiwiaGVhZGVycyIsImdldExlZnRGbGF0SGVhZGVycyIsImdldENlbnRlckZsYXRIZWFkZXJzIiwiZ2V0UmlnaHRGbGF0SGVhZGVycyIsImdldENlbnRlckxlYWZIZWFkZXJzIiwiZmxhdEhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMiLCJnZXRMZWZ0TGVhZkhlYWRlcnMiLCJfaGVhZGVyJHN1YkhlYWRlcnMyIiwiZ2V0UmlnaHRMZWFmSGVhZGVycyIsIl9oZWFkZXIkc3ViSGVhZGVyczMiLCJjZW50ZXIiLCJfbGVmdCQwJGhlYWRlcnMiLCJfbGVmdCQiLCJfY2VudGVyJDAkaGVhZGVycyIsIl9jZW50ZXIkIiwiX3JpZ2h0JDAkaGVhZGVycyIsIl9yaWdodCQiLCJjb2x1bW5zVG9Hcm91cCIsImhlYWRlckZhbWlseSIsIl9oZWFkZXJHcm91cHMkMCRoZWFkZSIsIl9oZWFkZXJHcm91cHMkIiwibWF4RGVwdGgiLCJmaW5kTWF4RGVwdGgiLCJnZXRJc1Zpc2libGUiLCJjcmVhdGVIZWFkZXJHcm91cCIsImhlYWRlcnNUb0dyb3VwIiwiam9pbiIsInBlbmRpbmdQYXJlbnRIZWFkZXJzIiwiaGVhZGVyVG9Hcm91cCIsImxhdGVzdFBlbmRpbmdQYXJlbnRIZWFkZXIiLCJpc0xlYWZIZWFkZXIiLCJib3R0b21IZWFkZXJzIiwicmVjdXJzZUhlYWRlcnNGb3JTcGFucyIsImZpbHRlcmVkSGVhZGVycyIsImNoaWxkUm93U3BhbnMiLCJjaGlsZENvbFNwYW4iLCJjaGlsZFJvd1NwYW4iLCJtaW5DaGlsZFJvd1NwYW4iLCJjcmVhdGVSb3ciLCJvcmlnaW5hbCIsInJvd0luZGV4Iiwic3ViUm93cyIsInBhcmVudElkIiwiX3ZhbHVlc0NhY2hlIiwiX3VuaXF1ZVZhbHVlc0NhY2hlIiwiaGFzT3duUHJvcGVydHkiLCJnZXRDb2x1bW4iLCJnZXRVbmlxdWVWYWx1ZXMiLCJfcm93JGdldFZhbHVlIiwiZ2V0TGVhZlJvd3MiLCJnZXRQYXJlbnRSb3ciLCJnZXRSb3ciLCJnZXRQYXJlbnRSb3dzIiwicGFyZW50Um93cyIsImN1cnJlbnRSb3ciLCJwYXJlbnRSb3ciLCJnZXRBbGxDZWxscyIsImdldEFsbExlYWZDb2x1bW5zIiwiX2dldEFsbENlbGxzQnlDb2x1bW5JZCIsImFsbENlbGxzIiwicmVkdWNlIiwiYWNjIiwiaSIsIkNvbHVtbkZhY2V0aW5nIiwiX2dldEZhY2V0ZWRSb3dNb2RlbCIsImdldEZhY2V0ZWRSb3dNb2RlbCIsImdldFByZUZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyIsImdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMiLCJNYXAiLCJfZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyIsImdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMiLCJpbmNsdWRlc1N0cmluZyIsImZpbHRlclZhbHVlIiwic2VhcmNoIiwidG9Mb3dlckNhc2UiLCJ0b1N0cmluZyIsImF1dG9SZW1vdmUiLCJ0ZXN0RmFsc2V5IiwiaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUiLCJfcm93JGdldFZhbHVlMiIsImVxdWFsc1N0cmluZyIsIl9yb3ckZ2V0VmFsdWUzIiwiYXJySW5jbHVkZXMiLCJfcm93JGdldFZhbHVlNCIsImFyckluY2x1ZGVzQWxsIiwiX3JvdyRnZXRWYWx1ZTUiLCJhcnJJbmNsdWRlc1NvbWUiLCJfcm93JGdldFZhbHVlNiIsImVxdWFscyIsIndlYWtFcXVhbHMiLCJpbk51bWJlclJhbmdlIiwicm93VmFsdWUiLCJyZXNvbHZlRmlsdGVyVmFsdWUiLCJ1bnNhZmVNaW4iLCJ1bnNhZmVNYXgiLCJwYXJzZWRNaW4iLCJwYXJzZUZsb2F0IiwicGFyc2VkTWF4IiwiTnVtYmVyIiwiaXNOYU4iLCJJbmZpbml0eSIsInRlbXAiLCJmaWx0ZXJGbnMiLCJDb2x1bW5GaWx0ZXJpbmciLCJnZXREZWZhdWx0Q29sdW1uRGVmIiwiZmlsdGVyRm4iLCJnZXRJbml0aWFsU3RhdGUiLCJzdGF0ZSIsImNvbHVtbkZpbHRlcnMiLCJnZXREZWZhdWx0T3B0aW9ucyIsIm9uQ29sdW1uRmlsdGVyc0NoYW5nZSIsImZpbHRlckZyb21MZWFmUm93cyIsIm1heExlYWZSb3dGaWx0ZXJEZXB0aCIsImdldEF1dG9GaWx0ZXJGbiIsImZpcnN0Um93IiwiZ2V0Q29yZVJvd01vZGVsIiwiZmxhdFJvd3MiLCJ2YWx1ZSIsImdldEZpbHRlckZuIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyIiwiX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiIsImdldENhbkZpbHRlciIsIl9jb2x1bW4kY29sdW1uRGVmJGVuYSIsIl90YWJsZSRvcHRpb25zJGVuYWJsZSIsIl90YWJsZSRvcHRpb25zJGVuYWJsZTIiLCJlbmFibGVDb2x1bW5GaWx0ZXIiLCJlbmFibGVDb2x1bW5GaWx0ZXJzIiwiZW5hYmxlRmlsdGVycyIsImdldElzRmlsdGVyZWQiLCJnZXRGaWx0ZXJJbmRleCIsImdldEZpbHRlclZhbHVlIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtIiwiX3RhYmxlJGdldFN0YXRlJGNvbHVtMiIsIl90YWJsZSRnZXRTdGF0ZSRjb2x1bTMiLCJmaW5kSW5kZXgiLCJzZXRGaWx0ZXJWYWx1ZSIsInNldENvbHVtbkZpbHRlcnMiLCJwcmV2aW91c0ZpbHRlciIsIm5ld0ZpbHRlciIsInNob3VsZEF1dG9SZW1vdmVGaWx0ZXIiLCJfb2xkJGZpbHRlciIsIm5ld0ZpbHRlck9iaiIsIl9vbGQkbWFwIiwiX3RhYmxlIiwiY29sdW1uRmlsdGVyc01ldGEiLCJ1cGRhdGVGbiIsIl9mdW5jdGlvbmFsVXBkYXRlIiwicmVzZXRDb2x1bW5GaWx0ZXJzIiwiZGVmYXVsdFN0YXRlIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRjIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSIsImluaXRpYWxTdGF0ZSIsImdldEZpbHRlcmVkUm93TW9kZWwiLCJfZ2V0RmlsdGVyZWRSb3dNb2RlbCIsIm1hbnVhbEZpbHRlcmluZyIsInN1bSIsIl9sZWFmUm93cyIsImNoaWxkUm93cyIsIm5leHQiLCJuZXh0VmFsdWUiLCJleHRlbnQiLCJtZWFuIiwibGVhZlJvd3MiLCJjb3VudCIsIm1lZGlhbiIsInZhbHVlcyIsIm1pZCIsImZsb29yIiwibnVtcyIsInNvcnQiLCJhIiwiYiIsInVuaXF1ZSIsImZyb20iLCJTZXQiLCJ1bmlxdWVDb3VudCIsInNpemUiLCJfY29sdW1uSWQiLCJhZ2dyZWdhdGlvbkZucyIsIkNvbHVtbkdyb3VwaW5nIiwiYWdncmVnYXRlZENlbGwiLCJwcm9wcyIsIl90b1N0cmluZyIsIl9wcm9wcyRnZXRWYWx1ZSIsImFnZ3JlZ2F0aW9uRm4iLCJncm91cGluZyIsIm9uR3JvdXBpbmdDaGFuZ2UiLCJncm91cGVkQ29sdW1uTW9kZSIsInRvZ2dsZUdyb3VwaW5nIiwic2V0R3JvdXBpbmciLCJnZXRDYW5Hcm91cCIsImVuYWJsZUdyb3VwaW5nIiwiZ2V0R3JvdXBpbmdWYWx1ZSIsImdldElzR3JvdXBlZCIsIl90YWJsZSRnZXRTdGF0ZSRncm91cCIsImdldEdyb3VwZWRJbmRleCIsIl90YWJsZSRnZXRTdGF0ZSRncm91cDIiLCJpbmRleE9mIiwiZ2V0VG9nZ2xlR3JvdXBpbmdIYW5kbGVyIiwiY2FuR3JvdXAiLCJnZXRBdXRvQWdncmVnYXRpb25GbiIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJnZXRBZ2dyZWdhdGlvbkZuIiwiX3RhYmxlJG9wdGlvbnMkYWdncmVnIiwiX3RhYmxlJG9wdGlvbnMkYWdncmVnMiIsInJlc2V0R3JvdXBpbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJGciLCJnZXRQcmVHcm91cGVkUm93TW9kZWwiLCJnZXRHcm91cGVkUm93TW9kZWwiLCJfZ2V0R3JvdXBlZFJvd01vZGVsIiwibWFudWFsR3JvdXBpbmciLCJncm91cGluZ0NvbHVtbklkIiwiX2dyb3VwaW5nVmFsdWVzQ2FjaGUiLCJnZXRJc1BsYWNlaG9sZGVyIiwiZ2V0SXNBZ2dyZWdhdGVkIiwiX3JvdyRzdWJSb3dzIiwibm9uR3JvdXBpbmdDb2x1bW5zIiwiY29sIiwiZ3JvdXBpbmdDb2x1bW5zIiwiZyIsIkNvbHVtbk9yZGVyaW5nIiwiY29sdW1uT3JkZXIiLCJvbkNvbHVtbk9yZGVyQ2hhbmdlIiwiZ2V0SW5kZXgiLCJwb3NpdGlvbiIsIl9nZXRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRJc0ZpcnN0Q29sdW1uIiwiX2NvbHVtbnMkIiwiZ2V0SXNMYXN0Q29sdW1uIiwiX2NvbHVtbnMiLCJzZXRDb2x1bW5PcmRlciIsInJlc2V0Q29sdW1uT3JkZXIiLCJvcmRlcmVkQ29sdW1ucyIsImNvbHVtbk9yZGVyQ29weSIsImNvbHVtbnNDb3B5IiwidGFyZ2V0Q29sdW1uSWQiLCJzaGlmdCIsImZvdW5kSW5kZXgiLCJzcGxpY2UiLCJnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlIiwiQ29sdW1uUGlubmluZyIsIm9uQ29sdW1uUGlubmluZ0NoYW5nZSIsInBpbiIsImNvbHVtbklkcyIsInNldENvbHVtblBpbm5pbmciLCJfb2xkJGxlZnQzIiwiX29sZCRyaWdodDMiLCJfb2xkJGxlZnQiLCJfb2xkJHJpZ2h0IiwiX29sZCRsZWZ0MiIsIl9vbGQkcmlnaHQyIiwiZ2V0Q2FuUGluIiwiX2QkY29sdW1uRGVmJGVuYWJsZVBpIiwiZW5hYmxlUGlubmluZyIsImVuYWJsZUNvbHVtblBpbm5pbmciLCJnZXRJc1Bpbm5lZCIsImxlYWZDb2x1bW5JZHMiLCJpc0xlZnQiLCJpc1JpZ2h0IiwiZ2V0UGlubmVkSW5kZXgiLCJnZXRDZW50ZXJWaXNpYmxlQ2VsbHMiLCJfZ2V0QWxsVmlzaWJsZUNlbGxzIiwibGVmdEFuZFJpZ2h0IiwiZ2V0TGVmdFZpc2libGVDZWxscyIsImNlbGxzIiwiZ2V0UmlnaHRWaXNpYmxlQ2VsbHMiLCJyZXNldENvbHVtblBpbm5pbmciLCJnZXRJc1NvbWVDb2x1bW5zUGlubmVkIiwiX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvIiwicGlubmluZ1N0YXRlIiwiX3Bpbm5pbmdTdGF0ZSRsZWZ0IiwiX3Bpbm5pbmdTdGF0ZSRyaWdodCIsImdldExlZnRMZWFmQ29sdW1ucyIsImdldFJpZ2h0TGVhZkNvbHVtbnMiLCJnZXRDZW50ZXJMZWFmQ29sdW1ucyIsImRlZmF1bHRDb2x1bW5TaXppbmciLCJtaW5TaXplIiwibWF4U2l6ZSIsIk1BWF9TQUZFX0lOVEVHRVIiLCJnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlIiwic3RhcnRPZmZzZXQiLCJzdGFydFNpemUiLCJkZWx0YU9mZnNldCIsImRlbHRhUGVyY2VudGFnZSIsImlzUmVzaXppbmdDb2x1bW4iLCJjb2x1bW5TaXppbmdTdGFydCIsIkNvbHVtblNpemluZyIsImNvbHVtblNpemluZyIsImNvbHVtblNpemluZ0luZm8iLCJjb2x1bW5SZXNpemVNb2RlIiwiY29sdW1uUmVzaXplRGlyZWN0aW9uIiwib25Db2x1bW5TaXppbmdDaGFuZ2UiLCJvbkNvbHVtblNpemluZ0luZm9DaGFuZ2UiLCJnZXRTaXplIiwiX2NvbHVtbiRjb2x1bW5EZWYkbWluIiwiX2NvbHVtbiRjb2x1bW5EZWYkbWF4IiwiY29sdW1uU2l6ZSIsImdldFN0YXJ0Iiwic2xpY2UiLCJnZXRBZnRlciIsInJlc2V0U2l6ZSIsInNldENvbHVtblNpemluZyIsIl9yZWYyIiwiXyIsInJlc3QiLCJnZXRDYW5SZXNpemUiLCJlbmFibGVSZXNpemluZyIsImVuYWJsZUNvbHVtblJlc2l6aW5nIiwiZ2V0SXNSZXNpemluZyIsIl9oZWFkZXIkY29sdW1uJGdldFNpeiIsInByZXZTaWJsaW5nSGVhZGVyIiwiZ2V0UmVzaXplSGFuZGxlciIsIl9jb250ZXh0RG9jdW1lbnQiLCJjYW5SZXNpemUiLCJlIiwicGVyc2lzdCIsImlzVG91Y2hTdGFydEV2ZW50IiwidG91Y2hlcyIsImNsaWVudFgiLCJuZXdDb2x1bW5TaXppbmciLCJ1cGRhdGVPZmZzZXQiLCJldmVudFR5cGUiLCJjbGllbnRYUG9zIiwic2V0Q29sdW1uU2l6aW5nSW5mbyIsIl9vbGQkc3RhcnRPZmZzZXQiLCJfb2xkJHN0YXJ0U2l6ZSIsImRlbHRhRGlyZWN0aW9uIiwiX3JlZjMiLCJoZWFkZXJTaXplIiwib25Nb3ZlIiwib25FbmQiLCJjb250ZXh0RG9jdW1lbnQiLCJkb2N1bWVudCIsIm1vdXNlRXZlbnRzIiwibW92ZUhhbmRsZXIiLCJ1cEhhbmRsZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidG91Y2hFdmVudHMiLCJjYW5jZWxhYmxlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJfZSR0b3VjaGVzJCIsInBhc3NpdmVJZlN1cHBvcnRlZCIsInBhc3NpdmVFdmVudFN1cHBvcnRlZCIsInBhc3NpdmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVzZXRDb2x1bW5TaXppbmciLCJyZXNldEhlYWRlclNpemVJbmZvIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRjMiIsImdldFRvdGFsU2l6ZSIsIl90YWJsZSRnZXRIZWFkZXJHcm91cCIsIl90YWJsZSRnZXRIZWFkZXJHcm91cDIiLCJnZXRMZWZ0VG90YWxTaXplIiwiX3RhYmxlJGdldExlZnRIZWFkZXJHIiwiX3RhYmxlJGdldExlZnRIZWFkZXJHMiIsImdldENlbnRlclRvdGFsU2l6ZSIsIl90YWJsZSRnZXRDZW50ZXJIZWFkZSIsIl90YWJsZSRnZXRDZW50ZXJIZWFkZTIiLCJnZXRSaWdodFRvdGFsU2l6ZSIsIl90YWJsZSRnZXRSaWdodEhlYWRlciIsIl90YWJsZSRnZXRSaWdodEhlYWRlcjIiLCJwYXNzaXZlU3VwcG9ydGVkIiwic3VwcG9ydGVkIiwid2luZG93IiwiZXJyIiwidHlwZSIsIkNvbHVtblZpc2liaWxpdHkiLCJjb2x1bW5WaXNpYmlsaXR5Iiwib25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlIiwidG9nZ2xlVmlzaWJpbGl0eSIsImdldENhbkhpZGUiLCJzZXRDb2x1bW5WaXNpYmlsaXR5IiwiY2hpbGRDb2x1bW5zIiwiYyIsImVuYWJsZUhpZGluZyIsImdldFRvZ2dsZVZpc2liaWxpdHlIYW5kbGVyIiwidGFyZ2V0IiwiY2hlY2tlZCIsImdldFZpc2libGVDZWxscyIsIm1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCIsImdldENvbHVtbnMiLCJnZXRWaXNpYmxlRmxhdENvbHVtbnMiLCJnZXRBbGxGbGF0Q29sdW1ucyIsImdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMiLCJnZXRSaWdodFZpc2libGVMZWFmQ29sdW1ucyIsImdldENlbnRlclZpc2libGVMZWFmQ29sdW1ucyIsInJlc2V0Q29sdW1uVmlzaWJpbGl0eSIsInRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlIiwiX3ZhbHVlIiwiZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSIsIm9iaiIsImdldElzU29tZUNvbHVtbnNWaXNpYmxlIiwiZ2V0VG9nZ2xlQWxsQ29sdW1uc1Zpc2liaWxpdHlIYW5kbGVyIiwiX3RhcmdldCIsIkdsb2JhbEZhY2V0aW5nIiwiX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCIsImdldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCIsIl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzIiwiZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcyIsIl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzIiwiZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyIsIkdsb2JhbEZpbHRlcmluZyIsImdsb2JhbEZpbHRlciIsIm9uR2xvYmFsRmlsdGVyQ2hhbmdlIiwiZ2xvYmFsRmlsdGVyRm4iLCJnZXRDb2x1bW5DYW5HbG9iYWxGaWx0ZXIiLCJfdGFibGUkZ2V0Q29yZVJvd01vZGUiLCJnZXRDYW5HbG9iYWxGaWx0ZXIiLCJfdGFibGUkb3B0aW9ucyRnZXRDb2wiLCJlbmFibGVHbG9iYWxGaWx0ZXIiLCJnZXRHbG9iYWxBdXRvRmlsdGVyRm4iLCJnZXRHbG9iYWxGaWx0ZXJGbiIsInNldEdsb2JhbEZpbHRlciIsInJlc2V0R2xvYmFsRmlsdGVyIiwiUm93RXhwYW5kaW5nIiwiZXhwYW5kZWQiLCJvbkV4cGFuZGVkQ2hhbmdlIiwicGFnaW5hdGVFeHBhbmRlZFJvd3MiLCJyZWdpc3RlcmVkIiwicXVldWVkIiwiX2F1dG9SZXNldEV4cGFuZGVkIiwiX3RhYmxlJG9wdGlvbnMkYXV0b1JlIiwiX3F1ZXVlIiwiYXV0b1Jlc2V0QWxsIiwiYXV0b1Jlc2V0RXhwYW5kZWQiLCJtYW51YWxFeHBhbmRpbmciLCJyZXNldEV4cGFuZGVkIiwic2V0RXhwYW5kZWQiLCJ0b2dnbGVBbGxSb3dzRXhwYW5kZWQiLCJnZXRJc0FsbFJvd3NFeHBhbmRlZCIsIl90YWJsZSRpbml0aWFsU3RhdGUkZSIsImdldENhblNvbWVSb3dzRXhwYW5kIiwiZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsIiwiZ2V0Q2FuRXhwYW5kIiwiZ2V0VG9nZ2xlQWxsUm93c0V4cGFuZGVkSGFuZGxlciIsImdldElzU29tZVJvd3NFeHBhbmRlZCIsImtleXMiLCJnZXRSb3dNb2RlbCIsImdldElzRXhwYW5kZWQiLCJnZXRFeHBhbmRlZERlcHRoIiwicm93SWRzIiwicm93c0J5SWQiLCJzcGxpdElkIiwiZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCIsImdldFNvcnRlZFJvd01vZGVsIiwiZ2V0RXhwYW5kZWRSb3dNb2RlbCIsIl9nZXRFeHBhbmRlZFJvd01vZGVsIiwidG9nZ2xlRXhwYW5kZWQiLCJfZXhwYW5kZWQiLCJleGlzdHMiLCJvbGRFeHBhbmRlZCIsInJvd0lkIiwiX3RhYmxlJG9wdGlvbnMkZ2V0SXNSIiwiZ2V0SXNSb3dFeHBhbmRlZCIsIl90YWJsZSRvcHRpb25zJGdldFJvdyIsImdldFJvd0NhbkV4cGFuZCIsImVuYWJsZUV4cGFuZGluZyIsImdldElzQWxsUGFyZW50c0V4cGFuZGVkIiwiaXNGdWxseUV4cGFuZGVkIiwiZ2V0VG9nZ2xlRXhwYW5kZWRIYW5kbGVyIiwiY2FuRXhwYW5kIiwiZGVmYXVsdFBhZ2VJbmRleCIsImRlZmF1bHRQYWdlU2l6ZSIsImdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUiLCJwYWdlSW5kZXgiLCJwYWdlU2l6ZSIsIlJvd1BhZ2luYXRpb24iLCJwYWdpbmF0aW9uIiwib25QYWdpbmF0aW9uQ2hhbmdlIiwiX2F1dG9SZXNldFBhZ2VJbmRleCIsImF1dG9SZXNldFBhZ2VJbmRleCIsIm1hbnVhbFBhZ2luYXRpb24iLCJyZXNldFBhZ2VJbmRleCIsInNldFBhZ2luYXRpb24iLCJzYWZlVXBkYXRlciIsIm5ld1N0YXRlIiwicmVzZXRQYWdpbmF0aW9uIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwIiwic2V0UGFnZUluZGV4IiwibWF4UGFnZUluZGV4IiwicGFnZUNvdW50IiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiIsInJlc2V0UGFnZVNpemUiLCJfdGFibGUkaW5pdGlhbFN0YXRlJHAzIiwiX3RhYmxlJGluaXRpYWxTdGF0ZTIiLCJzZXRQYWdlU2l6ZSIsInRvcFJvd0luZGV4Iiwic2V0UGFnZUNvdW50IiwiX3RhYmxlJG9wdGlvbnMkcGFnZUNvIiwibmV3UGFnZUNvdW50IiwiZ2V0UGFnZU9wdGlvbnMiLCJnZXRQYWdlQ291bnQiLCJwYWdlT3B0aW9ucyIsImZpbGwiLCJnZXRDYW5QcmV2aW91c1BhZ2UiLCJnZXRDYW5OZXh0UGFnZSIsInByZXZpb3VzUGFnZSIsIm5leHRQYWdlIiwiZmlyc3RQYWdlIiwibGFzdFBhZ2UiLCJnZXRQYWdpbmF0aW9uUm93TW9kZWwiLCJfZ2V0UGFnaW5hdGlvblJvd01vZGVsIiwiX3RhYmxlJG9wdGlvbnMkcGFnZUNvMiIsImNlaWwiLCJnZXRSb3dDb3VudCIsIl90YWJsZSRvcHRpb25zJHJvd0NvdSIsInJvd0NvdW50Iiwicm93cyIsImdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUiLCJ0b3AiLCJib3R0b20iLCJSb3dQaW5uaW5nIiwicm93UGlubmluZyIsIm9uUm93UGlubmluZ0NoYW5nZSIsImluY2x1ZGVMZWFmUm93cyIsImluY2x1ZGVQYXJlbnRSb3dzIiwibGVhZlJvd0lkcyIsInBhcmVudFJvd0lkcyIsInNldFJvd1Bpbm5pbmciLCJfb2xkJHRvcDMiLCJfb2xkJGJvdHRvbTMiLCJfb2xkJHRvcCIsIl9vbGQkYm90dG9tIiwiaGFzIiwiX29sZCR0b3AyIiwiX29sZCRib3R0b20yIiwiZW5hYmxlUm93UGlubmluZyIsImlzVG9wIiwiaXNCb3R0b20iLCJfcmVmNCIsIl92aXNpYmxlUGlubmVkUm93SWRzJCIsInZpc2libGVQaW5uZWRSb3dJZHMiLCJnZXRUb3BSb3dzIiwiZ2V0Qm90dG9tUm93cyIsIl9yZWY1IiwicmVzZXRSb3dQaW5uaW5nIiwiX3RhYmxlJGluaXRpYWxTdGF0ZSRyIiwiZ2V0SXNTb21lUm93c1Bpbm5lZCIsIl9waW5uaW5nU3RhdGUkdG9wIiwiX3Bpbm5pbmdTdGF0ZSRib3R0b20iLCJfZ2V0UGlubmVkUm93cyIsInZpc2libGVSb3dzIiwicGlubmVkUm93SWRzIiwiX3RhYmxlJG9wdGlvbnMka2VlcFBpIiwia2VlcFBpbm5lZFJvd3MiLCJhbGxSb3dzIiwidG9wUGlubmVkUm93SWRzIiwiYm90dG9tUGlubmVkUm93SWRzIiwiZ2V0Q2VudGVyUm93cyIsInRvcEFuZEJvdHRvbSIsIlJvd1NlbGVjdGlvbiIsInJvd1NlbGVjdGlvbiIsIm9uUm93U2VsZWN0aW9uQ2hhbmdlIiwiZW5hYmxlUm93U2VsZWN0aW9uIiwiZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24iLCJlbmFibGVTdWJSb3dTZWxlY3Rpb24iLCJzZXRSb3dTZWxlY3Rpb24iLCJyZXNldFJvd1NlbGVjdGlvbiIsInRvZ2dsZUFsbFJvd3NTZWxlY3RlZCIsImdldElzQWxsUm93c1NlbGVjdGVkIiwicHJlR3JvdXBlZEZsYXRSb3dzIiwiZ2V0Q2FuU2VsZWN0IiwidG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZCIsInJlc29sdmVkVmFsdWUiLCJnZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJtdXRhdGVSb3dJc1NlbGVjdGVkIiwiZ2V0UHJlU2VsZWN0ZWRSb3dNb2RlbCIsImdldFNlbGVjdGVkUm93TW9kZWwiLCJyb3dNb2RlbCIsInNlbGVjdFJvd3NGbiIsImdldEZpbHRlcmVkU2VsZWN0ZWRSb3dNb2RlbCIsImdldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsIiwiaXNBbGxSb3dzU2VsZWN0ZWQiLCJwYWdpbmF0aW9uRmxhdFJvd3MiLCJpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQiLCJnZXRJc1NvbWVSb3dzU2VsZWN0ZWQiLCJfdGFibGUkZ2V0U3RhdGUkcm93U2UiLCJ0b3RhbFNlbGVjdGVkIiwiZ2V0SXNTb21lUGFnZVJvd3NTZWxlY3RlZCIsImdldElzU2VsZWN0ZWQiLCJnZXRJc1NvbWVTZWxlY3RlZCIsImdldFRvZ2dsZUFsbFJvd3NTZWxlY3RlZEhhbmRsZXIiLCJnZXRUb2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkSGFuZGxlciIsInRvZ2dsZVNlbGVjdGVkIiwiaXNTZWxlY3RlZCIsIl9vcHRzJHNlbGVjdENoaWxkcmVuIiwic2VsZWN0ZWRSb3dJZHMiLCJzZWxlY3RDaGlsZHJlbiIsImlzUm93U2VsZWN0ZWQiLCJpc1N1YlJvd1NlbGVjdGVkIiwiZ2V0SXNBbGxTdWJSb3dzU2VsZWN0ZWQiLCJnZXRDYW5TZWxlY3RTdWJSb3dzIiwiZ2V0Q2FuTXVsdGlTZWxlY3QiLCJfdGFibGUkb3B0aW9ucyRlbmFibGUzIiwiZ2V0VG9nZ2xlU2VsZWN0ZWRIYW5kbGVyIiwiY2FuU2VsZWN0IiwiaW5jbHVkZUNoaWxkcmVuIiwibmV3U2VsZWN0ZWRGbGF0Um93cyIsIm5ld1NlbGVjdGVkUm93c0J5SWQiLCJyZWN1cnNlUm93cyIsIl9yb3ckc3ViUm93czIiLCJzZWxlY3Rpb24iLCJfc2VsZWN0aW9uJHJvdyRpZCIsIl9yb3ckc3ViUm93czMiLCJhbGxDaGlsZHJlblNlbGVjdGVkIiwic29tZVNlbGVjdGVkIiwic3ViUm93Iiwic3ViUm93Q2hpbGRyZW5TZWxlY3RlZCIsInJlU3BsaXRBbHBoYU51bWVyaWMiLCJhbHBoYW51bWVyaWMiLCJyb3dBIiwicm93QiIsImNvbXBhcmVBbHBoYW51bWVyaWMiLCJhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlIiwidGV4dCIsImNvbXBhcmVCYXNpYyIsInRleHRDYXNlU2Vuc2l0aXZlIiwiZGF0ZXRpbWUiLCJiYXNpYyIsImFTdHIiLCJiU3RyIiwiYWEiLCJiYiIsImFuIiwicGFyc2VJbnQiLCJibiIsImNvbWJvIiwic29ydGluZ0ZucyIsIlJvd1NvcnRpbmciLCJzb3J0aW5nIiwic29ydGluZ0ZuIiwic29ydFVuZGVmaW5lZCIsIm9uU29ydGluZ0NoYW5nZSIsImlzTXVsdGlTb3J0RXZlbnQiLCJzaGlmdEtleSIsImdldEF1dG9Tb3J0aW5nRm4iLCJmaXJzdFJvd3MiLCJpc1N0cmluZyIsImdldEF1dG9Tb3J0RGlyIiwiZ2V0U29ydGluZ0ZuIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluIiwiX3RhYmxlJG9wdGlvbnMkc29ydGluMiIsInRvZ2dsZVNvcnRpbmciLCJkZXNjIiwibXVsdGkiLCJuZXh0U29ydGluZ09yZGVyIiwiZ2V0TmV4dFNvcnRpbmdPcmRlciIsImhhc01hbnVhbFZhbHVlIiwic2V0U29ydGluZyIsImV4aXN0aW5nU29ydGluZyIsImV4aXN0aW5nSW5kZXgiLCJuZXdTb3J0aW5nIiwic29ydEFjdGlvbiIsIm5leHREZXNjIiwiZ2V0Q2FuTXVsdGlTb3J0IiwiX3RhYmxlJG9wdGlvbnMkbWF4TXVsIiwibWF4TXVsdGlTb3J0Q29sQ291bnQiLCJnZXRGaXJzdFNvcnREaXIiLCJfY29sdW1uJGNvbHVtbkRlZiRzb3IiLCJzb3J0RGVzY0ZpcnN0IiwiZmlyc3RTb3J0RGlyZWN0aW9uIiwiaXNTb3J0ZWQiLCJnZXRJc1NvcnRlZCIsImVuYWJsZVNvcnRpbmdSZW1vdmFsIiwiZW5hYmxlTXVsdGlSZW1vdmUiLCJnZXRDYW5Tb3J0IiwiZW5hYmxlU29ydGluZyIsIl9jb2x1bW4kY29sdW1uRGVmJGVuYTIiLCJlbmFibGVNdWx0aVNvcnQiLCJfdGFibGUkZ2V0U3RhdGUkc29ydGkiLCJjb2x1bW5Tb3J0IiwiZ2V0U29ydEluZGV4IiwiX3RhYmxlJGdldFN0YXRlJHNvcnRpMiIsIl90YWJsZSRnZXRTdGF0ZSRzb3J0aTMiLCJjbGVhclNvcnRpbmciLCJnZXRUb2dnbGVTb3J0aW5nSGFuZGxlciIsImNhblNvcnQiLCJyZXNldFNvcnRpbmciLCJfdGFibGUkaW5pdGlhbFN0YXRlJHMiLCJnZXRQcmVTb3J0ZWRSb3dNb2RlbCIsIl9nZXRTb3J0ZWRSb3dNb2RlbCIsIm1hbnVhbFNvcnRpbmciLCJidWlsdEluRmVhdHVyZXMiLCJfb3B0aW9ucyRfZmVhdHVyZXMiLCJfb3B0aW9ucyRpbml0aWFsU3RhdGUiLCJkZWJ1Z1RhYmxlIiwiZGVmYXVsdE9wdGlvbnMiLCJhc3NpZ24iLCJtZXJnZU9wdGlvbnMiLCJjb3JlSW5pdGlhbFN0YXRlIiwiX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0IiwicXVldWVkVGltZW91dCIsImNvcmVJbnN0YW5jZSIsImNiIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiY2F0Y2giLCJlcnJvciIsInNldFRpbWVvdXQiLCJyZXNldCIsInNldE9wdGlvbnMiLCJuZXdPcHRpb25zIiwib25TdGF0ZUNoYW5nZSIsIl9nZXRSb3dJZCIsImdldFJvd0lkIiwiX2dldENvcmVSb3dNb2RlbCIsInNlYXJjaEFsbCIsIl9kZWZhdWx0Q29sdW1uIiwiX3Byb3BzJHJlbmRlclZhbHVlJHRvIiwiX3Byb3BzJHJlbmRlclZhbHVlIiwiX2dldENvbHVtbkRlZnMiLCJjb2x1bW5EZWZzIiwicmVjdXJzZUNvbHVtbnMiLCJncm91cGluZ0NvbHVtbkRlZiIsIl9nZXRBbGxGbGF0Q29sdW1uc0J5SWQiLCJmbGF0Q29sdW1ucyIsImRhdGEiLCJhY2Nlc3NSb3dzIiwib3JpZ2luYWxSb3dzIiwiZ2V0U3ViUm93cyIsIl9yb3ckb3JpZ2luYWxTdWJSb3dzIiwib3JpZ2luYWxTdWJSb3dzIiwiZXhwYW5kUm93cyIsImV4cGFuZGVkUm93cyIsImhhbmRsZVJvdyIsIl90YWJsZSRnZXRDb2x1bW4iLCJmYWNldGVkUm93TW9kZWwiLCJfZmFjZXRlZFJvd01vZGVsJGZsYXQiLCJmaXJzdFZhbHVlIiwiZmFjZXRlZE1pbk1heFZhbHVlcyIsImoiLCJmaWx0ZXJSb3dzIiwiZmlsdGVyUm93SW1wbCIsImZpbHRlclJvd01vZGVsRnJvbUxlYWZzIiwiZmlsdGVyUm93TW9kZWxGcm9tUm9vdCIsInJvd3NUb0ZpbHRlciIsImZpbHRlclJvdyIsIl90YWJsZSRvcHRpb25zJG1heExlYSIsIm5ld0ZpbHRlcmVkRmxhdFJvd3MiLCJuZXdGaWx0ZXJlZFJvd3NCeUlkIiwicmVjdXJzZUZpbHRlclJvd3MiLCJuZXdSb3ciLCJfdGFibGUkb3B0aW9ucyRtYXhMZWEyIiwicGFzcyIsInByZVJvd01vZGVsIiwiZmlsdGVyYWJsZUlkcyIsImZpbHRlclJvd3NJbXBsIiwiZmFjZXRlZFVuaXF1ZVZhbHVlcyIsIl9mYWNldGVkVW5pcXVlVmFsdWVzJCIsInNldCIsImdldCIsInJlc29sdmVkQ29sdW1uRmlsdGVycyIsInJlc29sdmVkR2xvYmFsRmlsdGVycyIsIl9maWx0ZXJGbiRyZXNvbHZlRmlsdCIsImdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMiLCJfZ2xvYmFsRmlsdGVyRm4kcmVzb2wiLCJjdXJyZW50Q29sdW1uRmlsdGVyIiwiY3VycmVudEdsb2JhbEZpbHRlciIsImZpbHRlck1ldGEiLCJfX2dsb2JhbF9fIiwiZXhpc3RpbmdHcm91cGluZyIsImdyb3VwZWRGbGF0Um93cyIsImdyb3VwZWRSb3dzQnlJZCIsImdyb3VwVXBSZWN1cnNpdmVseSIsInJvd0dyb3Vwc01hcCIsImdyb3VwQnkiLCJhZ2dyZWdhdGVkR3JvdXBlZFJvd3MiLCJlbnRyaWVzIiwiZ3JvdXBpbmdWYWx1ZSIsImdyb3VwZWRSb3dzIiwiX2dyb3VwZWRSb3dzJDAkZ2V0VmFsIiwiYWdncmVnYXRlRm4iLCJncm91cE1hcCIsInJlc0tleSIsInByZXZpb3VzIiwicGFnZVN0YXJ0IiwicGFnZUVuZCIsInBhZ2luYXRlZFJvd01vZGVsIiwic29ydGluZ1N0YXRlIiwic29ydGVkRmxhdFJvd3MiLCJhdmFpbGFibGVTb3J0aW5nIiwiY29sdW1uSW5mb0J5SWQiLCJzb3J0RW50cnkiLCJpbnZlcnRTb3J0aW5nIiwic29ydERhdGEiLCJzb3J0ZWREYXRhIiwiX3NvcnRFbnRyeSRkZXNjIiwiY29sdW1uSW5mbyIsImlzRGVzYyIsInNvcnRJbnQiLCJhVmFsdWUiLCJiVmFsdWUiLCJhVW5kZWZpbmVkIiwiYlVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n");

/***/ })

};
;